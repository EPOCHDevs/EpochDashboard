/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/chart_def.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@epochlab/epoch-protos/dist/chart_def.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\n\n// node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\") (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n      else (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n      if (typeof Float64Array !== \"undefined\") (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n      else (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length; )\n          buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n      }\n      return this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// src/chart_def.js\nvar require_chart_def = __commonJS({\n  \"src/chart_def.js\"(exports2, module2) {\n    var $protobuf = require_minimal2();\n    var $Reader = $protobuf.Reader;\n    var $Writer = $protobuf.Writer;\n    var $util = $protobuf.util;\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.epoch_proto = function() {\n      var epoch_proto = {};\n      epoch_proto.AxisDef = function() {\n        function AxisDef(properties) {\n          this.categories = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        AxisDef.prototype.type = null;\n        AxisDef.prototype.label = null;\n        AxisDef.prototype.categories = $util.emptyArray;\n        var $oneOfFields;\n        Object.defineProperty(AxisDef.prototype, \"_type\", {\n          get: $util.oneOfGetter($oneOfFields = [\"type\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(AxisDef.prototype, \"_label\", {\n          get: $util.oneOfGetter($oneOfFields = [\"label\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        AxisDef.create = function create(properties) {\n          return new AxisDef(properties);\n        };\n        AxisDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.label != null && Object.hasOwnProperty.call(message, \"label\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.label);\n          if (message.categories != null && message.categories.length)\n            for (var i = 0; i < message.categories.length; ++i)\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.categories[i]);\n          return writer;\n        };\n        AxisDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        AxisDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.AxisDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.label = reader.string();\n                break;\n              }\n              case 3: {\n                if (!(message.categories && message.categories.length))\n                  message.categories = [];\n                message.categories.push(reader.string());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        AxisDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        AxisDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.type != null && message.hasOwnProperty(\"type\")) {\n            properties._type = 1;\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n                break;\n            }\n          }\n          if (message.label != null && message.hasOwnProperty(\"label\")) {\n            properties._label = 1;\n            if (!$util.isString(message.label))\n              return \"label: string expected\";\n          }\n          if (message.categories != null && message.hasOwnProperty(\"categories\")) {\n            if (!Array.isArray(message.categories))\n              return \"categories: array expected\";\n            for (var i = 0; i < message.categories.length; ++i)\n              if (!$util.isString(message.categories[i]))\n                return \"categories: string[] expected\";\n          }\n          return null;\n        };\n        AxisDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.AxisDef)\n            return object;\n          var message = new $root.epoch_proto.AxisDef();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"AxisUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"AxisLinear\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"AxisLogarithmic\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"AxisDateTime\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"AxisCategory\":\n            case 4:\n              message.type = 4;\n              break;\n          }\n          if (object.label != null)\n            message.label = String(object.label);\n          if (object.categories) {\n            if (!Array.isArray(object.categories))\n              throw TypeError(\".epoch_proto.AxisDef.categories: array expected\");\n            message.categories = [];\n            for (var i = 0; i < object.categories.length; ++i)\n              message.categories[i] = String(object.categories[i]);\n          }\n          return message;\n        };\n        AxisDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.categories = [];\n          if (message.type != null && message.hasOwnProperty(\"type\")) {\n            object.type = options.enums === String ? $root.epoch_proto.AxisType[message.type] === void 0 ? message.type : $root.epoch_proto.AxisType[message.type] : message.type;\n            if (options.oneofs)\n              object._type = \"type\";\n          }\n          if (message.label != null && message.hasOwnProperty(\"label\")) {\n            object.label = message.label;\n            if (options.oneofs)\n              object._label = \"label\";\n          }\n          if (message.categories && message.categories.length) {\n            object.categories = [];\n            for (var j = 0; j < message.categories.length; ++j)\n              object.categories[j] = message.categories[j];\n          }\n          return object;\n        };\n        AxisDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        AxisDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.AxisDef\";\n        };\n        return AxisDef;\n      }();\n      epoch_proto.ChartDef = function() {\n        function ChartDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        ChartDef.prototype.id = \"\";\n        ChartDef.prototype.title = \"\";\n        ChartDef.prototype.type = 0;\n        ChartDef.prototype.category = \"\";\n        ChartDef.prototype.yAxis = null;\n        ChartDef.prototype.xAxis = null;\n        var $oneOfFields;\n        Object.defineProperty(ChartDef.prototype, \"_yAxis\", {\n          get: $util.oneOfGetter($oneOfFields = [\"yAxis\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(ChartDef.prototype, \"_xAxis\", {\n          get: $util.oneOfGetter($oneOfFields = [\"xAxis\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        ChartDef.create = function create(properties) {\n          return new ChartDef(properties);\n        };\n        ChartDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.id);\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.title);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).string(message.category);\n          if (message.yAxis != null && Object.hasOwnProperty.call(message, \"yAxis\"))\n            $root.epoch_proto.AxisDef.encode(message.yAxis, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          if (message.xAxis != null && Object.hasOwnProperty.call(message, \"xAxis\"))\n            $root.epoch_proto.AxisDef.encode(message.xAxis, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          return writer;\n        };\n        ChartDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        ChartDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.ChartDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.id = reader.string();\n                break;\n              }\n              case 2: {\n                message.title = reader.string();\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              case 4: {\n                message.category = reader.string();\n                break;\n              }\n              case 5: {\n                message.yAxis = $root.epoch_proto.AxisDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 6: {\n                message.xAxis = $root.epoch_proto.AxisDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ChartDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        ChartDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.id != null && message.hasOwnProperty(\"id\")) {\n            if (!$util.isString(message.id))\n              return \"id: string expected\";\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.yAxis != null && message.hasOwnProperty(\"yAxis\")) {\n            properties._yAxis = 1;\n            {\n              var error = $root.epoch_proto.AxisDef.verify(message.yAxis);\n              if (error)\n                return \"yAxis.\" + error;\n            }\n          }\n          if (message.xAxis != null && message.hasOwnProperty(\"xAxis\")) {\n            properties._xAxis = 1;\n            {\n              var error = $root.epoch_proto.AxisDef.verify(message.xAxis);\n              if (error)\n                return \"xAxis.\" + error;\n            }\n          }\n          return null;\n        };\n        ChartDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.ChartDef)\n            return object;\n          var message = new $root.epoch_proto.ChartDef();\n          if (object.id != null)\n            message.id = String(object.id);\n          if (object.title != null)\n            message.title = String(object.title);\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.yAxis != null) {\n            if (typeof object.yAxis !== \"object\")\n              throw TypeError(\".epoch_proto.ChartDef.yAxis: object expected\");\n            message.yAxis = $root.epoch_proto.AxisDef.fromObject(object.yAxis);\n          }\n          if (object.xAxis != null) {\n            if (typeof object.xAxis !== \"object\")\n              throw TypeError(\".epoch_proto.ChartDef.xAxis: object expected\");\n            message.xAxis = $root.epoch_proto.AxisDef.fromObject(object.xAxis);\n          }\n          return message;\n        };\n        ChartDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.id = \"\";\n            object.title = \"\";\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n          }\n          if (message.id != null && message.hasOwnProperty(\"id\"))\n            object.id = message.id;\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.yAxis != null && message.hasOwnProperty(\"yAxis\")) {\n            object.yAxis = $root.epoch_proto.AxisDef.toObject(message.yAxis, options);\n            if (options.oneofs)\n              object._yAxis = \"yAxis\";\n          }\n          if (message.xAxis != null && message.hasOwnProperty(\"xAxis\")) {\n            object.xAxis = $root.epoch_proto.AxisDef.toObject(message.xAxis, options);\n            if (options.oneofs)\n              object._xAxis = \"xAxis\";\n          }\n          return object;\n        };\n        ChartDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        ChartDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.ChartDef\";\n        };\n        return ChartDef;\n      }();\n      epoch_proto.StraightLineDef = function() {\n        function StraightLineDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        StraightLineDef.prototype.title = \"\";\n        StraightLineDef.prototype.value = 0;\n        StraightLineDef.prototype.vertical = false;\n        StraightLineDef.create = function create(properties) {\n          return new StraightLineDef(properties);\n        };\n        StraightLineDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.title);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.value);\n          if (message.vertical != null && Object.hasOwnProperty.call(message, \"vertical\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).bool(message.vertical);\n          return writer;\n        };\n        StraightLineDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        StraightLineDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.StraightLineDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.title = reader.string();\n                break;\n              }\n              case 2: {\n                message.value = reader.double();\n                break;\n              }\n              case 3: {\n                message.vertical = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        StraightLineDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        StraightLineDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\")) {\n            if (typeof message.vertical !== \"boolean\")\n              return \"vertical: boolean expected\";\n          }\n          return null;\n        };\n        StraightLineDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.StraightLineDef)\n            return object;\n          var message = new $root.epoch_proto.StraightLineDef();\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.value != null)\n            message.value = Number(object.value);\n          if (object.vertical != null)\n            message.vertical = Boolean(object.vertical);\n          return message;\n        };\n        StraightLineDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.title = \"\";\n            object.value = 0;\n            object.vertical = false;\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\"))\n            object.vertical = message.vertical;\n          return object;\n        };\n        StraightLineDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        StraightLineDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.StraightLineDef\";\n        };\n        return StraightLineDef;\n      }();\n      epoch_proto.Band = function() {\n        function Band(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Band.prototype.from = null;\n        Band.prototype.to = null;\n        Band.create = function create(properties) {\n          return new Band(properties);\n        };\n        Band.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.from != null && Object.hasOwnProperty.call(message, \"from\"))\n            $root.epoch_proto.Scalar.encode(message.from, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.to != null && Object.hasOwnProperty.call(message, \"to\"))\n            $root.epoch_proto.Scalar.encode(message.to, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          return writer;\n        };\n        Band.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Band.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Band();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.from = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.to = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Band.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Band.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.from != null && message.hasOwnProperty(\"from\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.from);\n            if (error)\n              return \"from.\" + error;\n          }\n          if (message.to != null && message.hasOwnProperty(\"to\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.to);\n            if (error)\n              return \"to.\" + error;\n          }\n          return null;\n        };\n        Band.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Band)\n            return object;\n          var message = new $root.epoch_proto.Band();\n          if (object.from != null) {\n            if (typeof object.from !== \"object\")\n              throw TypeError(\".epoch_proto.Band.from: object expected\");\n            message.from = $root.epoch_proto.Scalar.fromObject(object.from);\n          }\n          if (object.to != null) {\n            if (typeof object.to !== \"object\")\n              throw TypeError(\".epoch_proto.Band.to: object expected\");\n            message.to = $root.epoch_proto.Scalar.fromObject(object.to);\n          }\n          return message;\n        };\n        Band.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.from = null;\n            object.to = null;\n          }\n          if (message.from != null && message.hasOwnProperty(\"from\"))\n            object.from = $root.epoch_proto.Scalar.toObject(message.from, options);\n          if (message.to != null && message.hasOwnProperty(\"to\"))\n            object.to = $root.epoch_proto.Scalar.toObject(message.to, options);\n          return object;\n        };\n        Band.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Band.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Band\";\n        };\n        return Band;\n      }();\n      epoch_proto.Point = function() {\n        function Point(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Point.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        Point.prototype.y = 0;\n        Point.create = function create(properties) {\n          return new Point(properties);\n        };\n        Point.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int64(message.x);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.y);\n          return writer;\n        };\n        Point.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Point.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Point();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.int64();\n                break;\n              }\n              case 2: {\n                message.y = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Point.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Point.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (typeof message.y !== \"number\")\n              return \"y: number expected\";\n          }\n          return null;\n        };\n        Point.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Point)\n            return object;\n          var message = new $root.epoch_proto.Point();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = false;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber();\n          }\n          if (object.y != null)\n            message.y = Number(object.y);\n          return message;\n        };\n        Point.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            object.y = 0;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber() : message.x;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;\n          return object;\n        };\n        Point.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Point\";\n        };\n        return Point;\n      }();\n      epoch_proto.Line = function() {\n        function Line(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Line.prototype.data = $util.emptyArray;\n        Line.prototype.name = \"\";\n        Line.prototype.dashStyle = null;\n        Line.prototype.lineWidth = null;\n        var $oneOfFields;\n        Object.defineProperty(Line.prototype, \"_dashStyle\", {\n          get: $util.oneOfGetter($oneOfFields = [\"dashStyle\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(Line.prototype, \"_lineWidth\", {\n          get: $util.oneOfGetter($oneOfFields = [\"lineWidth\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Line.create = function create(properties) {\n          return new Line(properties);\n        };\n        Line.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.Point.encode(message.data[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.name);\n          if (message.dashStyle != null && Object.hasOwnProperty.call(message, \"dashStyle\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.dashStyle);\n          if (message.lineWidth != null && Object.hasOwnProperty.call(message, \"lineWidth\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.lineWidth);\n          return writer;\n        };\n        Line.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Line.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Line();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.Point.decode(reader, reader.uint32()));\n                break;\n              }\n              case 2: {\n                message.name = reader.string();\n                break;\n              }\n              case 3: {\n                message.dashStyle = reader.int32();\n                break;\n              }\n              case 4: {\n                message.lineWidth = reader.uint32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Line.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Line.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.Point.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.dashStyle != null && message.hasOwnProperty(\"dashStyle\")) {\n            properties._dashStyle = 1;\n            switch (message.dashStyle) {\n              default:\n                return \"dashStyle: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          }\n          if (message.lineWidth != null && message.hasOwnProperty(\"lineWidth\")) {\n            properties._lineWidth = 1;\n            if (!$util.isInteger(message.lineWidth))\n              return \"lineWidth: integer expected\";\n          }\n          return null;\n        };\n        Line.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Line)\n            return object;\n          var message = new $root.epoch_proto.Line();\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.Line.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Line.data: object expected\");\n              message.data[i] = $root.epoch_proto.Point.fromObject(object.data[i]);\n            }\n          }\n          if (object.name != null)\n            message.name = String(object.name);\n          switch (object.dashStyle) {\n            default:\n              if (typeof object.dashStyle === \"number\") {\n                message.dashStyle = object.dashStyle;\n                break;\n              }\n              break;\n            case \"DashStyleUnspecified\":\n            case 0:\n              message.dashStyle = 0;\n              break;\n            case \"Solid\":\n            case 1:\n              message.dashStyle = 1;\n              break;\n            case \"ShortDash\":\n            case 2:\n              message.dashStyle = 2;\n              break;\n            case \"ShortDot\":\n            case 3:\n              message.dashStyle = 3;\n              break;\n            case \"ShortDashDot\":\n            case 4:\n              message.dashStyle = 4;\n              break;\n            case \"ShortDashDotDot\":\n            case 5:\n              message.dashStyle = 5;\n              break;\n            case \"Dot\":\n            case 6:\n              message.dashStyle = 6;\n              break;\n            case \"Dash\":\n            case 7:\n              message.dashStyle = 7;\n              break;\n            case \"LongDash\":\n            case 8:\n              message.dashStyle = 8;\n              break;\n            case \"DashDot\":\n            case 9:\n              message.dashStyle = 9;\n              break;\n            case \"LongDashDot\":\n            case 10:\n              message.dashStyle = 10;\n              break;\n            case \"LongDashDotDot\":\n            case 11:\n              message.dashStyle = 11;\n              break;\n          }\n          if (object.lineWidth != null)\n            message.lineWidth = object.lineWidth >>> 0;\n          return message;\n        };\n        Line.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults)\n            object.name = \"\";\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.Point.toObject(message.data[j], options);\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.dashStyle != null && message.hasOwnProperty(\"dashStyle\")) {\n            object.dashStyle = options.enums === String ? $root.epoch_proto.DashStyle[message.dashStyle] === void 0 ? message.dashStyle : $root.epoch_proto.DashStyle[message.dashStyle] : message.dashStyle;\n            if (options.oneofs)\n              object._dashStyle = \"dashStyle\";\n          }\n          if (message.lineWidth != null && message.hasOwnProperty(\"lineWidth\")) {\n            object.lineWidth = message.lineWidth;\n            if (options.oneofs)\n              object._lineWidth = \"lineWidth\";\n          }\n          return object;\n        };\n        Line.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Line.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Line\";\n        };\n        return Line;\n      }();\n      epoch_proto.LinesDef = function() {\n        function LinesDef(properties) {\n          this.lines = [];\n          this.straightLines = [];\n          this.yPlotBands = [];\n          this.xPlotBands = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        LinesDef.prototype.chartDef = null;\n        LinesDef.prototype.lines = $util.emptyArray;\n        LinesDef.prototype.straightLines = $util.emptyArray;\n        LinesDef.prototype.yPlotBands = $util.emptyArray;\n        LinesDef.prototype.xPlotBands = $util.emptyArray;\n        LinesDef.prototype.overlay = null;\n        LinesDef.prototype.stacked = false;\n        var $oneOfFields;\n        Object.defineProperty(LinesDef.prototype, \"_overlay\", {\n          get: $util.oneOfGetter($oneOfFields = [\"overlay\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        LinesDef.create = function create(properties) {\n          return new LinesDef(properties);\n        };\n        LinesDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.lines != null && message.lines.length)\n            for (var i = 0; i < message.lines.length; ++i)\n              $root.epoch_proto.Line.encode(message.lines[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.yPlotBands != null && message.yPlotBands.length)\n            for (var i = 0; i < message.yPlotBands.length; ++i)\n              $root.epoch_proto.Band.encode(message.yPlotBands[i], writer.uint32(\n                /* id 4, wireType 2 =*/\n                34\n              ).fork()).ldelim();\n          if (message.xPlotBands != null && message.xPlotBands.length)\n            for (var i = 0; i < message.xPlotBands.length; ++i)\n              $root.epoch_proto.Band.encode(message.xPlotBands[i], writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n          if (message.overlay != null && Object.hasOwnProperty.call(message, \"overlay\"))\n            $root.epoch_proto.Line.encode(message.overlay, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          if (message.stacked != null && Object.hasOwnProperty.call(message, \"stacked\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).bool(message.stacked);\n          return writer;\n        };\n        LinesDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        LinesDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.LinesDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.lines && message.lines.length))\n                  message.lines = [];\n                message.lines.push($root.epoch_proto.Line.decode(reader, reader.uint32()));\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                if (!(message.yPlotBands && message.yPlotBands.length))\n                  message.yPlotBands = [];\n                message.yPlotBands.push($root.epoch_proto.Band.decode(reader, reader.uint32()));\n                break;\n              }\n              case 5: {\n                if (!(message.xPlotBands && message.xPlotBands.length))\n                  message.xPlotBands = [];\n                message.xPlotBands.push($root.epoch_proto.Band.decode(reader, reader.uint32()));\n                break;\n              }\n              case 6: {\n                message.overlay = $root.epoch_proto.Line.decode(reader, reader.uint32());\n                break;\n              }\n              case 7: {\n                message.stacked = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        LinesDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        LinesDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.lines != null && message.hasOwnProperty(\"lines\")) {\n            if (!Array.isArray(message.lines))\n              return \"lines: array expected\";\n            for (var i = 0; i < message.lines.length; ++i) {\n              var error = $root.epoch_proto.Line.verify(message.lines[i]);\n              if (error)\n                return \"lines.\" + error;\n            }\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.yPlotBands != null && message.hasOwnProperty(\"yPlotBands\")) {\n            if (!Array.isArray(message.yPlotBands))\n              return \"yPlotBands: array expected\";\n            for (var i = 0; i < message.yPlotBands.length; ++i) {\n              var error = $root.epoch_proto.Band.verify(message.yPlotBands[i]);\n              if (error)\n                return \"yPlotBands.\" + error;\n            }\n          }\n          if (message.xPlotBands != null && message.hasOwnProperty(\"xPlotBands\")) {\n            if (!Array.isArray(message.xPlotBands))\n              return \"xPlotBands: array expected\";\n            for (var i = 0; i < message.xPlotBands.length; ++i) {\n              var error = $root.epoch_proto.Band.verify(message.xPlotBands[i]);\n              if (error)\n                return \"xPlotBands.\" + error;\n            }\n          }\n          if (message.overlay != null && message.hasOwnProperty(\"overlay\")) {\n            properties._overlay = 1;\n            {\n              var error = $root.epoch_proto.Line.verify(message.overlay);\n              if (error)\n                return \"overlay.\" + error;\n            }\n          }\n          if (message.stacked != null && message.hasOwnProperty(\"stacked\")) {\n            if (typeof message.stacked !== \"boolean\")\n              return \"stacked: boolean expected\";\n          }\n          return null;\n        };\n        LinesDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.LinesDef)\n            return object;\n          var message = new $root.epoch_proto.LinesDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.LinesDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.lines) {\n            if (!Array.isArray(object.lines))\n              throw TypeError(\".epoch_proto.LinesDef.lines: array expected\");\n            message.lines = [];\n            for (var i = 0; i < object.lines.length; ++i) {\n              if (typeof object.lines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.lines: object expected\");\n              message.lines[i] = $root.epoch_proto.Line.fromObject(object.lines[i]);\n            }\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.LinesDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.yPlotBands) {\n            if (!Array.isArray(object.yPlotBands))\n              throw TypeError(\".epoch_proto.LinesDef.yPlotBands: array expected\");\n            message.yPlotBands = [];\n            for (var i = 0; i < object.yPlotBands.length; ++i) {\n              if (typeof object.yPlotBands[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.yPlotBands: object expected\");\n              message.yPlotBands[i] = $root.epoch_proto.Band.fromObject(object.yPlotBands[i]);\n            }\n          }\n          if (object.xPlotBands) {\n            if (!Array.isArray(object.xPlotBands))\n              throw TypeError(\".epoch_proto.LinesDef.xPlotBands: array expected\");\n            message.xPlotBands = [];\n            for (var i = 0; i < object.xPlotBands.length; ++i) {\n              if (typeof object.xPlotBands[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.xPlotBands: object expected\");\n              message.xPlotBands[i] = $root.epoch_proto.Band.fromObject(object.xPlotBands[i]);\n            }\n          }\n          if (object.overlay != null) {\n            if (typeof object.overlay !== \"object\")\n              throw TypeError(\".epoch_proto.LinesDef.overlay: object expected\");\n            message.overlay = $root.epoch_proto.Line.fromObject(object.overlay);\n          }\n          if (object.stacked != null)\n            message.stacked = Boolean(object.stacked);\n          return message;\n        };\n        LinesDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.lines = [];\n            object.straightLines = [];\n            object.yPlotBands = [];\n            object.xPlotBands = [];\n          }\n          if (options.defaults) {\n            object.chartDef = null;\n            object.stacked = false;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.lines && message.lines.length) {\n            object.lines = [];\n            for (var j = 0; j < message.lines.length; ++j)\n              object.lines[j] = $root.epoch_proto.Line.toObject(message.lines[j], options);\n          }\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.yPlotBands && message.yPlotBands.length) {\n            object.yPlotBands = [];\n            for (var j = 0; j < message.yPlotBands.length; ++j)\n              object.yPlotBands[j] = $root.epoch_proto.Band.toObject(message.yPlotBands[j], options);\n          }\n          if (message.xPlotBands && message.xPlotBands.length) {\n            object.xPlotBands = [];\n            for (var j = 0; j < message.xPlotBands.length; ++j)\n              object.xPlotBands[j] = $root.epoch_proto.Band.toObject(message.xPlotBands[j], options);\n          }\n          if (message.overlay != null && message.hasOwnProperty(\"overlay\")) {\n            object.overlay = $root.epoch_proto.Line.toObject(message.overlay, options);\n            if (options.oneofs)\n              object._overlay = \"overlay\";\n          }\n          if (message.stacked != null && message.hasOwnProperty(\"stacked\"))\n            object.stacked = message.stacked;\n          return object;\n        };\n        LinesDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        LinesDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.LinesDef\";\n        };\n        return LinesDef;\n      }();\n      epoch_proto.HeatMapPoint = function() {\n        function HeatMapPoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HeatMapPoint.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        HeatMapPoint.prototype.y = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        HeatMapPoint.prototype.value = 0;\n        HeatMapPoint.create = function create(properties) {\n          return new HeatMapPoint(properties);\n        };\n        HeatMapPoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).uint64(message.x);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).uint64(message.y);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.value);\n          return writer;\n        };\n        HeatMapPoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HeatMapPoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HeatMapPoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.uint64();\n                break;\n              }\n              case 2: {\n                message.y = reader.uint64();\n                break;\n              }\n              case 3: {\n                message.value = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HeatMapPoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HeatMapPoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (!$util.isInteger(message.y) && !(message.y && $util.isInteger(message.y.low) && $util.isInteger(message.y.high)))\n              return \"y: integer|Long expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          return null;\n        };\n        HeatMapPoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HeatMapPoint)\n            return object;\n          var message = new $root.epoch_proto.HeatMapPoint();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = true;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber(true);\n          }\n          if (object.y != null) {\n            if ($util.Long)\n              (message.y = $util.Long.fromValue(object.y)).unsigned = true;\n            else if (typeof object.y === \"string\")\n              message.y = parseInt(object.y, 10);\n            else if (typeof object.y === \"number\")\n              message.y = object.y;\n            else if (typeof object.y === \"object\")\n              message.y = new $util.LongBits(object.y.low >>> 0, object.y.high >>> 0).toNumber(true);\n          }\n          if (object.value != null)\n            message.value = Number(object.value);\n          return message;\n        };\n        HeatMapPoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.y = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.y = options.longs === String ? \"0\" : 0;\n            object.value = 0;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber(true) : message.x;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            if (typeof message.y === \"number\")\n              object.y = options.longs === String ? String(message.y) : message.y;\n            else\n              object.y = options.longs === String ? $util.Long.prototype.toString.call(message.y) : options.longs === Number ? new $util.LongBits(message.y.low >>> 0, message.y.high >>> 0).toNumber(true) : message.y;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          return object;\n        };\n        HeatMapPoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HeatMapPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HeatMapPoint\";\n        };\n        return HeatMapPoint;\n      }();\n      epoch_proto.HeatMapDef = function() {\n        function HeatMapDef(properties) {\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HeatMapDef.prototype.chartDef = null;\n        HeatMapDef.prototype.points = $util.emptyArray;\n        HeatMapDef.create = function create(properties) {\n          return new HeatMapDef(properties);\n        };\n        HeatMapDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.HeatMapPoint.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        HeatMapDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HeatMapDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HeatMapDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.HeatMapPoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HeatMapDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HeatMapDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.HeatMapPoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        HeatMapDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HeatMapDef)\n            return object;\n          var message = new $root.epoch_proto.HeatMapDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.HeatMapDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.HeatMapDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.HeatMapDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.HeatMapPoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        HeatMapDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.points = [];\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.HeatMapPoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        HeatMapDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HeatMapDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HeatMapDef\";\n        };\n        return HeatMapDef;\n      }();\n      epoch_proto.BarDef = function() {\n        function BarDef(properties) {\n          this.straightLines = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BarDef.prototype.chartDef = null;\n        BarDef.prototype.data = null;\n        BarDef.prototype.straightLines = $util.emptyArray;\n        BarDef.prototype.barWidth = null;\n        BarDef.prototype.vertical = false;\n        var $oneOfFields;\n        Object.defineProperty(BarDef.prototype, \"_barWidth\", {\n          get: $util.oneOfGetter($oneOfFields = [\"barWidth\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        BarDef.create = function create(properties) {\n          return new BarDef(properties);\n        };\n        BarDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.Array.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.barWidth != null && Object.hasOwnProperty.call(message, \"barWidth\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.barWidth);\n          if (message.vertical != null && Object.hasOwnProperty.call(message, \"vertical\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.vertical);\n          return writer;\n        };\n        BarDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BarDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BarDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.Array.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.barWidth = reader.uint32();\n                break;\n              }\n              case 5: {\n                message.vertical = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BarDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BarDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.Array.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.barWidth != null && message.hasOwnProperty(\"barWidth\")) {\n            properties._barWidth = 1;\n            if (!$util.isInteger(message.barWidth))\n              return \"barWidth: integer expected\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\")) {\n            if (typeof message.vertical !== \"boolean\")\n              return \"vertical: boolean expected\";\n          }\n          return null;\n        };\n        BarDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BarDef)\n            return object;\n          var message = new $root.epoch_proto.BarDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.BarDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.BarDef.data: object expected\");\n            message.data = $root.epoch_proto.Array.fromObject(object.data);\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.BarDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BarDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.barWidth != null)\n            message.barWidth = object.barWidth >>> 0;\n          if (object.vertical != null)\n            message.vertical = Boolean(object.vertical);\n          return message;\n        };\n        BarDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.straightLines = [];\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n            object.vertical = false;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.Array.toObject(message.data, options);\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.barWidth != null && message.hasOwnProperty(\"barWidth\")) {\n            object.barWidth = message.barWidth;\n            if (options.oneofs)\n              object._barWidth = \"barWidth\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\"))\n            object.vertical = message.vertical;\n          return object;\n        };\n        BarDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BarDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BarDef\";\n        };\n        return BarDef;\n      }();\n      epoch_proto.HistogramDef = function() {\n        function HistogramDef(properties) {\n          this.straightLines = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HistogramDef.prototype.chartDef = null;\n        HistogramDef.prototype.data = null;\n        HistogramDef.prototype.straightLines = $util.emptyArray;\n        HistogramDef.prototype.binsCount = null;\n        var $oneOfFields;\n        Object.defineProperty(HistogramDef.prototype, \"_binsCount\", {\n          get: $util.oneOfGetter($oneOfFields = [\"binsCount\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        HistogramDef.create = function create(properties) {\n          return new HistogramDef(properties);\n        };\n        HistogramDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.Array.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.binsCount != null && Object.hasOwnProperty.call(message, \"binsCount\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.binsCount);\n          return writer;\n        };\n        HistogramDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HistogramDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HistogramDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.Array.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.binsCount = reader.uint32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HistogramDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HistogramDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.Array.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.binsCount != null && message.hasOwnProperty(\"binsCount\")) {\n            properties._binsCount = 1;\n            if (!$util.isInteger(message.binsCount))\n              return \"binsCount: integer expected\";\n          }\n          return null;\n        };\n        HistogramDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HistogramDef)\n            return object;\n          var message = new $root.epoch_proto.HistogramDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.HistogramDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.HistogramDef.data: object expected\");\n            message.data = $root.epoch_proto.Array.fromObject(object.data);\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.HistogramDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.HistogramDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.binsCount != null)\n            message.binsCount = object.binsCount >>> 0;\n          return message;\n        };\n        HistogramDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.straightLines = [];\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.Array.toObject(message.data, options);\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.binsCount != null && message.hasOwnProperty(\"binsCount\")) {\n            object.binsCount = message.binsCount;\n            if (options.oneofs)\n              object._binsCount = \"binsCount\";\n          }\n          return object;\n        };\n        HistogramDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HistogramDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HistogramDef\";\n        };\n        return HistogramDef;\n      }();\n      epoch_proto.BoxPlotDataPoint = function() {\n        function BoxPlotDataPoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDataPoint.prototype.low = 0;\n        BoxPlotDataPoint.prototype.q1 = 0;\n        BoxPlotDataPoint.prototype.median = 0;\n        BoxPlotDataPoint.prototype.q3 = 0;\n        BoxPlotDataPoint.prototype.high = 0;\n        BoxPlotDataPoint.create = function create(properties) {\n          return new BoxPlotDataPoint(properties);\n        };\n        BoxPlotDataPoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.low != null && Object.hasOwnProperty.call(message, \"low\"))\n            writer.uint32(\n              /* id 1, wireType 1 =*/\n              9\n            ).double(message.low);\n          if (message.q1 != null && Object.hasOwnProperty.call(message, \"q1\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.q1);\n          if (message.median != null && Object.hasOwnProperty.call(message, \"median\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.median);\n          if (message.q3 != null && Object.hasOwnProperty.call(message, \"q3\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.q3);\n          if (message.high != null && Object.hasOwnProperty.call(message, \"high\"))\n            writer.uint32(\n              /* id 5, wireType 1 =*/\n              41\n            ).double(message.high);\n          return writer;\n        };\n        BoxPlotDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDataPoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDataPoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.low = reader.double();\n                break;\n              }\n              case 2: {\n                message.q1 = reader.double();\n                break;\n              }\n              case 3: {\n                message.median = reader.double();\n                break;\n              }\n              case 4: {\n                message.q3 = reader.double();\n                break;\n              }\n              case 5: {\n                message.high = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDataPoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.low != null && message.hasOwnProperty(\"low\")) {\n            if (typeof message.low !== \"number\")\n              return \"low: number expected\";\n          }\n          if (message.q1 != null && message.hasOwnProperty(\"q1\")) {\n            if (typeof message.q1 !== \"number\")\n              return \"q1: number expected\";\n          }\n          if (message.median != null && message.hasOwnProperty(\"median\")) {\n            if (typeof message.median !== \"number\")\n              return \"median: number expected\";\n          }\n          if (message.q3 != null && message.hasOwnProperty(\"q3\")) {\n            if (typeof message.q3 !== \"number\")\n              return \"q3: number expected\";\n          }\n          if (message.high != null && message.hasOwnProperty(\"high\")) {\n            if (typeof message.high !== \"number\")\n              return \"high: number expected\";\n          }\n          return null;\n        };\n        BoxPlotDataPoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDataPoint)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDataPoint();\n          if (object.low != null)\n            message.low = Number(object.low);\n          if (object.q1 != null)\n            message.q1 = Number(object.q1);\n          if (object.median != null)\n            message.median = Number(object.median);\n          if (object.q3 != null)\n            message.q3 = Number(object.q3);\n          if (object.high != null)\n            message.high = Number(object.high);\n          return message;\n        };\n        BoxPlotDataPoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.low = 0;\n            object.q1 = 0;\n            object.median = 0;\n            object.q3 = 0;\n            object.high = 0;\n          }\n          if (message.low != null && message.hasOwnProperty(\"low\"))\n            object.low = options.json && !isFinite(message.low) ? String(message.low) : message.low;\n          if (message.q1 != null && message.hasOwnProperty(\"q1\"))\n            object.q1 = options.json && !isFinite(message.q1) ? String(message.q1) : message.q1;\n          if (message.median != null && message.hasOwnProperty(\"median\"))\n            object.median = options.json && !isFinite(message.median) ? String(message.median) : message.median;\n          if (message.q3 != null && message.hasOwnProperty(\"q3\"))\n            object.q3 = options.json && !isFinite(message.q3) ? String(message.q3) : message.q3;\n          if (message.high != null && message.hasOwnProperty(\"high\"))\n            object.high = options.json && !isFinite(message.high) ? String(message.high) : message.high;\n          return object;\n        };\n        BoxPlotDataPoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDataPoint\";\n        };\n        return BoxPlotDataPoint;\n      }();\n      epoch_proto.BoxPlotOutlier = function() {\n        function BoxPlotOutlier(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotOutlier.prototype.categoryIndex = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        BoxPlotOutlier.prototype.value = 0;\n        BoxPlotOutlier.create = function create(properties) {\n          return new BoxPlotOutlier(properties);\n        };\n        BoxPlotOutlier.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.categoryIndex != null && Object.hasOwnProperty.call(message, \"categoryIndex\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).uint64(message.categoryIndex);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.value);\n          return writer;\n        };\n        BoxPlotOutlier.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotOutlier.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotOutlier();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.categoryIndex = reader.uint64();\n                break;\n              }\n              case 2: {\n                message.value = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotOutlier.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotOutlier.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.categoryIndex != null && message.hasOwnProperty(\"categoryIndex\")) {\n            if (!$util.isInteger(message.categoryIndex) && !(message.categoryIndex && $util.isInteger(message.categoryIndex.low) && $util.isInteger(message.categoryIndex.high)))\n              return \"categoryIndex: integer|Long expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          return null;\n        };\n        BoxPlotOutlier.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotOutlier)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotOutlier();\n          if (object.categoryIndex != null) {\n            if ($util.Long)\n              (message.categoryIndex = $util.Long.fromValue(object.categoryIndex)).unsigned = true;\n            else if (typeof object.categoryIndex === \"string\")\n              message.categoryIndex = parseInt(object.categoryIndex, 10);\n            else if (typeof object.categoryIndex === \"number\")\n              message.categoryIndex = object.categoryIndex;\n            else if (typeof object.categoryIndex === \"object\")\n              message.categoryIndex = new $util.LongBits(object.categoryIndex.low >>> 0, object.categoryIndex.high >>> 0).toNumber(true);\n          }\n          if (object.value != null)\n            message.value = Number(object.value);\n          return message;\n        };\n        BoxPlotOutlier.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.categoryIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.categoryIndex = options.longs === String ? \"0\" : 0;\n            object.value = 0;\n          }\n          if (message.categoryIndex != null && message.hasOwnProperty(\"categoryIndex\"))\n            if (typeof message.categoryIndex === \"number\")\n              object.categoryIndex = options.longs === String ? String(message.categoryIndex) : message.categoryIndex;\n            else\n              object.categoryIndex = options.longs === String ? $util.Long.prototype.toString.call(message.categoryIndex) : options.longs === Number ? new $util.LongBits(message.categoryIndex.low >>> 0, message.categoryIndex.high >>> 0).toNumber(true) : message.categoryIndex;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          return object;\n        };\n        BoxPlotOutlier.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotOutlier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotOutlier\";\n        };\n        return BoxPlotOutlier;\n      }();\n      epoch_proto.BoxPlotDataPointDef = function() {\n        function BoxPlotDataPointDef(properties) {\n          this.outliers = [];\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDataPointDef.prototype.outliers = $util.emptyArray;\n        BoxPlotDataPointDef.prototype.points = $util.emptyArray;\n        BoxPlotDataPointDef.create = function create(properties) {\n          return new BoxPlotDataPointDef(properties);\n        };\n        BoxPlotDataPointDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.outliers != null && message.outliers.length)\n            for (var i = 0; i < message.outliers.length; ++i)\n              $root.epoch_proto.BoxPlotOutlier.encode(message.outliers[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.BoxPlotDataPoint.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        BoxPlotDataPointDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDataPointDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDataPointDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.outliers && message.outliers.length))\n                  message.outliers = [];\n                message.outliers.push($root.epoch_proto.BoxPlotOutlier.decode(reader, reader.uint32()));\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.BoxPlotDataPoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPointDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDataPointDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.outliers != null && message.hasOwnProperty(\"outliers\")) {\n            if (!Array.isArray(message.outliers))\n              return \"outliers: array expected\";\n            for (var i = 0; i < message.outliers.length; ++i) {\n              var error = $root.epoch_proto.BoxPlotOutlier.verify(message.outliers[i]);\n              if (error)\n                return \"outliers.\" + error;\n            }\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.BoxPlotDataPoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        BoxPlotDataPointDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDataPointDef)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDataPointDef();\n          if (object.outliers) {\n            if (!Array.isArray(object.outliers))\n              throw TypeError(\".epoch_proto.BoxPlotDataPointDef.outliers: array expected\");\n            message.outliers = [];\n            for (var i = 0; i < object.outliers.length; ++i) {\n              if (typeof object.outliers[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BoxPlotDataPointDef.outliers: object expected\");\n              message.outliers[i] = $root.epoch_proto.BoxPlotOutlier.fromObject(object.outliers[i]);\n            }\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.BoxPlotDataPointDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BoxPlotDataPointDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.BoxPlotDataPoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPointDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.outliers = [];\n            object.points = [];\n          }\n          if (message.outliers && message.outliers.length) {\n            object.outliers = [];\n            for (var j = 0; j < message.outliers.length; ++j)\n              object.outliers[j] = $root.epoch_proto.BoxPlotOutlier.toObject(message.outliers[j], options);\n          }\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.BoxPlotDataPoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        BoxPlotDataPointDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDataPointDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDataPointDef\";\n        };\n        return BoxPlotDataPointDef;\n      }();\n      epoch_proto.BoxPlotDef = function() {\n        function BoxPlotDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDef.prototype.chartDef = null;\n        BoxPlotDef.prototype.data = null;\n        BoxPlotDef.create = function create(properties) {\n          return new BoxPlotDef(properties);\n        };\n        BoxPlotDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.BoxPlotDataPointDef.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          return writer;\n        };\n        BoxPlotDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.BoxPlotDataPointDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.BoxPlotDataPointDef.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          return null;\n        };\n        BoxPlotDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDef)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.BoxPlotDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.BoxPlotDef.data: object expected\");\n            message.data = $root.epoch_proto.BoxPlotDataPointDef.fromObject(object.data);\n          }\n          return message;\n        };\n        BoxPlotDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.BoxPlotDataPointDef.toObject(message.data, options);\n          return object;\n        };\n        BoxPlotDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDef\";\n        };\n        return BoxPlotDef;\n      }();\n      epoch_proto.XRangePoint = function() {\n        function XRangePoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        XRangePoint.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        XRangePoint.prototype.x2 = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        XRangePoint.prototype.y = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        XRangePoint.prototype.isLong = false;\n        XRangePoint.create = function create(properties) {\n          return new XRangePoint(properties);\n        };\n        XRangePoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int64(message.x);\n          if (message.x2 != null && Object.hasOwnProperty.call(message, \"x2\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.x2);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).uint64(message.y);\n          if (message.isLong != null && Object.hasOwnProperty.call(message, \"isLong\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).bool(message.isLong);\n          return writer;\n        };\n        XRangePoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        XRangePoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.XRangePoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.int64();\n                break;\n              }\n              case 2: {\n                message.x2 = reader.int64();\n                break;\n              }\n              case 3: {\n                message.y = reader.uint64();\n                break;\n              }\n              case 4: {\n                message.isLong = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        XRangePoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        XRangePoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.x2 != null && message.hasOwnProperty(\"x2\")) {\n            if (!$util.isInteger(message.x2) && !(message.x2 && $util.isInteger(message.x2.low) && $util.isInteger(message.x2.high)))\n              return \"x2: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (!$util.isInteger(message.y) && !(message.y && $util.isInteger(message.y.low) && $util.isInteger(message.y.high)))\n              return \"y: integer|Long expected\";\n          }\n          if (message.isLong != null && message.hasOwnProperty(\"isLong\")) {\n            if (typeof message.isLong !== \"boolean\")\n              return \"isLong: boolean expected\";\n          }\n          return null;\n        };\n        XRangePoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.XRangePoint)\n            return object;\n          var message = new $root.epoch_proto.XRangePoint();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = false;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber();\n          }\n          if (object.x2 != null) {\n            if ($util.Long)\n              (message.x2 = $util.Long.fromValue(object.x2)).unsigned = false;\n            else if (typeof object.x2 === \"string\")\n              message.x2 = parseInt(object.x2, 10);\n            else if (typeof object.x2 === \"number\")\n              message.x2 = object.x2;\n            else if (typeof object.x2 === \"object\")\n              message.x2 = new $util.LongBits(object.x2.low >>> 0, object.x2.high >>> 0).toNumber();\n          }\n          if (object.y != null) {\n            if ($util.Long)\n              (message.y = $util.Long.fromValue(object.y)).unsigned = true;\n            else if (typeof object.y === \"string\")\n              message.y = parseInt(object.y, 10);\n            else if (typeof object.y === \"number\")\n              message.y = object.y;\n            else if (typeof object.y === \"object\")\n              message.y = new $util.LongBits(object.y.low >>> 0, object.y.high >>> 0).toNumber(true);\n          }\n          if (object.isLong != null)\n            message.isLong = Boolean(object.isLong);\n          return message;\n        };\n        XRangePoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x2 = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.y = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.y = options.longs === String ? \"0\" : 0;\n            object.isLong = false;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber() : message.x;\n          if (message.x2 != null && message.hasOwnProperty(\"x2\"))\n            if (typeof message.x2 === \"number\")\n              object.x2 = options.longs === String ? String(message.x2) : message.x2;\n            else\n              object.x2 = options.longs === String ? $util.Long.prototype.toString.call(message.x2) : options.longs === Number ? new $util.LongBits(message.x2.low >>> 0, message.x2.high >>> 0).toNumber() : message.x2;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            if (typeof message.y === \"number\")\n              object.y = options.longs === String ? String(message.y) : message.y;\n            else\n              object.y = options.longs === String ? $util.Long.prototype.toString.call(message.y) : options.longs === Number ? new $util.LongBits(message.y.low >>> 0, message.y.high >>> 0).toNumber(true) : message.y;\n          if (message.isLong != null && message.hasOwnProperty(\"isLong\"))\n            object.isLong = message.isLong;\n          return object;\n        };\n        XRangePoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        XRangePoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.XRangePoint\";\n        };\n        return XRangePoint;\n      }();\n      epoch_proto.XRangeDef = function() {\n        function XRangeDef(properties) {\n          this.categories = [];\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        XRangeDef.prototype.chartDef = null;\n        XRangeDef.prototype.categories = $util.emptyArray;\n        XRangeDef.prototype.points = $util.emptyArray;\n        XRangeDef.create = function create(properties) {\n          return new XRangeDef(properties);\n        };\n        XRangeDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.categories != null && message.categories.length)\n            for (var i = 0; i < message.categories.length; ++i)\n              writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).string(message.categories[i]);\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.XRangePoint.encode(message.points[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          return writer;\n        };\n        XRangeDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        XRangeDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.XRangeDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.categories && message.categories.length))\n                  message.categories = [];\n                message.categories.push(reader.string());\n                break;\n              }\n              case 3: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.XRangePoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        XRangeDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        XRangeDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.categories != null && message.hasOwnProperty(\"categories\")) {\n            if (!Array.isArray(message.categories))\n              return \"categories: array expected\";\n            for (var i = 0; i < message.categories.length; ++i)\n              if (!$util.isString(message.categories[i]))\n                return \"categories: string[] expected\";\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.XRangePoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        XRangeDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.XRangeDef)\n            return object;\n          var message = new $root.epoch_proto.XRangeDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.XRangeDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.categories) {\n            if (!Array.isArray(object.categories))\n              throw TypeError(\".epoch_proto.XRangeDef.categories: array expected\");\n            message.categories = [];\n            for (var i = 0; i < object.categories.length; ++i)\n              message.categories[i] = String(object.categories[i]);\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.XRangeDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.XRangeDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.XRangePoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        XRangeDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.categories = [];\n            object.points = [];\n          }\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.categories && message.categories.length) {\n            object.categories = [];\n            for (var j = 0; j < message.categories.length; ++j)\n              object.categories[j] = message.categories[j];\n          }\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.XRangePoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        XRangeDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        XRangeDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.XRangeDef\";\n        };\n        return XRangeDef;\n      }();\n      epoch_proto.PieData = function() {\n        function PieData(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieData.prototype.name = \"\";\n        PieData.prototype.y = 0;\n        PieData.create = function create(properties) {\n          return new PieData(properties);\n        };\n        PieData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.name);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.y);\n          return writer;\n        };\n        PieData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.name = reader.string();\n                break;\n              }\n              case 2: {\n                message.y = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (typeof message.y !== \"number\")\n              return \"y: number expected\";\n          }\n          return null;\n        };\n        PieData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieData)\n            return object;\n          var message = new $root.epoch_proto.PieData();\n          if (object.name != null)\n            message.name = String(object.name);\n          if (object.y != null)\n            message.y = Number(object.y);\n          return message;\n        };\n        PieData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.name = \"\";\n            object.y = 0;\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;\n          return object;\n        };\n        PieData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieData\";\n        };\n        return PieData;\n      }();\n      epoch_proto.PieDataDef = function() {\n        function PieDataDef(properties) {\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieDataDef.prototype.name = \"\";\n        PieDataDef.prototype.points = $util.emptyArray;\n        PieDataDef.prototype.size = \"\";\n        PieDataDef.prototype.innerSize = null;\n        var $oneOfFields;\n        Object.defineProperty(PieDataDef.prototype, \"_innerSize\", {\n          get: $util.oneOfGetter($oneOfFields = [\"innerSize\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        PieDataDef.create = function create(properties) {\n          return new PieDataDef(properties);\n        };\n        PieDataDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.name);\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.PieData.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n            writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).string(message.size);\n          if (message.innerSize != null && Object.hasOwnProperty.call(message, \"innerSize\"))\n            writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).string(message.innerSize);\n          return writer;\n        };\n        PieDataDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieDataDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieDataDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.name = reader.string();\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.PieData.decode(reader, reader.uint32()));\n                break;\n              }\n              case 3: {\n                message.size = reader.string();\n                break;\n              }\n              case 4: {\n                message.innerSize = reader.string();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieDataDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieDataDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.PieData.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          if (message.size != null && message.hasOwnProperty(\"size\")) {\n            if (!$util.isString(message.size))\n              return \"size: string expected\";\n          }\n          if (message.innerSize != null && message.hasOwnProperty(\"innerSize\")) {\n            properties._innerSize = 1;\n            if (!$util.isString(message.innerSize))\n              return \"innerSize: string expected\";\n          }\n          return null;\n        };\n        PieDataDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieDataDef)\n            return object;\n          var message = new $root.epoch_proto.PieDataDef();\n          if (object.name != null)\n            message.name = String(object.name);\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.PieDataDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.PieDataDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.PieData.fromObject(object.points[i]);\n            }\n          }\n          if (object.size != null)\n            message.size = String(object.size);\n          if (object.innerSize != null)\n            message.innerSize = String(object.innerSize);\n          return message;\n        };\n        PieDataDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.points = [];\n          if (options.defaults) {\n            object.name = \"\";\n            object.size = \"\";\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.PieData.toObject(message.points[j], options);\n          }\n          if (message.size != null && message.hasOwnProperty(\"size\"))\n            object.size = message.size;\n          if (message.innerSize != null && message.hasOwnProperty(\"innerSize\")) {\n            object.innerSize = message.innerSize;\n            if (options.oneofs)\n              object._innerSize = \"innerSize\";\n          }\n          return object;\n        };\n        PieDataDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieDataDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieDataDef\";\n        };\n        return PieDataDef;\n      }();\n      epoch_proto.PieDef = function() {\n        function PieDef(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieDef.prototype.chartDef = null;\n        PieDef.prototype.data = $util.emptyArray;\n        PieDef.create = function create(properties) {\n          return new PieDef(properties);\n        };\n        PieDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.PieDataDef.encode(message.data[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        PieDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.PieDataDef.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.PieDataDef.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          return null;\n        };\n        PieDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieDef)\n            return object;\n          var message = new $root.epoch_proto.PieDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.PieDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.PieDef.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.PieDef.data: object expected\");\n              message.data[i] = $root.epoch_proto.PieDataDef.fromObject(object.data[i]);\n            }\n          }\n          return message;\n        };\n        PieDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.PieDataDef.toObject(message.data[j], options);\n          }\n          return object;\n        };\n        PieDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieDef\";\n        };\n        return PieDef;\n      }();\n      epoch_proto.Chart = function() {\n        function Chart(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Chart.prototype.linesDef = null;\n        Chart.prototype.heatMapDef = null;\n        Chart.prototype.barDef = null;\n        Chart.prototype.histogramDef = null;\n        Chart.prototype.boxPlotDef = null;\n        Chart.prototype.xRangeDef = null;\n        Chart.prototype.pieDef = null;\n        var $oneOfFields;\n        Object.defineProperty(Chart.prototype, \"chartType\", {\n          get: $util.oneOfGetter($oneOfFields = [\"linesDef\", \"heatMapDef\", \"barDef\", \"histogramDef\", \"boxPlotDef\", \"xRangeDef\", \"pieDef\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Chart.create = function create(properties) {\n          return new Chart(properties);\n        };\n        Chart.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.linesDef != null && Object.hasOwnProperty.call(message, \"linesDef\"))\n            $root.epoch_proto.LinesDef.encode(message.linesDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.heatMapDef != null && Object.hasOwnProperty.call(message, \"heatMapDef\"))\n            $root.epoch_proto.HeatMapDef.encode(message.heatMapDef, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.barDef != null && Object.hasOwnProperty.call(message, \"barDef\"))\n            $root.epoch_proto.BarDef.encode(message.barDef, writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).fork()).ldelim();\n          if (message.histogramDef != null && Object.hasOwnProperty.call(message, \"histogramDef\"))\n            $root.epoch_proto.HistogramDef.encode(message.histogramDef, writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).fork()).ldelim();\n          if (message.boxPlotDef != null && Object.hasOwnProperty.call(message, \"boxPlotDef\"))\n            $root.epoch_proto.BoxPlotDef.encode(message.boxPlotDef, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          if (message.xRangeDef != null && Object.hasOwnProperty.call(message, \"xRangeDef\"))\n            $root.epoch_proto.XRangeDef.encode(message.xRangeDef, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          if (message.pieDef != null && Object.hasOwnProperty.call(message, \"pieDef\"))\n            $root.epoch_proto.PieDef.encode(message.pieDef, writer.uint32(\n              /* id 7, wireType 2 =*/\n              58\n            ).fork()).ldelim();\n          return writer;\n        };\n        Chart.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Chart.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Chart();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.linesDef = $root.epoch_proto.LinesDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.heatMapDef = $root.epoch_proto.HeatMapDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                message.barDef = $root.epoch_proto.BarDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 4: {\n                message.histogramDef = $root.epoch_proto.HistogramDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 5: {\n                message.boxPlotDef = $root.epoch_proto.BoxPlotDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 6: {\n                message.xRangeDef = $root.epoch_proto.XRangeDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 7: {\n                message.pieDef = $root.epoch_proto.PieDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Chart.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Chart.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.linesDef != null && message.hasOwnProperty(\"linesDef\")) {\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.LinesDef.verify(message.linesDef);\n              if (error)\n                return \"linesDef.\" + error;\n            }\n          }\n          if (message.heatMapDef != null && message.hasOwnProperty(\"heatMapDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.HeatMapDef.verify(message.heatMapDef);\n              if (error)\n                return \"heatMapDef.\" + error;\n            }\n          }\n          if (message.barDef != null && message.hasOwnProperty(\"barDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.BarDef.verify(message.barDef);\n              if (error)\n                return \"barDef.\" + error;\n            }\n          }\n          if (message.histogramDef != null && message.hasOwnProperty(\"histogramDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.HistogramDef.verify(message.histogramDef);\n              if (error)\n                return \"histogramDef.\" + error;\n            }\n          }\n          if (message.boxPlotDef != null && message.hasOwnProperty(\"boxPlotDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.BoxPlotDef.verify(message.boxPlotDef);\n              if (error)\n                return \"boxPlotDef.\" + error;\n            }\n          }\n          if (message.xRangeDef != null && message.hasOwnProperty(\"xRangeDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.XRangeDef.verify(message.xRangeDef);\n              if (error)\n                return \"xRangeDef.\" + error;\n            }\n          }\n          if (message.pieDef != null && message.hasOwnProperty(\"pieDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.PieDef.verify(message.pieDef);\n              if (error)\n                return \"pieDef.\" + error;\n            }\n          }\n          return null;\n        };\n        Chart.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Chart)\n            return object;\n          var message = new $root.epoch_proto.Chart();\n          if (object.linesDef != null) {\n            if (typeof object.linesDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.linesDef: object expected\");\n            message.linesDef = $root.epoch_proto.LinesDef.fromObject(object.linesDef);\n          }\n          if (object.heatMapDef != null) {\n            if (typeof object.heatMapDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.heatMapDef: object expected\");\n            message.heatMapDef = $root.epoch_proto.HeatMapDef.fromObject(object.heatMapDef);\n          }\n          if (object.barDef != null) {\n            if (typeof object.barDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.barDef: object expected\");\n            message.barDef = $root.epoch_proto.BarDef.fromObject(object.barDef);\n          }\n          if (object.histogramDef != null) {\n            if (typeof object.histogramDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.histogramDef: object expected\");\n            message.histogramDef = $root.epoch_proto.HistogramDef.fromObject(object.histogramDef);\n          }\n          if (object.boxPlotDef != null) {\n            if (typeof object.boxPlotDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.boxPlotDef: object expected\");\n            message.boxPlotDef = $root.epoch_proto.BoxPlotDef.fromObject(object.boxPlotDef);\n          }\n          if (object.xRangeDef != null) {\n            if (typeof object.xRangeDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.xRangeDef: object expected\");\n            message.xRangeDef = $root.epoch_proto.XRangeDef.fromObject(object.xRangeDef);\n          }\n          if (object.pieDef != null) {\n            if (typeof object.pieDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.pieDef: object expected\");\n            message.pieDef = $root.epoch_proto.PieDef.fromObject(object.pieDef);\n          }\n          return message;\n        };\n        Chart.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.linesDef != null && message.hasOwnProperty(\"linesDef\")) {\n            object.linesDef = $root.epoch_proto.LinesDef.toObject(message.linesDef, options);\n            if (options.oneofs)\n              object.chartType = \"linesDef\";\n          }\n          if (message.heatMapDef != null && message.hasOwnProperty(\"heatMapDef\")) {\n            object.heatMapDef = $root.epoch_proto.HeatMapDef.toObject(message.heatMapDef, options);\n            if (options.oneofs)\n              object.chartType = \"heatMapDef\";\n          }\n          if (message.barDef != null && message.hasOwnProperty(\"barDef\")) {\n            object.barDef = $root.epoch_proto.BarDef.toObject(message.barDef, options);\n            if (options.oneofs)\n              object.chartType = \"barDef\";\n          }\n          if (message.histogramDef != null && message.hasOwnProperty(\"histogramDef\")) {\n            object.histogramDef = $root.epoch_proto.HistogramDef.toObject(message.histogramDef, options);\n            if (options.oneofs)\n              object.chartType = \"histogramDef\";\n          }\n          if (message.boxPlotDef != null && message.hasOwnProperty(\"boxPlotDef\")) {\n            object.boxPlotDef = $root.epoch_proto.BoxPlotDef.toObject(message.boxPlotDef, options);\n            if (options.oneofs)\n              object.chartType = \"boxPlotDef\";\n          }\n          if (message.xRangeDef != null && message.hasOwnProperty(\"xRangeDef\")) {\n            object.xRangeDef = $root.epoch_proto.XRangeDef.toObject(message.xRangeDef, options);\n            if (options.oneofs)\n              object.chartType = \"xRangeDef\";\n          }\n          if (message.pieDef != null && message.hasOwnProperty(\"pieDef\")) {\n            object.pieDef = $root.epoch_proto.PieDef.toObject(message.pieDef, options);\n            if (options.oneofs)\n              object.chartType = \"pieDef\";\n          }\n          return object;\n        };\n        Chart.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Chart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Chart\";\n        };\n        return Chart;\n      }();\n      epoch_proto.EpochFolioDashboardWidget = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"WidgetUnspecified\"] = 0;\n        values[valuesById[1] = \"WidgetCard\"] = 1;\n        values[valuesById[2] = \"WidgetLines\"] = 2;\n        values[valuesById[3] = \"WidgetBar\"] = 3;\n        values[valuesById[4] = \"WidgetDataTable\"] = 4;\n        values[valuesById[5] = \"WidgetXRange\"] = 5;\n        values[valuesById[6] = \"WidgetHistogram\"] = 6;\n        values[valuesById[7] = \"WidgetPie\"] = 7;\n        values[valuesById[8] = \"WidgetHeatMap\"] = 8;\n        values[valuesById[9] = \"WidgetBoxPlot\"] = 9;\n        values[valuesById[10] = \"WidgetArea\"] = 10;\n        values[valuesById[11] = \"WidgetColumn\"] = 11;\n        return values;\n      }();\n      epoch_proto.EpochFolioType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"TypeUnspecified\"] = 0;\n        values[valuesById[1] = \"TypeString\"] = 1;\n        values[valuesById[2] = \"TypeInteger\"] = 2;\n        values[valuesById[3] = \"TypeDecimal\"] = 3;\n        values[valuesById[4] = \"TypePercent\"] = 4;\n        values[valuesById[5] = \"TypeBoolean\"] = 5;\n        values[valuesById[6] = \"TypeDateTime\"] = 6;\n        values[valuesById[7] = \"TypeDate\"] = 7;\n        values[valuesById[8] = \"TypeDayDuration\"] = 8;\n        values[valuesById[9] = \"TypeMonetary\"] = 9;\n        values[valuesById[10] = \"TypeDuration\"] = 10;\n        return values;\n      }();\n      epoch_proto.Scalar = function() {\n        function Scalar(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Scalar.prototype.stringValue = null;\n        Scalar.prototype.integerValue = null;\n        Scalar.prototype.decimalValue = null;\n        Scalar.prototype.percentValue = null;\n        Scalar.prototype.booleanValue = null;\n        Scalar.prototype.timestampMs = null;\n        Scalar.prototype.dateValue = null;\n        Scalar.prototype.dayDuration = null;\n        Scalar.prototype.monetaryValue = null;\n        Scalar.prototype.durationMs = null;\n        Scalar.prototype.nullValue = null;\n        var $oneOfFields;\n        Object.defineProperty(Scalar.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"integerValue\", \"decimalValue\", \"percentValue\", \"booleanValue\", \"timestampMs\", \"dateValue\", \"dayDuration\", \"monetaryValue\", \"durationMs\", \"nullValue\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Scalar.create = function create(properties) {\n          return new Scalar(properties);\n        };\n        Scalar.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.stringValue);\n          if (message.integerValue != null && Object.hasOwnProperty.call(message, \"integerValue\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.integerValue);\n          if (message.decimalValue != null && Object.hasOwnProperty.call(message, \"decimalValue\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.decimalValue);\n          if (message.percentValue != null && Object.hasOwnProperty.call(message, \"percentValue\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.percentValue);\n          if (message.booleanValue != null && Object.hasOwnProperty.call(message, \"booleanValue\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.booleanValue);\n          if (message.timestampMs != null && Object.hasOwnProperty.call(message, \"timestampMs\"))\n            writer.uint32(\n              /* id 6, wireType 0 =*/\n              48\n            ).int64(message.timestampMs);\n          if (message.dateValue != null && Object.hasOwnProperty.call(message, \"dateValue\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).int64(message.dateValue);\n          if (message.dayDuration != null && Object.hasOwnProperty.call(message, \"dayDuration\"))\n            writer.uint32(\n              /* id 8, wireType 0 =*/\n              64\n            ).int32(message.dayDuration);\n          if (message.monetaryValue != null && Object.hasOwnProperty.call(message, \"monetaryValue\"))\n            writer.uint32(\n              /* id 9, wireType 1 =*/\n              73\n            ).double(message.monetaryValue);\n          if (message.durationMs != null && Object.hasOwnProperty.call(message, \"durationMs\"))\n            writer.uint32(\n              /* id 10, wireType 0 =*/\n              80\n            ).int64(message.durationMs);\n          if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n            writer.uint32(\n              /* id 11, wireType 0 =*/\n              88\n            ).int32(message.nullValue);\n          return writer;\n        };\n        Scalar.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Scalar.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Scalar();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.stringValue = reader.string();\n                break;\n              }\n              case 2: {\n                message.integerValue = reader.int64();\n                break;\n              }\n              case 3: {\n                message.decimalValue = reader.double();\n                break;\n              }\n              case 4: {\n                message.percentValue = reader.double();\n                break;\n              }\n              case 5: {\n                message.booleanValue = reader.bool();\n                break;\n              }\n              case 6: {\n                message.timestampMs = reader.int64();\n                break;\n              }\n              case 7: {\n                message.dateValue = reader.int64();\n                break;\n              }\n              case 8: {\n                message.dayDuration = reader.int32();\n                break;\n              }\n              case 9: {\n                message.monetaryValue = reader.double();\n                break;\n              }\n              case 10: {\n                message.durationMs = reader.int64();\n                break;\n              }\n              case 11: {\n                message.nullValue = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Scalar.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Scalar.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties.value = 1;\n            if (!$util.isString(message.stringValue))\n              return \"stringValue: string expected\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high)))\n              return \"integerValue: integer|Long expected\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.decimalValue !== \"number\")\n              return \"decimalValue: number expected\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.percentValue !== \"number\")\n              return \"percentValue: number expected\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.booleanValue !== \"boolean\")\n              return \"booleanValue: boolean expected\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))\n              return \"timestampMs: integer|Long expected\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dateValue) && !(message.dateValue && $util.isInteger(message.dateValue.low) && $util.isInteger(message.dateValue.high)))\n              return \"dateValue: integer|Long expected\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dayDuration))\n              return \"dayDuration: integer expected\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.monetaryValue !== \"number\")\n              return \"monetaryValue: number expected\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))\n              return \"durationMs: integer|Long expected\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            switch (message.nullValue) {\n              default:\n                return \"nullValue: enum value expected\";\n              case 0:\n                break;\n            }\n          }\n          return null;\n        };\n        Scalar.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Scalar)\n            return object;\n          var message = new $root.epoch_proto.Scalar();\n          if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n          if (object.integerValue != null) {\n            if ($util.Long)\n              (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;\n            else if (typeof object.integerValue === \"string\")\n              message.integerValue = parseInt(object.integerValue, 10);\n            else if (typeof object.integerValue === \"number\")\n              message.integerValue = object.integerValue;\n            else if (typeof object.integerValue === \"object\")\n              message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();\n          }\n          if (object.decimalValue != null)\n            message.decimalValue = Number(object.decimalValue);\n          if (object.percentValue != null)\n            message.percentValue = Number(object.percentValue);\n          if (object.booleanValue != null)\n            message.booleanValue = Boolean(object.booleanValue);\n          if (object.timestampMs != null) {\n            if ($util.Long)\n              (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;\n            else if (typeof object.timestampMs === \"string\")\n              message.timestampMs = parseInt(object.timestampMs, 10);\n            else if (typeof object.timestampMs === \"number\")\n              message.timestampMs = object.timestampMs;\n            else if (typeof object.timestampMs === \"object\")\n              message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();\n          }\n          if (object.dateValue != null) {\n            if ($util.Long)\n              (message.dateValue = $util.Long.fromValue(object.dateValue)).unsigned = false;\n            else if (typeof object.dateValue === \"string\")\n              message.dateValue = parseInt(object.dateValue, 10);\n            else if (typeof object.dateValue === \"number\")\n              message.dateValue = object.dateValue;\n            else if (typeof object.dateValue === \"object\")\n              message.dateValue = new $util.LongBits(object.dateValue.low >>> 0, object.dateValue.high >>> 0).toNumber();\n          }\n          if (object.dayDuration != null)\n            message.dayDuration = object.dayDuration | 0;\n          if (object.monetaryValue != null)\n            message.monetaryValue = Number(object.monetaryValue);\n          if (object.durationMs != null) {\n            if ($util.Long)\n              (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = false;\n            else if (typeof object.durationMs === \"string\")\n              message.durationMs = parseInt(object.durationMs, 10);\n            else if (typeof object.durationMs === \"number\")\n              message.durationMs = object.durationMs;\n            else if (typeof object.durationMs === \"object\")\n              message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber();\n          }\n          switch (object.nullValue) {\n            default:\n              if (typeof object.nullValue === \"number\") {\n                message.nullValue = object.nullValue;\n                break;\n              }\n              break;\n            case \"NULL_VALUE\":\n            case 0:\n              message.nullValue = 0;\n              break;\n          }\n          return message;\n        };\n        Scalar.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n              object.value = \"stringValue\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (typeof message.integerValue === \"number\")\n              object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;\n            else\n              object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;\n            if (options.oneofs)\n              object.value = \"integerValue\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            object.decimalValue = options.json && !isFinite(message.decimalValue) ? String(message.decimalValue) : message.decimalValue;\n            if (options.oneofs)\n              object.value = \"decimalValue\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            object.percentValue = options.json && !isFinite(message.percentValue) ? String(message.percentValue) : message.percentValue;\n            if (options.oneofs)\n              object.value = \"percentValue\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            object.booleanValue = message.booleanValue;\n            if (options.oneofs)\n              object.value = \"booleanValue\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (typeof message.timestampMs === \"number\")\n              object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;\n            else\n              object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;\n            if (options.oneofs)\n              object.value = \"timestampMs\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (typeof message.dateValue === \"number\")\n              object.dateValue = options.longs === String ? String(message.dateValue) : message.dateValue;\n            else\n              object.dateValue = options.longs === String ? $util.Long.prototype.toString.call(message.dateValue) : options.longs === Number ? new $util.LongBits(message.dateValue.low >>> 0, message.dateValue.high >>> 0).toNumber() : message.dateValue;\n            if (options.oneofs)\n              object.value = \"dateValue\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            object.dayDuration = message.dayDuration;\n            if (options.oneofs)\n              object.value = \"dayDuration\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            object.monetaryValue = options.json && !isFinite(message.monetaryValue) ? String(message.monetaryValue) : message.monetaryValue;\n            if (options.oneofs)\n              object.value = \"monetaryValue\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (typeof message.durationMs === \"number\")\n              object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;\n            else\n              object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber() : message.durationMs;\n            if (options.oneofs)\n              object.value = \"durationMs\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n            if (options.oneofs)\n              object.value = \"nullValue\";\n          }\n          return object;\n        };\n        Scalar.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Scalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Scalar\";\n        };\n        return Scalar;\n      }();\n      epoch_proto.Array = function() {\n        function Array2(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Array2.prototype.values = $util.emptyArray;\n        Array2.create = function create(properties) {\n          return new Array2(properties);\n        };\n        Array2.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        Array2.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Array2.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Array();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Array2.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Array2.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array2.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        Array2.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Array)\n            return object;\n          var message = new $root.epoch_proto.Array();\n          if (object.values) {\n            if (!Array2.isArray(object.values))\n              throw TypeError(\".epoch_proto.Array.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Array.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        Array2.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        Array2.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Array2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Array\";\n        };\n        return Array2;\n      }();\n      epoch_proto.AxisType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"AxisUnspecified\"] = 0;\n        values[valuesById[1] = \"AxisLinear\"] = 1;\n        values[valuesById[2] = \"AxisLogarithmic\"] = 2;\n        values[valuesById[3] = \"AxisDateTime\"] = 3;\n        values[valuesById[4] = \"AxisCategory\"] = 4;\n        return values;\n      }();\n      epoch_proto.DashStyle = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"DashStyleUnspecified\"] = 0;\n        values[valuesById[1] = \"Solid\"] = 1;\n        values[valuesById[2] = \"ShortDash\"] = 2;\n        values[valuesById[3] = \"ShortDot\"] = 3;\n        values[valuesById[4] = \"ShortDashDot\"] = 4;\n        values[valuesById[5] = \"ShortDashDotDot\"] = 5;\n        values[valuesById[6] = \"Dot\"] = 6;\n        values[valuesById[7] = \"Dash\"] = 7;\n        values[valuesById[8] = \"LongDash\"] = 8;\n        values[valuesById[9] = \"DashDot\"] = 9;\n        values[valuesById[10] = \"LongDashDot\"] = 10;\n        values[valuesById[11] = \"LongDashDotDot\"] = 11;\n        return values;\n      }();\n      return epoch_proto;\n    }();\n    $root.google = function() {\n      var google = {};\n      google.protobuf = function() {\n        var protobuf = {};\n        protobuf.Struct = function() {\n          function Struct(properties) {\n            this.fields = {};\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Struct.prototype.fields = $util.emptyObject;\n          Struct.create = function create(properties) {\n            return new Struct(properties);\n          };\n          Struct.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.fields != null && Object.hasOwnProperty.call(message, \"fields\"))\n              for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {\n                writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork().uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).string(keys[i]);\n                $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(\n                  /* id 2, wireType 2 =*/\n                  18\n                ).fork()).ldelim().ldelim();\n              }\n            return writer;\n          };\n          Struct.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Struct.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (message.fields === $util.emptyObject)\n                    message.fields = {};\n                  var end2 = reader.uint32() + reader.pos;\n                  key = \"\";\n                  value = null;\n                  while (reader.pos < end2) {\n                    var tag2 = reader.uint32();\n                    switch (tag2 >>> 3) {\n                      case 1:\n                        key = reader.string();\n                        break;\n                      case 2:\n                        value = $root.google.protobuf.Value.decode(reader, reader.uint32());\n                        break;\n                      default:\n                        reader.skipType(tag2 & 7);\n                        break;\n                    }\n                  }\n                  message.fields[key] = value;\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Struct.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Struct.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.fields != null && message.hasOwnProperty(\"fields\")) {\n              if (!$util.isObject(message.fields))\n                return \"fields: object expected\";\n              var key = Object.keys(message.fields);\n              for (var i = 0; i < key.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);\n                if (error)\n                  return \"fields.\" + error;\n              }\n            }\n            return null;\n          };\n          Struct.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Struct)\n              return object;\n            var message = new $root.google.protobuf.Struct();\n            if (object.fields) {\n              if (typeof object.fields !== \"object\")\n                throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n              message.fields = {};\n              for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {\n                if (typeof object.fields[keys[i]] !== \"object\")\n                  throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n                message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);\n              }\n            }\n            return message;\n          };\n          Struct.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n              object.fields = {};\n            var keys2;\n            if (message.fields && (keys2 = Object.keys(message.fields)).length) {\n              object.fields = {};\n              for (var j = 0; j < keys2.length; ++j)\n                object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);\n            }\n            return object;\n          };\n          Struct.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Struct\";\n          };\n          return Struct;\n        }();\n        protobuf.Value = function() {\n          function Value(properties) {\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Value.prototype.nullValue = null;\n          Value.prototype.numberValue = null;\n          Value.prototype.stringValue = null;\n          Value.prototype.boolValue = null;\n          Value.prototype.structValue = null;\n          Value.prototype.listValue = null;\n          var $oneOfFields;\n          Object.defineProperty(Value.prototype, \"kind\", {\n            get: $util.oneOfGetter($oneOfFields = [\"nullValue\", \"numberValue\", \"stringValue\", \"boolValue\", \"structValue\", \"listValue\"]),\n            set: $util.oneOfSetter($oneOfFields)\n          });\n          Value.create = function create(properties) {\n            return new Value(properties);\n          };\n          Value.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n              writer.uint32(\n                /* id 1, wireType 0 =*/\n                8\n              ).int32(message.nullValue);\n            if (message.numberValue != null && Object.hasOwnProperty.call(message, \"numberValue\"))\n              writer.uint32(\n                /* id 2, wireType 1 =*/\n                17\n              ).double(message.numberValue);\n            if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.stringValue);\n            if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n              writer.uint32(\n                /* id 4, wireType 0 =*/\n                32\n              ).bool(message.boolValue);\n            if (message.structValue != null && Object.hasOwnProperty.call(message, \"structValue\"))\n              $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n            if (message.listValue != null && Object.hasOwnProperty.call(message, \"listValue\"))\n              $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(\n                /* id 6, wireType 2 =*/\n                50\n              ).fork()).ldelim();\n            return writer;\n          };\n          Value.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Value.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  message.nullValue = reader.int32();\n                  break;\n                }\n                case 2: {\n                  message.numberValue = reader.double();\n                  break;\n                }\n                case 3: {\n                  message.stringValue = reader.string();\n                  break;\n                }\n                case 4: {\n                  message.boolValue = reader.bool();\n                  break;\n                }\n                case 5: {\n                  message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());\n                  break;\n                }\n                case 6: {\n                  message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Value.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Value.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            var properties = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              properties.kind = 1;\n              switch (message.nullValue) {\n                default:\n                  return \"nullValue: enum value expected\";\n                case 0:\n                  break;\n              }\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.numberValue !== \"number\")\n                return \"numberValue: number expected\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.boolValue !== \"boolean\")\n                return \"boolValue: boolean expected\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.Struct.verify(message.structValue);\n                if (error)\n                  return \"structValue.\" + error;\n              }\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.ListValue.verify(message.listValue);\n                if (error)\n                  return \"listValue.\" + error;\n              }\n            }\n            return null;\n          };\n          Value.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Value)\n              return object;\n            var message = new $root.google.protobuf.Value();\n            switch (object.nullValue) {\n              default:\n                if (typeof object.nullValue === \"number\") {\n                  message.nullValue = object.nullValue;\n                  break;\n                }\n                break;\n              case \"NULL_VALUE\":\n              case 0:\n                message.nullValue = 0;\n                break;\n            }\n            if (object.numberValue != null)\n              message.numberValue = Number(object.numberValue);\n            if (object.stringValue != null)\n              message.stringValue = String(object.stringValue);\n            if (object.boolValue != null)\n              message.boolValue = Boolean(object.boolValue);\n            if (object.structValue != null) {\n              if (typeof object.structValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.structValue: object expected\");\n              message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);\n            }\n            if (object.listValue != null) {\n              if (typeof object.listValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.listValue: object expected\");\n              message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);\n            }\n            return message;\n          };\n          Value.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n              if (options.oneofs)\n                object.kind = \"nullValue\";\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;\n              if (options.oneofs)\n                object.kind = \"numberValue\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              object.stringValue = message.stringValue;\n              if (options.oneofs)\n                object.kind = \"stringValue\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              object.boolValue = message.boolValue;\n              if (options.oneofs)\n                object.kind = \"boolValue\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);\n              if (options.oneofs)\n                object.kind = \"structValue\";\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);\n              if (options.oneofs)\n                object.kind = \"listValue\";\n            }\n            return object;\n          };\n          Value.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Value\";\n          };\n          return Value;\n        }();\n        protobuf.NullValue = function() {\n          var valuesById = {}, values = Object.create(valuesById);\n          values[valuesById[0] = \"NULL_VALUE\"] = 0;\n          return values;\n        }();\n        protobuf.ListValue = function() {\n          function ListValue(properties) {\n            this.values = [];\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          ListValue.prototype.values = $util.emptyArray;\n          ListValue.create = function create(properties) {\n            return new ListValue(properties);\n          };\n          ListValue.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.values != null && message.values.length)\n              for (var i = 0; i < message.values.length; ++i)\n                $root.google.protobuf.Value.encode(message.values[i], writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork()).ldelim();\n            return writer;\n          };\n          ListValue.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          ListValue.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (!(message.values && message.values.length))\n                    message.values = [];\n                  message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          ListValue.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          ListValue.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.values != null && message.hasOwnProperty(\"values\")) {\n              if (!Array.isArray(message.values))\n                return \"values: array expected\";\n              for (var i = 0; i < message.values.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.values[i]);\n                if (error)\n                  return \"values.\" + error;\n              }\n            }\n            return null;\n          };\n          ListValue.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.ListValue)\n              return object;\n            var message = new $root.google.protobuf.ListValue();\n            if (object.values) {\n              if (!Array.isArray(object.values))\n                throw TypeError(\".google.protobuf.ListValue.values: array expected\");\n              message.values = [];\n              for (var i = 0; i < object.values.length; ++i) {\n                if (typeof object.values[i] !== \"object\")\n                  throw TypeError(\".google.protobuf.ListValue.values: object expected\");\n                message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);\n              }\n            }\n            return message;\n          };\n          ListValue.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n              object.values = [];\n            if (message.values && message.values.length) {\n              object.values = [];\n              for (var j = 0; j < message.values.length; ++j)\n                object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);\n            }\n            return object;\n          };\n          ListValue.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.ListValue\";\n          };\n          return ListValue;\n        }();\n        return protobuf;\n      }();\n      return google;\n    }();\n    module2.exports = $root;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (require_chart_def());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvY2hhcnRfZGVmLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUMxRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBTSxvQkFBb0IscUJBQU0sSUFBSSxxQkFBTSxZQUFZLHFCQUFNLHFCQUFxQixxQkFBTTtBQUN4SCxpQ0FBaUMscUJBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFlLG1CQUFtQixFQUFDIiwic291cmNlcyI6WyIvaG9tZS9hZGVzb2xhL0Vwb2NoTGFiL0Vwb2NoRGFzaGJvYXJkL2pzL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvY2hhcnRfZGVmLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QyKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QyIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kMiA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kMiksIG1vZDIuZXhwb3J0cztcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanNcbnZhciByZXF1aXJlX2FzcHJvbWlzZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGFzUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eCkge1xuICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksIG9mZnNldCA9IDAsIGluZGV4ID0gMiwgcGVuZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcGFyYW1zMiA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksIG9mZnNldDIgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0MiA8IHBhcmFtczIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHBhcmFtczJbb2Zmc2V0MisrXSA9IGFyZ3VtZW50c1tvZmZzZXQyXTtcbiAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanNcbnZhciByZXF1aXJlX2Jhc2U2NCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiYXNlNjQgPSBleHBvcnRzMjtcbiAgICBiYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xuICAgICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKCFwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcbiAgICAgICAgKytuO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcbiAgICB9O1xuICAgIHZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xuICAgIHZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IClcbiAgICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcbiAgICB2YXIgaTtcbiAgICBiYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHBhcnRzID0gbnVsbCwgY2h1bmsgPSBbXTtcbiAgICAgIHZhciBpMiA9IDAsIGogPSAwLCB0O1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFtiID4+IDJdO1xuICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbdCB8IGIgPj4gNF07XG4gICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbdCB8IGIgPj4gNl07XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFtiICYgNjNdO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPiA4MTkxKSB7XG4gICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChqKSB7XG4gICAgICAgIGNodW5rW2kyKytdID0gYjY0W3RdO1xuICAgICAgICBjaHVua1tpMisrXSA9IDYxO1xuICAgICAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgICBjaHVua1tpMisrXSA9IDYxO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIGlmIChpMilcbiAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpMikpKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkyKSk7XG4gICAgfTtcbiAgICB2YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XG4gICAgYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICB2YXIgaiA9IDAsIHQ7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3RyaW5nLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaTIrKyk7XG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XG4gICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgaiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcbiAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgaiA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XG4gICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgIGogPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuICAgIGJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ldmVudGVtaXR0ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcbiAgICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xuICAgICAgICBmbixcbiAgICAgICAgY3R4OiBjdHggfHwgdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcbiAgICAgIGlmIChldnQgPT09IHZvaWQgMClcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZuID09PSB2b2lkIDApXG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKVxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXG4gICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyApXG4gICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IClcbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanNcbnZhciByZXF1aXJlX2Zsb2F0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xuICAgIGZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0czMpIHtcbiAgICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFstMF0pLCBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSwgbGUgPSBmOGJbM10gPT09IDEyODtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmMzJbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbMF07XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmMzJbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3NdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XG4gICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xuICAgICAgICAgIHJldHVybiBmMzJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICByZXR1cm4gZjMyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcbiAgICAgIH0pKCk7XG4gICAgICBlbHNlIChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xuICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgdmFsID0gLXZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAwKVxuICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gKFxuICAgICAgICAgICAgICAvKiBwb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAvKiBuZWdhdGl2ZSAwICovXG4gICAgICAgICAgICAgIDIxNDc0ODM2NDhcbiAgICAgICAgICAgICksIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxuICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzNDAyODIzNDY2Mzg1Mjg4NmUyMilcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSBpZiAodmFsIDwgMTE3NTQ5NDM1MDgyMjI4NzVlLTU0KVxuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxNDAxMjk4NDY0MzI0ODE3ZS02MCkpID4+PiAwLCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xuICAgICAgICBleHBvcnRzMy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLCBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XG4gICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTUgPyBtYW50aXNzYSA/IE5hTiA6IHNpZ24gKiBJbmZpbml0eSA6IGV4cG9uZW50ID09PSAwID8gc2lnbiAqIDE0MDEyOTg0NjQzMjQ4MTdlLTYwICogbWFudGlzc2EgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLCBsZSA9IGY4Yls3XSA9PT0gMTI4O1xuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmNjRbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbMF07XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcbiAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XG4gICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGY2NFswXSA9IHZhbDtcbiAgICAgICAgICBidWZbcG9zXSA9IGY4Yls3XTtcbiAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XG4gICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcbiAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XG4gICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xuICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcbiAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XG4gICAgICAgICAgcmV0dXJuIGY2NFswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbN10gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XG4gICAgICAgICAgcmV0dXJuIGY2NFswXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XG4gICAgICB9KSgpO1xuICAgICAgZWxzZSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XG4gICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICB2YWwgPSAtdmFsO1xuICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gKFxuICAgICAgICAgICAgICAvKiBwb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAvKiBuZWdhdGl2ZSAwICovXG4gICAgICAgICAgICAgIDIxNDc0ODM2NDhcbiAgICAgICAgICAgICksIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMTc5NzY5MzEzNDg2MjMxNTdlMjkyKSB7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWFudGlzc2E7XG4gICAgICAgICAgICBpZiAodmFsIDwgMjIyNTA3Mzg1ODUwNzIwMTRlLTMyNCkge1xuICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcbiAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xuICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XG4gICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcbiAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLCBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NywgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcbiAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDcgPyBtYW50aXNzYSA/IE5hTiA6IHNpZ24gKiBJbmZpbml0eSA6IGV4cG9uZW50ID09PSAwID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAxXSA9IHZhbCA+Pj4gOCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAyXSA9IHZhbCA+Pj4gMTYgJiAyNTU7XG4gICAgICBidWZbcG9zICsgM10gPSB2YWwgPj4+IDI0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCA+Pj4gMjQ7XG4gICAgICBidWZbcG9zICsgMV0gPSB2YWwgPj4+IDE2ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDJdID0gdmFsID4+PiA4ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDNdID0gdmFsICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XG4gICAgICByZXR1cm4gKGJ1Zltwb3NdIHwgYnVmW3BvcyArIDFdIDw8IDggfCBidWZbcG9zICsgMl0gPDwgMTYgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XG4gICAgICByZXR1cm4gKGJ1Zltwb3NdIDw8IDI0IHwgYnVmW3BvcyArIDFdIDw8IDE2IHwgYnVmW3BvcyArIDJdIDw8IDggfCBidWZbcG9zICsgM10pID4+PiAwO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9pbnF1aXJlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XG4gICAgZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sIFwicmVcIikpKG1vZHVsZU5hbWUpO1xuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanNcbnZhciByZXF1aXJlX3V0ZjggPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHV0ZjggPSBleHBvcnRzMjtcbiAgICB1dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xuICAgICAgdmFyIGxlbiA9IDAsIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOClcbiAgICAgICAgICBsZW4gKz0gMTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgbGVuICs9IDI7XG4gICAgICAgIGVsc2UgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgNjQ1MTIpID09PSA1NjMyMCkge1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBsZW4gKz0gNDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbGVuICs9IDM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH07XG4gICAgdXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGxlbiA8IDEpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgdmFyIHBhcnRzID0gbnVsbCwgY2h1bmsgPSBbXSwgaSA9IDAsIHQ7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcbiAgICAgICAgaWYgKHQgPCAxMjgpXG4gICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcbiAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcbiAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gNjU1MzY7XG4gICAgICAgICAgY2h1bmtbaSsrXSA9IDU1Mjk2ICsgKHQgPj4gMTApO1xuICAgICAgICAgIGNodW5rW2krK10gPSA1NjMyMCArICh0ICYgMTAyMyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcbiAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcbiAgICB9O1xuICAgIHV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzdGFydCA9IG9mZnNldCwgYzEsIGMyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2IHwgMTkyO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAmIDYzIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiA2NDUxMikgPT09IDU2MzIwKSB7XG4gICAgICAgICAgYzEgPSA2NTUzNiArICgoYzEgJiAxMDIzKSA8PCAxMCkgKyAoYzIgJiAxMDIzKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4IHwgMjQwO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICYgNjMgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyIHwgMjI0O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICYgNjMgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanNcbnZhciByZXF1aXJlX3Bvb2wgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcG9vbDtcbiAgICBmdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xuICAgICAgdmFyIFNJWkUgPSBzaXplIHx8IDgxOTI7XG4gICAgICB2YXIgTUFYID0gU0laRSA+Pj4gMTtcbiAgICAgIHZhciBzbGFiID0gbnVsbDtcbiAgICAgIHZhciBvZmZzZXQgPSBTSVpFO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZTIpIHtcbiAgICAgICAgaWYgKHNpemUyIDwgMSB8fCBzaXplMiA+IE1BWClcbiAgICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZTIpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZTIgPiBTSVpFKSB7XG4gICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCBvZmZzZXQgKz0gc2l6ZTIpO1xuICAgICAgICBpZiAob2Zmc2V0ICYgNylcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IHwgNykgKyAxO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qc1xudmFyIHJlcXVpcmVfbG9uZ2JpdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gTG9uZ0JpdHM7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcbiAgICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcbiAgICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbiAgICB9XG4gICAgdmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgdmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuICAgIExvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCwgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG4gICAgfTtcbiAgICBMb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCwgaGkgPSB+dGhpcy5oaSA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5NjtcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICAgIHJldHVybiB1dGlsLkxvbmcgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG4gICAgfTtcbiAgICB2YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcbiAgICBMb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDggfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTYgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwLFxuICAgICAgICAoY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDggfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTYgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgICApO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQsXG4gICAgICAgIHRoaXMuaGkgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICAgKTtcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgICAgdmFyIG1hc2sgPSB0aGlzLmhpID4+IDMxO1xuICAgICAgdGhpcy5oaSA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSBeIG1hc2spID4+PiAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICAgIHRoaXMuaGkgPSAodGhpcy5oaSA+Pj4gMSBeIG1hc2spID4+PiAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgdmFyIHBhcnQwID0gdGhpcy5sbywgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLCBwYXJ0MiA9IHRoaXMuaGkgPj4+IDI0O1xuICAgICAgcmV0dXJuIHBhcnQyID09PSAwID8gcGFydDEgPT09IDAgPyBwYXJ0MCA8IDE2Mzg0ID8gcGFydDAgPCAxMjggPyAxIDogMiA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0IDogcGFydDEgPCAxNjM4NCA/IHBhcnQxIDwgMTI4ID8gNSA6IDYgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOCA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzXG52YXIgcmVxdWlyZV9taW5pbWFsID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHV0aWwgPSBleHBvcnRzMjtcbiAgICB1dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmVfYXNwcm9taXNlKCk7XG4gICAgdXRpbC5iYXNlNjQgPSByZXF1aXJlX2Jhc2U2NCgpO1xuICAgIHV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZV9ldmVudGVtaXR0ZXIoKTtcbiAgICB1dGlsLmZsb2F0ID0gcmVxdWlyZV9mbG9hdCgpO1xuICAgIHV0aWwuaW5xdWlyZSA9IHJlcXVpcmVfaW5xdWlyZSgpO1xuICAgIHV0aWwudXRmOCA9IHJlcXVpcmVfdXRmOCgpO1xuICAgIHV0aWwucG9vbCA9IHJlcXVpcmVfcG9vbCgpO1xuICAgIHV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlX2xvbmdiaXRzKCk7XG4gICAgdXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsICYmIGdsb2JhbC5wcm9jZXNzICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuICAgIHV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgZXhwb3J0czI7XG4gICAgdXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogKFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIFtdXG4gICAgKTtcbiAgICB1dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogKFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHt9XG4gICAgKTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuICAgIHV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9O1xuICAgIHV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgICB9O1xuICAgIHV0aWwuaXNzZXQgPSAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gICAgICovXG4gICAgdXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHV0aWwuQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyMiA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIHJldHVybiBCdWZmZXIyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIyIDogKFxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgdXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCIgPyB1dGlsLkJ1ZmZlciA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSkgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSkgOiB1dGlsLkJ1ZmZlciA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KSA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gc2l6ZU9yQXJyYXkgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG4gICAgfTtcbiAgICB1dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IDogQXJyYXk7XG4gICAgdXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5nbG9iYWwuTG9uZyB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuICAgIHV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuICAgIHV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuICAgIHV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcbiAgICB1dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbiAgICB9O1xuICAgIHV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkge1xuICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdm9pZCAwIHx8ICFpZk5vdFNldClcbiAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICB1dGlsLm1lcmdlID0gbWVyZ2U7XG4gICAgdXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuICAgICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9IH0pO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IHZvaWQgMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXG4gICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBidXQgSSdtIGd1ZXNzaW5nIHRoYXQgd2FzIG5vdCBpbnRlbnRpb25hbC5cbiAgICAgICAgICAvLyBGb3IgYW4gYWN0dWFsIGVycm9yIHN1YmNsYXNzLCB0aGlzIHByb3BlcnR5IHdvdWxkXG4gICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG4gICAgfVxuICAgIHV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcbiAgICB1dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG4gICAgdXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaTIgPSBrZXlzLmxlbmd0aCAtIDE7IGkyID4gLTE7IC0taTIpXG4gICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaTJdXSA9PT0gMSAmJiB0aGlzW2tleXNbaTJdXSAhPT0gdm9pZCAwICYmIHRoaXNba2V5c1tpMl1dICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGtleXNbaTJdO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB1dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgICBsb25nczogU3RyaW5nLFxuICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICB1dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBCdWZmZXIyID0gdXRpbC5CdWZmZXI7XG4gICAgICBpZiAoIUJ1ZmZlcjIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlcjIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlcjIuZnJvbSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyMih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgfTtcbiAgICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlcjIuYWxsb2NVbnNhZmUgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyMihzaXplKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanNcbnZhciByZXF1aXJlX3dyaXRlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFdyaXRlcjtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIHZhciBCdWZmZXJXcml0ZXI7XG4gICAgdmFyIExvbmdCaXRzID0gdXRpbC5Mb25nQml0cztcbiAgICB2YXIgYmFzZTY0ID0gdXRpbC5iYXNlNjQ7XG4gICAgdmFyIHV0ZjggPSB1dGlsLnV0Zjg7XG4gICAgZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuICAgICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG4gICAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG4gICAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0ZXIoKSB7XG4gICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG4gICAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUyKCkge1xuICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICB9KSgpO1xuICAgICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuICAgIFdyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGJ1Zltwb3NdID0gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB9XG4gICAgVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuICAgIFZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG4gICAgV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApIDwgMTI4ID8gMSA6IHZhbHVlIDwgMTYzODQgPyAyIDogdmFsdWUgPCAyMDk3MTUyID8gMyA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNCA6IDUsXG4gICAgICAgIHZhbHVlXG4gICAgICApKS5sZW47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSA6IHRoaXMudWludDMyKHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgICAgfVxuICAgICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgICB9XG4gICAgICBidWZbcG9zKytdID0gdmFsLmxvO1xuICAgIH1cbiAgICBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG4gICAgICBidWZbcG9zICsgMV0gPSB2YWwgPj4+IDggJiAyNTU7XG4gICAgICBidWZbcG9zICsgMl0gPSB2YWwgPj4+IDE2ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDNdID0gdmFsID4+PiAyNDtcbiAgICB9XG4gICAgV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuICAgIFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0ID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmLnNldCh2YWwsIHBvcyk7XG4gICAgfSA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgICAgcmV0dXJuIGxlbiA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSkgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsIHRhaWwgPSB0aGlzLnRhaWwsIGxlbiA9IHRoaXMubGVuO1xuICAgICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDtcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIGJ1ZiA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLCBwb3MgPSAwO1xuICAgICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanNcbnZhciByZXF1aXJlX3dyaXRlcl9idWZmZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuICAgIHZhciBXcml0ZXIgPSByZXF1aXJlX3dyaXRlcigpO1xuICAgIChCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcbiAgICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCIgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpO1xuICAgICAgfSA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGlmICh2YWwuY29weSlcbiAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyApXG4gICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgfTtcbiAgICB9O1xuICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgICAgdGhpcy51aW50MzIobGVuKTtcbiAgICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBpZiAodmFsLmxlbmd0aCA8IDQwKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbiAgICB9XG4gICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzXG52YXIgcmVxdWlyZV9yZWFkZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBSZWFkZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICB2YXIgQnVmZmVyUmVhZGVyO1xuICAgIHZhciBMb25nQml0cyA9IHV0aWwuTG9uZ0JpdHM7XG4gICAgdmFyIHV0ZjggPSB1dGlsLnV0Zjg7XG4gICAgZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9IDogZnVuY3Rpb24gY3JlYXRlX2FycmF5MihidWZmZXIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZTIoKSB7XG4gICAgICByZXR1cm4gdXRpbC5CdWZmZXIgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcjIpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyMikgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcjIpIDogY3JlYXRlX2FycmF5KGJ1ZmZlcjIpO1xuICAgICAgICB9KShidWZmZXIpO1xuICAgICAgfSA6IGNyZWF0ZV9hcnJheTtcbiAgICB9O1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCA3KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxNSkgPDwgMjgpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIFJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkge1xuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+IDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG4gICAgfVxuICAgIFJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7XG4gICAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XSB8IGJ1ZltlbmQgLSAzXSA8PCA4IHwgYnVmW2VuZCAtIDJdIDw8IDE2IHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbiAgICB9XG4gICAgUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWFkRml4ZWQ2NCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuICAgICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbiAgICB9XG4gICAgUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgICAgICByZXR1cm4gbmF0aXZlQnVmZmVyID8gbmF0aXZlQnVmZmVyLmFsbG9jKDApIDogbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4gICAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogKFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBcInRvTnVtYmVyXCJcbiAgICAgICk7XG4gICAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanNcbnZhciByZXF1aXJlX3JlYWRlcl9idWZmZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuICAgIHZhciBSZWFkZXIgPSByZXF1aXJlX3JlYWRlcigpO1xuICAgIChCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuICAgIH1cbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbiAgICB9O1xuICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbiAgICB9O1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanNcbnZhciByZXF1aXJlX3NlcnZpY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFNlcnZpY2U7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICAoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG4gICAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcbiAgICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG4gICAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG4gICAgfVxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZjIsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG4gICAgICBpZiAoIXNlbGYyLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmMi5ycGNJbXBsKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmMi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZjIuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZjIuZW5kKFxuICAgICAgICAgICAgICAgIC8qIGVuZGVkQnlSUEMgKi9cbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmMi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICBzZWxmMi5lbWl0KFwiZXJyb3JcIiwgZXJyMiwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYyLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZjIuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQylcbiAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzXG52YXIgcmVxdWlyZV9ycGMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcnBjID0gZXhwb3J0czI7XG4gICAgcnBjLlNlcnZpY2UgPSByZXF1aXJlX3NlcnZpY2UoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qc1xudmFyIHJlcXVpcmVfcm9vdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHt9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanNcbnZhciByZXF1aXJlX2luZGV4X21pbmltYWwgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHByb3RvYnVmID0gZXhwb3J0czI7XG4gICAgcHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcbiAgICBwcm90b2J1Zi5Xcml0ZXIgPSByZXF1aXJlX3dyaXRlcigpO1xuICAgIHByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmVfd3JpdGVyX2J1ZmZlcigpO1xuICAgIHByb3RvYnVmLlJlYWRlciA9IHJlcXVpcmVfcmVhZGVyKCk7XG4gICAgcHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZV9yZWFkZXJfYnVmZmVyKCk7XG4gICAgcHJvdG9idWYudXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIHByb3RvYnVmLnJwYyA9IHJlcXVpcmVfcnBjKCk7XG4gICAgcHJvdG9idWYucm9vdHMgPSByZXF1aXJlX3Jvb3RzKCk7XG4gICAgcHJvdG9idWYuY29uZmlndXJlID0gY29uZmlndXJlO1xuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG4gICAgfVxuICAgIGNvbmZpZ3VyZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qc1xudmFyIHJlcXVpcmVfbWluaW1hbDIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2luZGV4X21pbmltYWwoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy9jaGFydF9kZWYuanNcbnZhciByZXF1aXJlX2NoYXJ0X2RlZiA9IF9fY29tbW9uSlMoe1xuICBcInNyYy9jaGFydF9kZWYuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciAkcHJvdG9idWYgPSByZXF1aXJlX21pbmltYWwyKCk7XG4gICAgdmFyICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyO1xuICAgIHZhciAkV3JpdGVyID0gJHByb3RvYnVmLldyaXRlcjtcbiAgICB2YXIgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcbiAgICB2YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuICAgICRyb290LmVwb2NoX3Byb3RvID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXBvY2hfcHJvdG8gPSB7fTtcbiAgICAgIGVwb2NoX3Byb3RvLkF4aXNEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQXhpc0RlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBeGlzRGVmLnByb3RvdHlwZS50eXBlID0gbnVsbDtcbiAgICAgICAgQXhpc0RlZi5wcm90b3R5cGUubGFiZWwgPSBudWxsO1xuICAgICAgICBBeGlzRGVmLnByb3RvdHlwZS5jYXRlZ29yaWVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNEZWYucHJvdG90eXBlLCBcIl90eXBlXCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcInR5cGVcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNEZWYucHJvdG90eXBlLCBcIl9sYWJlbFwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJsYWJlbFwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBBeGlzRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBeGlzRGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidHlwZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDhcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5sYWJlbCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibGFiZWxcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5sYWJlbCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcmllcyAhPSBudWxsICYmIG1lc3NhZ2UuY2F0ZWdvcmllcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY2F0ZWdvcmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcmllc1tpXSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQXhpc0RlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEF4aXNEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxhYmVsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2F0ZWdvcmllcyAmJiBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXhpc0RlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX3R5cGUgPSAxO1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5sYWJlbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsYWJlbFwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5fbGFiZWwgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmxhYmVsKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwibGFiZWw6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yaWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3JpZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmNhdGVnb3JpZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yaWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5jYXRlZ29yaWVzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yaWVzOiBzdHJpbmdbXSBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQXhpc0RlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZigpO1xuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBeGlzVW5zcGVjaWZpZWRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXhpc0xpbmVhclwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBeGlzTG9nYXJpdGhtaWNcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXhpc0RhdGVUaW1lXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkF4aXNDYXRlZ29yeVwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5sYWJlbCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5sYWJlbCA9IFN0cmluZyhvYmplY3QubGFiZWwpO1xuICAgICAgICAgIGlmIChvYmplY3QuY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5jYXRlZ29yaWVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkF4aXNEZWYuY2F0ZWdvcmllczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNhdGVnb3JpZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllc1tpXSA9IFN0cmluZyhvYmplY3QuY2F0ZWdvcmllc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5lcG9jaF9wcm90by5BeGlzVHlwZVttZXNzYWdlLnR5cGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5lcG9jaF9wcm90by5BeGlzVHlwZVttZXNzYWdlLnR5cGVdIDogbWVzc2FnZS50eXBlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX3R5cGUgPSBcInR5cGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGFiZWwgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGFiZWxcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5sYWJlbCA9IG1lc3NhZ2UubGFiZWw7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5fbGFiZWwgPSBcImxhYmVsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgJiYgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllc1tqXSA9IG1lc3NhZ2UuY2F0ZWdvcmllc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQXhpc0RlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQXhpc0RlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXhpc0RlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkNoYXJ0RGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoYXJ0RGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENoYXJ0RGVmLnByb3RvdHlwZS5pZCA9IFwiXCI7XG4gICAgICAgIENoYXJ0RGVmLnByb3RvdHlwZS50aXRsZSA9IFwiXCI7XG4gICAgICAgIENoYXJ0RGVmLnByb3RvdHlwZS50eXBlID0gMDtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLmNhdGVnb3J5ID0gXCJcIjtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLnlBeGlzID0gbnVsbDtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLnhBeGlzID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0RGVmLnByb3RvdHlwZSwgXCJfeUF4aXNcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wieUF4aXNcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0RGVmLnByb3RvdHlwZSwgXCJfeEF4aXNcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wieEF4aXNcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgQ2hhcnREZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENoYXJ0RGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydERlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmlkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJpZFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLmlkKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGl0bGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS50aXRsZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidHlwZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDI0XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNhdGVnb3J5XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMzRcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnlBeGlzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ5QXhpc1wiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYuZW5jb2RlKG1lc3NhZ2UueUF4aXMsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDQyXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueEF4aXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInhBeGlzXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi5lbmNvZGUobWVzc2FnZS54QXhpcywgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydERlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueUF4aXMgPSAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54QXhpcyA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaWRcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5pZCkpXG4gICAgICAgICAgICAgIHJldHVybiBcImlkOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50aXRsZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInRpdGxlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmNhdGVnb3J5KSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcnk6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55QXhpcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5QXhpc1wiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5feUF4aXMgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmLnZlcmlmeShtZXNzYWdlLnlBeGlzKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInlBeGlzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnhBeGlzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhBeGlzXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl94QXhpcyA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYudmVyaWZ5KG1lc3NhZ2UueEF4aXMpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieEF4aXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmlkICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmlkID0gU3RyaW5nKG9iamVjdC5pZCk7XG4gICAgICAgICAgaWYgKG9iamVjdC50aXRsZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IFN0cmluZyhvYmplY3QudGl0bGUpO1xuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRVbnNwZWNpZmllZFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRDYXJkXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldExpbmVzXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEJhclwiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXREYXRhVGFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0WFJhbmdlXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEhpc3RvZ3JhbVwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRQaWVcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0SGVhdE1hcFwiOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRCb3hQbG90XCI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEFyZWFcIjpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRDb2x1bW5cIjpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yeSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yeSA9IFN0cmluZyhvYmplY3QuY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChvYmplY3QueUF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QueUF4aXMgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydERlZi55QXhpczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS55QXhpcyA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYuZnJvbU9iamVjdChvYmplY3QueUF4aXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnhBeGlzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnhBeGlzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2hhcnREZWYueEF4aXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UueEF4aXMgPSAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmLmZyb21PYmplY3Qob2JqZWN0LnhBeGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5pZCA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIldpZGdldFVuc3BlY2lmaWVkXCIgOiAwO1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5ID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaWRcIikpXG4gICAgICAgICAgICBvYmplY3QuaWQgPSBtZXNzYWdlLmlkO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpdGxlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gbWVzc2FnZS50aXRsZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmVwb2NoX3Byb3RvLkVwb2NoRm9saW9EYXNoYm9hcmRXaWRnZXRbbWVzc2FnZS50eXBlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS50eXBlIDogJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldFttZXNzYWdlLnR5cGVdIDogbWVzc2FnZS50eXBlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5ID0gbWVzc2FnZS5jYXRlZ29yeTtcbiAgICAgICAgICBpZiAobWVzc2FnZS55QXhpcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5QXhpc1wiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnlBeGlzID0gJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi50b09iamVjdChtZXNzYWdlLnlBeGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll95QXhpcyA9IFwieUF4aXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueEF4aXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieEF4aXNcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC54QXhpcyA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYudG9PYmplY3QobWVzc2FnZS54QXhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5feEF4aXMgPSBcInhBeGlzXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQ2hhcnREZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENoYXJ0RGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFN0cmFpZ2h0TGluZURlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTdHJhaWdodExpbmVEZWYucHJvdG90eXBlLnRpdGxlID0gXCJcIjtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLnByb3RvdHlwZS52YWx1ZSA9IDA7XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5wcm90b3R5cGUudmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJhaWdodExpbmVEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0aXRsZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAxN1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmVydGljYWwgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInZlcnRpY2FsXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMjRcbiAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLnZlcnRpY2FsKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBTdHJhaWdodExpbmVEZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBTdHJhaWdodExpbmVEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnRpY2FsID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50aXRsZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInRpdGxlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52YWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJ0aWNhbFwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnZlcnRpY2FsICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWw6IGJvb2xlYW4gZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnRpdGxlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gU3RyaW5nKG9iamVjdC50aXRsZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IE51bWJlcihvYmplY3QudmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QudmVydGljYWwgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UudmVydGljYWwgPSBCb29sZWFuKG9iamVjdC52ZXJ0aWNhbCk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gMDtcbiAgICAgICAgICAgIG9iamVjdC52ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aXRsZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50aXRsZSA9IG1lc3NhZ2UudGl0bGU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UudmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UudmFsdWUpIDogbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJ0aWNhbFwiKSlcbiAgICAgICAgICAgIG9iamVjdC52ZXJ0aWNhbCA9IG1lc3NhZ2UudmVydGljYWw7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyYWlnaHRMaW5lRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBCYW5kKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEJhbmQucHJvdG90eXBlLmZyb20gPSBudWxsO1xuICAgICAgICBCYW5kLnByb3RvdHlwZS50byA9IG51bGw7XG4gICAgICAgIEJhbmQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJhbmQocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5mcm9tICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJmcm9tXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLmZyb20sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG8gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRvXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLnRvLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBCYW5kLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQmFuZCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50byA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmZyb20gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZnJvbVwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnZlcmlmeShtZXNzYWdlLmZyb20pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJmcm9tLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRvXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudmVyaWZ5KG1lc3NhZ2UudG8pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ0by5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQmFuZClcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQmFuZCgpO1xuICAgICAgICAgIGlmIChvYmplY3QuZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5mcm9tICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQmFuZC5mcm9tOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmZyb20gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZnJvbU9iamVjdChvYmplY3QuZnJvbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudG8gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5CYW5kLnRvOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnRvID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmZyb21PYmplY3Qob2JqZWN0LnRvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LmZyb20gPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LnRvID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnJvbSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmcm9tXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmZyb20gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudG9PYmplY3QobWVzc2FnZS5mcm9tLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50byAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0b1wiKSlcbiAgICAgICAgICAgIG9iamVjdC50byA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci50b09iamVjdChtZXNzYWdlLnRvLCBvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBCYW5kLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5CYW5kXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCYW5kO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUG9pbnQocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUG9pbnQucHJvdG90eXBlLnggPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCBmYWxzZSkgOiAwO1xuICAgICAgICBQb2ludC5wcm90b3R5cGUueSA9IDA7XG4gICAgICAgIFBvaW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ4XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLngpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAxN1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS55KTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBQb2ludC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54KSAmJiAhKG1lc3NhZ2UueCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueC5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIng6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS55ICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ5OiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Qb2ludClcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLnggPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QueCkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnggPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueCA9IHBhcnNlSW50KG9iamVjdC54LCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueCA9IG9iamVjdC54O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54ID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnggPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LngubG93ID4+PiAwLCBvYmplY3QueC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnkgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UueSA9IE51bWJlcihvYmplY3QueSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QueSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLngpIDogbWVzc2FnZS54O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS54KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLngubG93ID4+PiAwLCBtZXNzYWdlLnguaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UueDtcbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpXG4gICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS55KSA/IFN0cmluZyhtZXNzYWdlLnkpIDogbWVzc2FnZS55O1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uUG9pbnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBvaW50O1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uTGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBMaW5lKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpbmUucHJvdG90eXBlLmRhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcbiAgICAgICAgTGluZS5wcm90b3R5cGUuZGFzaFN0eWxlID0gbnVsbDtcbiAgICAgICAgTGluZS5wcm90b3R5cGUubGluZVdpZHRoID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUucHJvdG90eXBlLCBcIl9kYXNoU3R5bGVcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZGFzaFN0eWxlXCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5lLnByb3RvdHlwZSwgXCJfbGluZVdpZHRoXCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImxpbmVXaWR0aFwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBMaW5lLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQuZW5jb2RlKG1lc3NhZ2UuZGF0YVtpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJuYW1lXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGFzaFN0eWxlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXNoU3R5bGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAyNFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLmRhc2hTdHlsZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZVdpZHRoICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJsaW5lV2lkdGhcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAzMlxuICAgICAgICAgICAgKS51aW50MzIobWVzc2FnZS5saW5lV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uTGluZSgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lV2lkdGggPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRhdGEpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQudmVyaWZ5KG1lc3NhZ2UuZGF0YVtpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGFzaFN0eWxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhc2hTdHlsZVwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5fZGFzaFN0eWxlID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5kYXNoU3R5bGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXNoU3R5bGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lV2lkdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGluZVdpZHRoXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl9saW5lV2lkdGggPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5saW5lV2lkdGgpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJsaW5lV2lkdGg6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkxpbmUpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkxpbmUoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGF0YSkpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lLmRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGFbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmUuZGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5Qb2ludC5mcm9tT2JqZWN0KG9iamVjdC5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LmRhc2hTdHlsZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGFzaFN0eWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSBvYmplY3QuZGFzaFN0eWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRhc2hTdHlsZVVuc3BlY2lmaWVkXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU29saWRcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTaG9ydERhc2hcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTaG9ydERvdFwiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNob3J0RGFzaERvdFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNob3J0RGFzaERvdERvdFwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRvdFwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRhc2hcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMb25nRGFzaFwiOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRhc2hEb3RcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMb25nRGFzaERvdFwiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTG9uZ0Rhc2hEb3REb3RcIjpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmxpbmVXaWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5saW5lV2lkdGggPSBvYmplY3QubGluZVdpZHRoID4+PiAwO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QuZGF0YVtqXSA9ICRyb290LmVwb2NoX3Byb3RvLlBvaW50LnRvT2JqZWN0KG1lc3NhZ2UuZGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhc2hTdHlsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXNoU3R5bGVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5kYXNoU3R5bGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5lcG9jaF9wcm90by5EYXNoU3R5bGVbbWVzc2FnZS5kYXNoU3R5bGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLmRhc2hTdHlsZSA6ICRyb290LmVwb2NoX3Byb3RvLkRhc2hTdHlsZVttZXNzYWdlLmRhc2hTdHlsZV0gOiBtZXNzYWdlLmRhc2hTdHlsZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9kYXNoU3R5bGUgPSBcImRhc2hTdHlsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lV2lkdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGluZVdpZHRoXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QubGluZVdpZHRoID0gbWVzc2FnZS5saW5lV2lkdGg7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5fbGluZVdpZHRoID0gXCJsaW5lV2lkdGhcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uTGluZVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGluZTtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkxpbmVzRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpbmVzRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmxpbmVzID0gW107XG4gICAgICAgICAgdGhpcy5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgdGhpcy55UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgdGhpcy54UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBMaW5lc0RlZi5wcm90b3R5cGUuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICBMaW5lc0RlZi5wcm90b3R5cGUubGluZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBMaW5lc0RlZi5wcm90b3R5cGUuc3RyYWlnaHRMaW5lcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS55UGxvdEJhbmRzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgTGluZXNEZWYucHJvdG90eXBlLnhQbG90QmFuZHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBMaW5lc0RlZi5wcm90b3R5cGUub3ZlcmxheSA9IG51bGw7XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS5zdGFja2VkID0gZmFsc2U7XG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMaW5lc0RlZi5wcm90b3R5cGUsIFwiX292ZXJsYXlcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wib3ZlcmxheVwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBMaW5lc0RlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgTGluZXNEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZW5jb2RlKG1lc3NhZ2UuY2hhcnREZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmxpbmVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5saW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uTGluZS5lbmNvZGUobWVzc2FnZS5saW5lc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJhaWdodExpbmVzICE9IG51bGwgJiYgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYuZW5jb2RlKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS55UGxvdEJhbmRzICE9IG51bGwgJiYgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5CYW5kLmVuY29kZShtZXNzYWdlLnlQbG90QmFuZHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAzNFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFBsb3RCYW5kcyAhPSBudWxsICYmIG1lc3NhZ2UueFBsb3RCYW5kcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UueFBsb3RCYW5kcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQmFuZC5lbmNvZGUobWVzc2FnZS54UGxvdEJhbmRzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgNDJcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm92ZXJsYXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm92ZXJsYXlcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5MaW5lLmVuY29kZShtZXNzYWdlLm92ZXJsYXksIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDYsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDUwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhY2tlZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RhY2tlZFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDcsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDU2XG4gICAgICAgICAgICApLmJvb2wobWVzc2FnZS5zdGFja2VkKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lc0RlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubGluZXMgJiYgbWVzc2FnZS5saW5lcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGluZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5MaW5lLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnlQbG90QmFuZHMgJiYgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnlQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnlQbG90QmFuZHMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5CYW5kLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UueFBsb3RCYW5kcyAmJiBtZXNzYWdlLnhQbG90QmFuZHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UueFBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueFBsb3RCYW5kcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkJhbmQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5vdmVybGF5ID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RhY2tlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lc0RlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi52ZXJpZnkobWVzc2FnZS5jaGFydERlZik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0RGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpbmVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5saW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiBcImxpbmVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmUudmVyaWZ5KG1lc3NhZ2UubGluZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibGluZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJhaWdodExpbmVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyYWlnaHRMaW5lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi52ZXJpZnkobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmFpZ2h0TGluZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueVBsb3RCYW5kcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5UGxvdEJhbmRzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS55UGxvdEJhbmRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwieVBsb3RCYW5kczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQudmVyaWZ5KG1lc3NhZ2UueVBsb3RCYW5kc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ5UGxvdEJhbmRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnhQbG90QmFuZHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFBsb3RCYW5kc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UueFBsb3RCYW5kcykpXG4gICAgICAgICAgICAgIHJldHVybiBcInhQbG90QmFuZHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UueFBsb3RCYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5CYW5kLnZlcmlmeShtZXNzYWdlLnhQbG90QmFuZHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieFBsb3RCYW5kcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5vdmVybGF5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm92ZXJsYXlcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX292ZXJsYXkgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5MaW5lLnZlcmlmeShtZXNzYWdlLm92ZXJsYXkpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib3ZlcmxheS5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5zdGFja2VkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0YWNrZWRcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5zdGFja2VkICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RhY2tlZDogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5MaW5lc0RlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QuY2hhcnREZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuY2hhcnREZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5saW5lcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5saW5lcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5saW5lczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmxpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5saW5lc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uTGluZXNEZWYubGluZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5saW5lc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmUuZnJvbU9iamVjdChvYmplY3QubGluZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnN0cmFpZ2h0TGluZXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Quc3RyYWlnaHRMaW5lcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5zdHJhaWdodExpbmVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJhaWdodExpbmVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5zdHJhaWdodExpbmVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5mcm9tT2JqZWN0KG9iamVjdC5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC55UGxvdEJhbmRzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnlQbG90QmFuZHMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uTGluZXNEZWYueVBsb3RCYW5kczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnlQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnlQbG90QmFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QueVBsb3RCYW5kc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uTGluZXNEZWYueVBsb3RCYW5kczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnlQbG90QmFuZHNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5CYW5kLmZyb21PYmplY3Qob2JqZWN0LnlQbG90QmFuZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnhQbG90QmFuZHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QueFBsb3RCYW5kcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi54UGxvdEJhbmRzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UueFBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QueFBsb3RCYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC54UGxvdEJhbmRzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi54UGxvdEJhbmRzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UueFBsb3RCYW5kc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQuZnJvbU9iamVjdChvYmplY3QueFBsb3RCYW5kc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Qub3ZlcmxheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5vdmVybGF5ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uTGluZXNEZWYub3ZlcmxheTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5vdmVybGF5ID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS5mcm9tT2JqZWN0KG9iamVjdC5vdmVybGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5zdGFja2VkICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnN0YWNrZWQgPSBCb29sZWFuKG9iamVjdC5zdGFja2VkKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LmxpbmVzID0gW107XG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgb2JqZWN0LnlQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICAgIG9iamVjdC54UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LnN0YWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi50b09iamVjdChtZXNzYWdlLmNoYXJ0RGVmLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lcyAmJiBtZXNzYWdlLmxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmxpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UubGluZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5saW5lc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmUudG9PYmplY3QobWVzc2FnZS5saW5lc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgJiYgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi50b09iamVjdChtZXNzYWdlLnN0cmFpZ2h0TGluZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55UGxvdEJhbmRzICYmIG1lc3NhZ2UueVBsb3RCYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC55UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UueVBsb3RCYW5kcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnlQbG90QmFuZHNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5CYW5kLnRvT2JqZWN0KG1lc3NhZ2UueVBsb3RCYW5kc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnhQbG90QmFuZHMgJiYgbWVzc2FnZS54UGxvdEJhbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnhQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS54UGxvdEJhbmRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QueFBsb3RCYW5kc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQudG9PYmplY3QobWVzc2FnZS54UGxvdEJhbmRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uub3ZlcmxheSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJvdmVybGF5XCIpKSB7XG4gICAgICAgICAgICBvYmplY3Qub3ZlcmxheSA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmUudG9PYmplY3QobWVzc2FnZS5vdmVybGF5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9vdmVybGF5ID0gXCJvdmVybGF5XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnN0YWNrZWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RhY2tlZFwiKSlcbiAgICAgICAgICAgIG9iamVjdC5zdGFja2VkID0gbWVzc2FnZS5zdGFja2VkO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uTGluZXNEZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIExpbmVzRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhlYXRNYXBQb2ludChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWF0TWFwUG9pbnQucHJvdG90eXBlLnggPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gICAgICAgIEhlYXRNYXBQb2ludC5wcm90b3R5cGUueSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgICAgICAgSGVhdE1hcFBvaW50LnByb3RvdHlwZS52YWx1ZSA9IDA7XG4gICAgICAgIEhlYXRNYXBQb2ludC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgSGVhdE1hcFBvaW50KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwUG9pbnQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ4XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS54KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ5XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMTZcbiAgICAgICAgICAgICkudWludDY0KG1lc3NhZ2UueSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMjVcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueCkgJiYgIShtZXNzYWdlLnggJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnguaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ4OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnkpICYmICEobWVzc2FnZS55ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnkubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS55LmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwieTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLnggPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QueCkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcGFyc2VJbnQob2JqZWN0LngsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gb2JqZWN0Lng7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnggPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QueC5sb3cgPj4+IDAsIG9iamVjdC54LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLnkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QueSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcGFyc2VJbnQob2JqZWN0LnksIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gb2JqZWN0Lnk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QueS5sb3cgPj4+IDAsIG9iamVjdC55LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gTnVtYmVyKG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS54KSA6IG1lc3NhZ2UueDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UueCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS54LmxvdyA+Pj4gMCwgbWVzc2FnZS54LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbWVzc2FnZS54O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieVwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS55ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnkpIDogbWVzc2FnZS55O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS55KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLnkubG93ID4+PiAwLCBtZXNzYWdlLnkuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLnk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UudmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UudmFsdWUpIDogbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBIZWF0TWFwUG9pbnQ7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5IZWF0TWFwRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhlYXRNYXBEZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIZWF0TWFwRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIEhlYXRNYXBEZWYucHJvdG90eXBlLnBvaW50cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEhlYXRNYXBEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEhlYXRNYXBEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5lbmNvZGUobWVzc2FnZS5jaGFydERlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQuZW5jb2RlKG1lc3NhZ2UucG9pbnRzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcERlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBvaW50c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucG9pbnRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQudmVyaWZ5KG1lc3NhZ2UucG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInBvaW50cy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcERlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcERlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QuY2hhcnREZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuY2hhcnREZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5IZWF0TWFwRGVmLmNoYXJ0RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZnJvbU9iamVjdChvYmplY3QuY2hhcnREZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5wb2ludHMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uSGVhdE1hcERlZi5wb2ludHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5wb2ludHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYucG9pbnRzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50LmZyb21PYmplY3Qob2JqZWN0LnBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudG9PYmplY3QobWVzc2FnZS5jaGFydERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnBvaW50c1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludC50b09iamVjdChtZXNzYWdlLnBvaW50c1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkhlYXRNYXBEZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEhlYXRNYXBEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5CYXJEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQmFyRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEJhckRlZi5wcm90b3R5cGUuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICBCYXJEZWYucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuICAgICAgICBCYXJEZWYucHJvdG90eXBlLnN0cmFpZ2h0TGluZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBCYXJEZWYucHJvdG90eXBlLmJhcldpZHRoID0gbnVsbDtcbiAgICAgICAgQmFyRGVmLnByb3RvdHlwZS52ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFyRGVmLnByb3RvdHlwZSwgXCJfYmFyV2lkdGhcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiYmFyV2lkdGhcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgQmFyRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCYXJEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmVuY29kZShtZXNzYWdlLmNoYXJ0RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5BcnJheS5lbmNvZGUobWVzc2FnZS5kYXRhLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5lbmNvZGUobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmJhcldpZHRoICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJiYXJXaWR0aFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICApLnVpbnQzMihtZXNzYWdlLmJhcldpZHRoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmVydGljYWxcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UudmVydGljYWwpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJhckRlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmFpZ2h0TGluZXMgJiYgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5iYXJXaWR0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnRpY2FsID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudmVyaWZ5KG1lc3NhZ2UuY2hhcnREZWYpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydERlZi5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkFycmF5LnZlcmlmeShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyYWlnaHRMaW5lc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcykpXG4gICAgICAgICAgICAgIHJldHVybiBcInN0cmFpZ2h0TGluZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYudmVyaWZ5KG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJhaWdodExpbmVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJhcldpZHRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJhcldpZHRoXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl9iYXJXaWR0aCA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmJhcldpZHRoKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiYmFyV2lkdGg6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmVydGljYWwgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVydGljYWxcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52ZXJ0aWNhbCAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCYXJEZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkJhckRlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQmFyRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJhckRlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5CYXJEZWYuZGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkuZnJvbU9iamVjdChvYmplY3QuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Quc3RyYWlnaHRMaW5lcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJhckRlZi5zdHJhaWdodExpbmVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJhaWdodExpbmVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5CYXJEZWYuc3RyYWlnaHRMaW5lczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYuZnJvbU9iamVjdChvYmplY3Quc3RyYWlnaHRMaW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuYmFyV2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuYmFyV2lkdGggPSBvYmplY3QuYmFyV2lkdGggPj4+IDA7XG4gICAgICAgICAgaWYgKG9iamVjdC52ZXJ0aWNhbCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS52ZXJ0aWNhbCA9IEJvb2xlYW4ob2JqZWN0LnZlcnRpY2FsKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudG9PYmplY3QobWVzc2FnZS5jaGFydERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5BcnJheS50b09iamVjdChtZXNzYWdlLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgJiYgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi50b09iamVjdChtZXNzYWdlLnN0cmFpZ2h0TGluZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5iYXJXaWR0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXJXaWR0aFwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJhcldpZHRoID0gbWVzc2FnZS5iYXJXaWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9iYXJXaWR0aCA9IFwiYmFyV2lkdGhcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmVydGljYWwgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmVydGljYWxcIikpXG4gICAgICAgICAgICBvYmplY3QudmVydGljYWwgPSBtZXNzYWdlLnZlcnRpY2FsO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBCYXJEZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5CYXJEZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJhckRlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBIaXN0b2dyYW1EZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSGlzdG9ncmFtRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIEhpc3RvZ3JhbURlZi5wcm90b3R5cGUuZGF0YSA9IG51bGw7XG4gICAgICAgIEhpc3RvZ3JhbURlZi5wcm90b3R5cGUuc3RyYWlnaHRMaW5lcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEhpc3RvZ3JhbURlZi5wcm90b3R5cGUuYmluc0NvdW50ID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhpc3RvZ3JhbURlZi5wcm90b3R5cGUsIFwiX2JpbnNDb3VudFwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJiaW5zQ291bnRcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b2dyYW1EZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmVuY29kZShtZXNzYWdlLmNoYXJ0RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5BcnJheS5lbmNvZGUobWVzc2FnZS5kYXRhLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5lbmNvZGUobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmJpbnNDb3VudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYmluc0NvdW50XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICkudWludDMyKG1lc3NhZ2UuYmluc0NvdW50KTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLkFycmF5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJhaWdodExpbmVzICYmIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmluc0NvdW50ID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi52ZXJpZnkobWVzc2FnZS5jaGFydERlZik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0RGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkudmVyaWZ5KG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJhaWdodExpbmVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyYWlnaHRMaW5lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi52ZXJpZnkobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmFpZ2h0TGluZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmluc0NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJpbnNDb3VudFwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5fYmluc0NvdW50ID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmluc0NvdW50KSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiYmluc0NvdW50OiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYuZGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkuZnJvbU9iamVjdChvYmplY3QuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Quc3RyYWlnaHRMaW5lcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5zdHJhaWdodExpbmVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Quc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJhaWdodExpbmVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYuc3RyYWlnaHRMaW5lczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYuZnJvbU9iamVjdChvYmplY3Quc3RyYWlnaHRMaW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuYmluc0NvdW50ICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmJpbnNDb3VudCA9IG9iamVjdC5iaW5zQ291bnQgPj4+IDA7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gbnVsbDtcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi50b09iamVjdChtZXNzYWdlLmNoYXJ0RGVmLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpXG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLkFycmF5LnRvT2JqZWN0KG1lc3NhZ2UuZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLnRvT2JqZWN0KG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJpbnNDb3VudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiaW5zQ291bnRcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5iaW5zQ291bnQgPSBtZXNzYWdlLmJpbnNDb3VudDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9iaW5zQ291bnQgPSBcImJpbnNDb3VudFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBIaXN0b2dyYW1EZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJveFBsb3REYXRhUG9pbnQocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5wcm90b3R5cGUubG93ID0gMDtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5wcm90b3R5cGUucTEgPSAwO1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnByb3RvdHlwZS5tZWRpYW4gPSAwO1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnByb3RvdHlwZS5xMyA9IDA7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQucHJvdG90eXBlLmhpZ2ggPSAwO1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3hQbG90RGF0YVBvaW50KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubG93ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJsb3dcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICA5XG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLmxvdyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucTEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInExXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMTdcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UucTEpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm1lZGlhbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibWVkaWFuXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMjVcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubWVkaWFuKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5xMyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwicTNcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAzM1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5xMyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlnaCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaGlnaFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDQxXG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLmhpZ2gpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sb3cgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5xMSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm1lZGlhbiA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnEzID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGlnaCA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5sb3cgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibG93XCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UubG93ICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJsb3c6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5xMSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJxMVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnExICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJxMTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm1lZGlhbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtZWRpYW5cIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tZWRpYW4gIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcIm1lZGlhbjogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnEzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInEzXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UucTMgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInEzOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlnaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoaWdoXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaGlnaCAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaGlnaDogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5sb3cgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubG93ID0gTnVtYmVyKG9iamVjdC5sb3cpO1xuICAgICAgICAgIGlmIChvYmplY3QucTEgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UucTEgPSBOdW1iZXIob2JqZWN0LnExKTtcbiAgICAgICAgICBpZiAob2JqZWN0Lm1lZGlhbiAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5tZWRpYW4gPSBOdW1iZXIob2JqZWN0Lm1lZGlhbik7XG4gICAgICAgICAgaWYgKG9iamVjdC5xMyAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5xMyA9IE51bWJlcihvYmplY3QucTMpO1xuICAgICAgICAgIGlmIChvYmplY3QuaGlnaCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5oaWdoID0gTnVtYmVyKG9iamVjdC5oaWdoKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QubG93ID0gMDtcbiAgICAgICAgICAgIG9iamVjdC5xMSA9IDA7XG4gICAgICAgICAgICBvYmplY3QubWVkaWFuID0gMDtcbiAgICAgICAgICAgIG9iamVjdC5xMyA9IDA7XG4gICAgICAgICAgICBvYmplY3QuaGlnaCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmxvdyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsb3dcIikpXG4gICAgICAgICAgICBvYmplY3QubG93ID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmxvdykgPyBTdHJpbmcobWVzc2FnZS5sb3cpIDogbWVzc2FnZS5sb3c7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucTEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicTFcIikpXG4gICAgICAgICAgICBvYmplY3QucTEgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UucTEpID8gU3RyaW5nKG1lc3NhZ2UucTEpIDogbWVzc2FnZS5xMTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5tZWRpYW4gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWVkaWFuXCIpKVxuICAgICAgICAgICAgb2JqZWN0Lm1lZGlhbiA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5tZWRpYW4pID8gU3RyaW5nKG1lc3NhZ2UubWVkaWFuKSA6IG1lc3NhZ2UubWVkaWFuO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnEzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInEzXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnEzID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLnEzKSA/IFN0cmluZyhtZXNzYWdlLnEzKSA6IG1lc3NhZ2UucTM7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlnaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoaWdoXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmhpZ2ggPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuaGlnaCkgPyBTdHJpbmcobWVzc2FnZS5oaWdoKSA6IG1lc3NhZ2UuaGlnaDtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCb3hQbG90RGF0YVBvaW50O1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQm94UGxvdE91dGxpZXIocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQm94UGxvdE91dGxpZXIucHJvdG90eXBlLmNhdGVnb3J5SW5kZXggPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLnByb3RvdHlwZS52YWx1ZSA9IDA7XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3hQbG90T3V0bGllcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeUluZGV4ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjYXRlZ29yeUluZGV4XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS5jYXRlZ29yeUluZGV4KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAxN1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5SW5kZXggPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5SW5kZXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlJbmRleFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5jYXRlZ29yeUluZGV4KSAmJiAhKG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5jYXRlZ29yeUluZGV4LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuY2F0ZWdvcnlJbmRleC5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImNhdGVnb3J5SW5kZXg6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yeUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5jYXRlZ29yeUluZGV4ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmNhdGVnb3J5SW5kZXgpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmNhdGVnb3J5SW5kZXggPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCA9IHBhcnNlSW50KG9iamVjdC5jYXRlZ29yeUluZGV4LCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmNhdGVnb3J5SW5kZXggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCA9IG9iamVjdC5jYXRlZ29yeUluZGV4O1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5jYXRlZ29yeUluZGV4ID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5SW5kZXggPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmNhdGVnb3J5SW5kZXgubG93ID4+PiAwLCBvYmplY3QuY2F0ZWdvcnlJbmRleC5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IE51bWJlcihvYmplY3QudmFsdWUpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnlJbmRleCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5SW5kZXggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeUluZGV4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5SW5kZXhcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5SW5kZXggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5jYXRlZ29yeUluZGV4KSA6IG1lc3NhZ2UuY2F0ZWdvcnlJbmRleDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5SW5kZXggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5jYXRlZ29yeUluZGV4LmxvdyA+Pj4gMCwgbWVzc2FnZS5jYXRlZ29yeUluZGV4LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbWVzc2FnZS5jYXRlZ29yeUluZGV4O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLnZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLnZhbHVlKSA6IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5Cb3hQbG90T3V0bGllclwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQm94UGxvdE91dGxpZXI7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJveFBsb3REYXRhUG9pbnREZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMub3V0bGllcnMgPSBbXTtcbiAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5wcm90b3R5cGUub3V0bGllcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLnByb3RvdHlwZS5wb2ludHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3hQbG90RGF0YVBvaW50RGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0bGllcnMgIT0gbnVsbCAmJiBtZXNzYWdlLm91dGxpZXJzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5vdXRsaWVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIuZW5jb2RlKG1lc3NhZ2Uub3V0bGllcnNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludC5lbmNvZGUobWVzc2FnZS5wb2ludHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm91dGxpZXJzICYmIG1lc3NhZ2Uub3V0bGllcnMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0bGllcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm91dGxpZXJzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm91dGxpZXJzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm91dGxpZXJzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5vdXRsaWVycykpXG4gICAgICAgICAgICAgIHJldHVybiBcIm91dGxpZXJzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dGxpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyLnZlcmlmeShtZXNzYWdlLm91dGxpZXJzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm91dGxpZXJzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwb2ludHNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnBvaW50cykpXG4gICAgICAgICAgICAgIHJldHVybiBcInBvaW50czogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludC52ZXJpZnkobWVzc2FnZS5wb2ludHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5vdXRsaWVycykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5vdXRsaWVycykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLm91dGxpZXJzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uub3V0bGllcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm91dGxpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm91dGxpZXJzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLm91dGxpZXJzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uub3V0bGllcnNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90T3V0bGllci5mcm9tT2JqZWN0KG9iamVjdC5vdXRsaWVyc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QucG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnBvaW50cykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLnBvaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBvaW50c1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludERlZi5wb2ludHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50LmZyb21PYmplY3Qob2JqZWN0LnBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5vdXRsaWVycyA9IFtdO1xuICAgICAgICAgICAgb2JqZWN0LnBvaW50cyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5vdXRsaWVycyAmJiBtZXNzYWdlLm91dGxpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0Lm91dGxpZXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uub3V0bGllcnMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5vdXRsaWVyc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyLnRvT2JqZWN0KG1lc3NhZ2Uub3V0bGllcnNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QucG9pbnRzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludC50b09iamVjdChtZXNzYWdlLnBvaW50c1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJveFBsb3REYXRhUG9pbnREZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Cb3hQbG90RGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJveFBsb3REZWYocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQm94UGxvdERlZi5wcm90b3R5cGUuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICBCb3hQbG90RGVmLnByb3RvdHlwZS5kYXRhID0gbnVsbDtcbiAgICAgICAgQm94UGxvdERlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQm94UGxvdERlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmVuY29kZShtZXNzYWdlLmNoYXJ0RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLmVuY29kZShtZXNzYWdlLmRhdGEsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLnZlcmlmeShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJveFBsb3REZWYuY2hhcnREZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5mcm9tT2JqZWN0KG9iamVjdC5jaGFydERlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQm94UGxvdERlZi5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLmZyb21PYmplY3Qob2JqZWN0LmRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnRvT2JqZWN0KG1lc3NhZ2UuY2hhcnREZWYsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludERlZi50b09iamVjdChtZXNzYWdlLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJveFBsb3REZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJveFBsb3REZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5YUmFuZ2VQb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBYUmFuZ2VQb2ludChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBYUmFuZ2VQb2ludC5wcm90b3R5cGUueCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG4gICAgICAgIFhSYW5nZVBvaW50LnByb3RvdHlwZS54MiA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG4gICAgICAgIFhSYW5nZVBvaW50LnByb3RvdHlwZS55ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICAgICAgICBYUmFuZ2VQb2ludC5wcm90b3R5cGUuaXNMb25nID0gZmFsc2U7XG4gICAgICAgIFhSYW5nZVBvaW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYUmFuZ2VQb2ludChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ4XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLngpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLngyICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ4MlwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDE2XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UueDIpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAyNFxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS55KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pc0xvbmcgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImlzTG9uZ1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICApLmJvb2wobWVzc2FnZS5pc0xvbmcpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54MiA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlzTG9uZyA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VQb2ludC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueCkgJiYgIShtZXNzYWdlLnggJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnguaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ4OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueDIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieDJcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueDIpICYmICEobWVzc2FnZS54MiAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54Mi5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLngyLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwieDI6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueSkgJiYgIShtZXNzYWdlLnkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnkuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaXNMb25nICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlzTG9uZ1wiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmlzTG9uZyAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcImlzTG9uZzogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludCgpO1xuICAgICAgICAgIGlmIChvYmplY3QueCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC54KSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcGFyc2VJbnQob2JqZWN0LngsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gb2JqZWN0Lng7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnggPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QueC5sb3cgPj4+IDAsIG9iamVjdC54LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueDIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLngyID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LngyKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueDIgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueDIgPSBwYXJzZUludChvYmplY3QueDIsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueDIgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueDIgPSBvYmplY3QueDI7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LngyID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLngyID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC54Mi5sb3cgPj4+IDAsIG9iamVjdC54Mi5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLnkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QueSkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcGFyc2VJbnQob2JqZWN0LnksIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gb2JqZWN0Lnk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QueS5sb3cgPj4+IDAsIG9iamVjdC55LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmlzTG9uZyAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5pc0xvbmcgPSBCb29sZWFuKG9iamVjdC5pc0xvbmcpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VQb2ludC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC54ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgIG9iamVjdC54MiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LngyID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgb2JqZWN0LmlzTG9uZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS54ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS54KSA6IG1lc3NhZ2UueDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UueCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS54LmxvdyA+Pj4gMCwgbWVzc2FnZS54LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLng7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueDIgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieDJcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UueDIgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC54MiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLngyKSA6IG1lc3NhZ2UueDI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC54MiA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS54MikgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS54Mi5sb3cgPj4+IDAsIG1lc3NhZ2UueDIuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UueDI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5XCIpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UueSkgOiBtZXNzYWdlLnk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UueS5sb3cgPj4+IDAsIG1lc3NhZ2UueS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UueTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pc0xvbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXNMb25nXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmlzTG9uZyA9IG1lc3NhZ2UuaXNMb25nO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uWFJhbmdlUG9pbnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFhSYW5nZVBvaW50O1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uWFJhbmdlRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhSYW5nZURlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFhSYW5nZURlZi5wcm90b3R5cGUuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICBYUmFuZ2VEZWYucHJvdG90eXBlLmNhdGVnb3JpZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBYUmFuZ2VEZWYucHJvdG90eXBlLnBvaW50cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFhSYW5nZURlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgWFJhbmdlRGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5lbmNvZGUobWVzc2FnZS5jaGFydERlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yaWVzICE9IG51bGwgJiYgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5jYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludC5lbmNvZGUobWVzc2FnZS5wb2ludHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNhdGVnb3JpZXMgJiYgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucG9pbnRzICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlUG9pbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi52ZXJpZnkobWVzc2FnZS5jaGFydERlZik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0RGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcmllc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY2F0ZWdvcmllcykpXG4gICAgICAgICAgICAgIHJldHVybiBcImNhdGVnb3JpZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY2F0ZWdvcmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmNhdGVnb3JpZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNhdGVnb3JpZXM6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwb2ludHNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnBvaW50cykpXG4gICAgICAgICAgICAgIHJldHVybiBcInBvaW50czogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlUG9pbnQudmVyaWZ5KG1lc3NhZ2UucG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInBvaW50cy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZURlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QuY2hhcnREZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuY2hhcnREZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5YUmFuZ2VEZWYuY2hhcnREZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5mcm9tT2JqZWN0KG9iamVjdC5jaGFydERlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuY2F0ZWdvcmllcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5jYXRlZ29yaWVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlhSYW5nZURlZi5jYXRlZ29yaWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2F0ZWdvcmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzW2ldID0gU3RyaW5nKG9iamVjdC5jYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5wb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucG9pbnRzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlhSYW5nZURlZi5wb2ludHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5wb2ludHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlhSYW5nZURlZi5wb2ludHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludC5mcm9tT2JqZWN0KG9iamVjdC5wb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gbnVsbDtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnRvT2JqZWN0KG1lc3NhZ2UuY2hhcnREZWYsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgJiYgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllc1tqXSA9IG1lc3NhZ2UuY2F0ZWdvcmllc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnBvaW50c1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50LnRvT2JqZWN0KG1lc3NhZ2UucG9pbnRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZURlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlhSYW5nZURlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWFJhbmdlRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uUGllRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBQaWVEYXRhKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFBpZURhdGEucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBQaWVEYXRhLnByb3RvdHlwZS55ID0gMDtcbiAgICAgICAgUGllRGF0YS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUGllRGF0YShwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ5XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMTdcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UueSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGEuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGEudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5XCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UueSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwieTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgIGlmIChvYmplY3QueSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS55ID0gTnVtYmVyKG9iamVjdC55KTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QueSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieVwiKSlcbiAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLnkpID8gU3RyaW5nKG1lc3NhZ2UueSkgOiBtZXNzYWdlLnk7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uUGllRGF0YVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGllRGF0YTtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlBpZURhdGFEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUGllRGF0YURlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFBpZURhdGFEZWYucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBQaWVEYXRhRGVmLnByb3RvdHlwZS5wb2ludHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBQaWVEYXRhRGVmLnByb3RvdHlwZS5zaXplID0gXCJcIjtcbiAgICAgICAgUGllRGF0YURlZi5wcm90b3R5cGUuaW5uZXJTaXplID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBpZURhdGFEZWYucHJvdG90eXBlLCBcIl9pbm5lclNpemVcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiaW5uZXJTaXplXCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIFBpZURhdGFEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFBpZURhdGFEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGFEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJuYW1lXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YS5lbmNvZGUobWVzc2FnZS5wb2ludHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc2l6ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic2l6ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnNpemUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmlubmVyU2l6ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaW5uZXJTaXplXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMzRcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuaW5uZXJTaXplKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGFEZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBvaW50cyAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50cy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zaXplID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJTaXplID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGFEZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicG9pbnRzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5wb2ludHMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJwb2ludHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEudmVyaWZ5KG1lc3NhZ2UucG9pbnRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInBvaW50cy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5zaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNpemVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zaXplKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic2l6ZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmlubmVyU2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbm5lclNpemVcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX2lubmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuaW5uZXJTaXplKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaW5uZXJTaXplOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGFEZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGFEZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGFEZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5wb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucG9pbnRzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlBpZURhdGFEZWYucG9pbnRzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucG9pbnRzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5QaWVEYXRhRGVmLnBvaW50czogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50c1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEuZnJvbU9iamVjdChvYmplY3QucG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnNpemUgPSBTdHJpbmcob2JqZWN0LnNpemUpO1xuICAgICAgICAgIGlmIChvYmplY3QuaW5uZXJTaXplICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmlubmVyU2l6ZSA9IFN0cmluZyhvYmplY3QuaW5uZXJTaXplKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnBvaW50cyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3Quc2l6ZSA9IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5wb2ludHNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhLnRvT2JqZWN0KG1lc3NhZ2UucG9pbnRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzaXplXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnNpemUgPSBtZXNzYWdlLnNpemU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW5uZXJTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlubmVyU2l6ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmlubmVyU2l6ZSA9IG1lc3NhZ2UuaW5uZXJTaXplO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX2lubmVyU2l6ZSA9IFwiaW5uZXJTaXplXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGFEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlBpZURhdGFEZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBpZURhdGFEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5QaWVEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gUGllRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFBpZURlZi5wcm90b3R5cGUuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICBQaWVEZWYucHJvdG90eXBlLmRhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBQaWVEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFBpZURlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZW5jb2RlKG1lc3NhZ2UuY2hhcnREZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZi5lbmNvZGUobWVzc2FnZS5kYXRhW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlBpZURlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5kYXRhKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YTogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGFEZWYudmVyaWZ5KG1lc3NhZ2UuZGF0YVtpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlBpZURlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlBpZURlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRhdGEpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uUGllRGVmLmRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGFbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlBpZURlZi5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YVtpXSA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGFEZWYuZnJvbU9iamVjdChvYmplY3QuZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudG9PYmplY3QobWVzc2FnZS5jaGFydERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAmJiBtZXNzYWdlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRhW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZi50b09iamVjdChtZXNzYWdlLmRhdGFbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBQaWVEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uUGllRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQaWVEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5DaGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGFydChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDaGFydC5wcm90b3R5cGUubGluZXNEZWYgPSBudWxsO1xuICAgICAgICBDaGFydC5wcm90b3R5cGUuaGVhdE1hcERlZiA9IG51bGw7XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS5iYXJEZWYgPSBudWxsO1xuICAgICAgICBDaGFydC5wcm90b3R5cGUuaGlzdG9ncmFtRGVmID0gbnVsbDtcbiAgICAgICAgQ2hhcnQucHJvdG90eXBlLmJveFBsb3REZWYgPSBudWxsO1xuICAgICAgICBDaGFydC5wcm90b3R5cGUueFJhbmdlRGVmID0gbnVsbDtcbiAgICAgICAgQ2hhcnQucHJvdG90eXBlLnBpZURlZiA9IG51bGw7XG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDaGFydC5wcm90b3R5cGUsIFwiY2hhcnRUeXBlXCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImxpbmVzRGVmXCIsIFwiaGVhdE1hcERlZlwiLCBcImJhckRlZlwiLCBcImhpc3RvZ3JhbURlZlwiLCBcImJveFBsb3REZWZcIiwgXCJ4UmFuZ2VEZWZcIiwgXCJwaWVEZWZcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgQ2hhcnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENoYXJ0KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVzRGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJsaW5lc0RlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmLmVuY29kZShtZXNzYWdlLmxpbmVzRGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmhlYXRNYXBEZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImhlYXRNYXBEZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmLmVuY29kZShtZXNzYWdlLmhlYXRNYXBEZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmFyRGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJiYXJEZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5CYXJEZWYuZW5jb2RlKG1lc3NhZ2UuYmFyRGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmhpc3RvZ3JhbURlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaGlzdG9ncmFtRGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLmVuY29kZShtZXNzYWdlLmhpc3RvZ3JhbURlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMzRcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5ib3hQbG90RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJib3hQbG90RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERlZi5lbmNvZGUobWVzc2FnZS5ib3hQbG90RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICA0MlxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnhSYW5nZURlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwieFJhbmdlRGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLmVuY29kZShtZXNzYWdlLnhSYW5nZURlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5waWVEZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInBpZURlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlBpZURlZi5lbmNvZGUobWVzc2FnZS5waWVEZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDcsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDU4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0KCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVzRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYXRNYXBEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5iYXJEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5CYXJEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhpc3RvZ3JhbURlZiA9ICRyb290LmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm94UGxvdERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnhSYW5nZURlZiA9ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZURlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucGllRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVzRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpbmVzRGVmXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmLnZlcmlmeShtZXNzYWdlLmxpbmVzRGVmKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImxpbmVzRGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmhlYXRNYXBEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGVhdE1hcERlZlwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuY2hhcnRUeXBlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydFR5cGU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jaGFydFR5cGUgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmLnZlcmlmeShtZXNzYWdlLmhlYXRNYXBEZWYpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaGVhdE1hcERlZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5iYXJEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmFyRGVmXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5jaGFydFR5cGUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0VHlwZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJhckRlZi52ZXJpZnkobWVzc2FnZS5iYXJEZWYpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYmFyRGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmhpc3RvZ3JhbURlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoaXN0b2dyYW1EZWZcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRUeXBlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2hhcnRUeXBlID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLnZlcmlmeShtZXNzYWdlLmhpc3RvZ3JhbURlZik7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJoaXN0b2dyYW1EZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm94UGxvdERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib3hQbG90RGVmXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5jaGFydFR5cGUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0VHlwZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYudmVyaWZ5KG1lc3NhZ2UuYm94UGxvdERlZik7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJib3hQbG90RGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnhSYW5nZURlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4UmFuZ2VEZWZcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRUeXBlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2hhcnRUeXBlID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLnZlcmlmeShtZXNzYWdlLnhSYW5nZURlZik7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ4UmFuZ2VEZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGllRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBpZURlZlwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuY2hhcnRUeXBlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydFR5cGU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jaGFydFR5cGUgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5QaWVEZWYudmVyaWZ5KG1lc3NhZ2UucGllRGVmKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInBpZURlZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DaGFydCgpO1xuICAgICAgICAgIGlmIChvYmplY3QubGluZXNEZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubGluZXNEZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydC5saW5lc0RlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5saW5lc0RlZiA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmLmZyb21PYmplY3Qob2JqZWN0LmxpbmVzRGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5oZWF0TWFwRGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmhlYXRNYXBEZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydC5oZWF0TWFwRGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmhlYXRNYXBEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmLmZyb21PYmplY3Qob2JqZWN0LmhlYXRNYXBEZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmJhckRlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5iYXJEZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydC5iYXJEZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuYmFyRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQmFyRGVmLmZyb21PYmplY3Qob2JqZWN0LmJhckRlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuaGlzdG9ncmFtRGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lmhpc3RvZ3JhbURlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0Lmhpc3RvZ3JhbURlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5oaXN0b2dyYW1EZWYgPSAkcm9vdC5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYuZnJvbU9iamVjdChvYmplY3QuaGlzdG9ncmFtRGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5ib3hQbG90RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmJveFBsb3REZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydC5ib3hQbG90RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmJveFBsb3REZWYgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmLmZyb21PYmplY3Qob2JqZWN0LmJveFBsb3REZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnhSYW5nZURlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC54UmFuZ2VEZWYgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydC54UmFuZ2VEZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UueFJhbmdlRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLmZyb21PYmplY3Qob2JqZWN0LnhSYW5nZURlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QucGllRGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBpZURlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LnBpZURlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5waWVEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5QaWVEZWYuZnJvbU9iamVjdChvYmplY3QucGllRGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZXNEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGluZXNEZWZcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5saW5lc0RlZiA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmLnRvT2JqZWN0KG1lc3NhZ2UubGluZXNEZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuY2hhcnRUeXBlID0gXCJsaW5lc0RlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5oZWF0TWFwRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhlYXRNYXBEZWZcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5oZWF0TWFwRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcERlZi50b09iamVjdChtZXNzYWdlLmhlYXRNYXBEZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuY2hhcnRUeXBlID0gXCJoZWF0TWFwRGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJhckRlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXJEZWZcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5iYXJEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5CYXJEZWYudG9PYmplY3QobWVzc2FnZS5iYXJEZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuY2hhcnRUeXBlID0gXCJiYXJEZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlzdG9ncmFtRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhpc3RvZ3JhbURlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0Lmhpc3RvZ3JhbURlZiA9ICRyb290LmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi50b09iamVjdChtZXNzYWdlLmhpc3RvZ3JhbURlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcImhpc3RvZ3JhbURlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ib3hQbG90RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJveFBsb3REZWZcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5ib3hQbG90RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERlZi50b09iamVjdChtZXNzYWdlLmJveFBsb3REZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuY2hhcnRUeXBlID0gXCJib3hQbG90RGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnhSYW5nZURlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4UmFuZ2VEZWZcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC54UmFuZ2VEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYudG9PYmplY3QobWVzc2FnZS54UmFuZ2VEZWYsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuY2hhcnRUeXBlID0gXCJ4UmFuZ2VEZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGllRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBpZURlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnBpZURlZiA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURlZi50b09iamVjdChtZXNzYWdlLnBpZURlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcInBpZURlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkNoYXJ0XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDaGFydDtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkVwb2NoRm9saW9EYXNoYm9hcmRXaWRnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIldpZGdldFVuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIldpZGdldENhcmRcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiV2lkZ2V0TGluZXNcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiV2lkZ2V0QmFyXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIldpZGdldERhdGFUYWJsZVwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJXaWRnZXRYUmFuZ2VcIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiV2lkZ2V0SGlzdG9ncmFtXCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIldpZGdldFBpZVwiXSA9IDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJXaWRnZXRIZWF0TWFwXCJdID0gODtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIldpZGdldEJveFBsb3RcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIldpZGdldEFyZWFcIl0gPSAxMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTFdID0gXCJXaWRnZXRDb2x1bW5cIl0gPSAxMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkVwb2NoRm9saW9UeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJUeXBlVW5zcGVjaWZpZWRcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiVHlwZVN0cmluZ1wiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJUeXBlSW50ZWdlclwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJUeXBlRGVjaW1hbFwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJUeXBlUGVyY2VudFwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJUeXBlQm9vbGVhblwiXSA9IDU7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJUeXBlRGF0ZVRpbWVcIl0gPSA2O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiVHlwZURhdGVcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiVHlwZURheUR1cmF0aW9uXCJdID0gODtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIlR5cGVNb25ldGFyeVwiXSA9IDk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwXSA9IFwiVHlwZUR1cmF0aW9uXCJdID0gMTA7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5TY2FsYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gU2NhbGFyKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmludGVnZXJWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuZGVjaW1hbFZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5wZXJjZW50VmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmJvb2xlYW5WYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUudGltZXN0YW1wTXMgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmRhdGVWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuZGF5RHVyYXRpb24gPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLm1vbmV0YXJ5VmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmR1cmF0aW9uTXMgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLm51bGxWYWx1ZSA9IG51bGw7XG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTY2FsYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcInN0cmluZ1ZhbHVlXCIsIFwiaW50ZWdlclZhbHVlXCIsIFwiZGVjaW1hbFZhbHVlXCIsIFwicGVyY2VudFZhbHVlXCIsIFwiYm9vbGVhblZhbHVlXCIsIFwidGltZXN0YW1wTXNcIiwgXCJkYXRlVmFsdWVcIiwgXCJkYXlEdXJhdGlvblwiLCBcIm1vbmV0YXJ5VmFsdWVcIiwgXCJkdXJhdGlvbk1zXCIsIFwibnVsbFZhbHVlXCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIFNjYWxhci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RyaW5nVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5zdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW50ZWdlclZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJpbnRlZ2VyVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAxNlxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLmludGVnZXJWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGVjaW1hbFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkZWNpbWFsVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAyNVxuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5kZWNpbWFsVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnBlcmNlbnRWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwicGVyY2VudFZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMzNcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UucGVyY2VudFZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5ib29sZWFuVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJvb2xlYW5WYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDQwXG4gICAgICAgICAgICApLmJvb2wobWVzc2FnZS5ib29sZWFuVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcE1zICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0aW1lc3RhbXBNc1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDYsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDQ4XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UudGltZXN0YW1wTXMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGVWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF0ZVZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgNTZcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS5kYXRlVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRheUR1cmF0aW9uICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXlEdXJhdGlvblwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDgsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDY0XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UuZGF5RHVyYXRpb24pO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm1vbmV0YXJ5VmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA5LCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICA3M1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5tb25ldGFyeVZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kdXJhdGlvbk1zICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkdXJhdGlvbk1zXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMTAsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDgwXG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UuZHVyYXRpb25Ncyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJudWxsVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgODhcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS5udWxsVmFsdWUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhcigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmludGVnZXJWYWx1ZSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVjaW1hbFZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucGVyY2VudFZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9vbGVhblZhbHVlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRlVmFsdWUgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDg6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRheUR1cmF0aW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5tb25ldGFyeVZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDExOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nVmFsdWUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdWYWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmludGVnZXJWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnRlZ2VyVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50ZWdlclZhbHVlKSAmJiAhKG1lc3NhZ2UuaW50ZWdlclZhbHVlICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludGVnZXJWYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludGVnZXJWYWx1ZS5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImludGVnZXJWYWx1ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRlY2ltYWxWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZWNpbWFsVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kZWNpbWFsVmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcImRlY2ltYWxWYWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBlcmNlbnRWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwZXJjZW50VmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5wZXJjZW50VmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInBlcmNlbnRWYWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xlYW5WYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sZWFuVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ib29sZWFuVmFsdWUgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJib29sZWFuVmFsdWU6IGJvb2xlYW4gZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wTXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGltZXN0YW1wTXNcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudGltZXN0YW1wTXMpICYmICEobWVzc2FnZS50aW1lc3RhbXBNcyAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50aW1lc3RhbXBNcy5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRpbWVzdGFtcE1zLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGltZXN0YW1wTXM6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRlVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0ZVZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRhdGVWYWx1ZSkgJiYgIShtZXNzYWdlLmRhdGVWYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXRlVmFsdWUubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXRlVmFsdWUuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRlVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXlEdXJhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXlEdXJhdGlvblwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXlEdXJhdGlvbikpXG4gICAgICAgICAgICAgIHJldHVybiBcImRheUR1cmF0aW9uOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9uZXRhcnlWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcIm1vbmV0YXJ5VmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kdXJhdGlvbk1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImR1cmF0aW9uTXNcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZHVyYXRpb25NcykgJiYgIShtZXNzYWdlLmR1cmF0aW9uTXMgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZHVyYXRpb25Ncy5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmR1cmF0aW9uTXMuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkdXJhdGlvbk1zOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLm51bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxWYWx1ZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlNjYWxhcilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5zdHJpbmdWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IFN0cmluZyhvYmplY3Quc3RyaW5nVmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QuaW50ZWdlclZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuaW50ZWdlclZhbHVlKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50ZWdlclZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmludGVnZXJWYWx1ZSA9IHBhcnNlSW50KG9iamVjdC5pbnRlZ2VyVmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50ZWdlclZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmludGVnZXJWYWx1ZSA9IG9iamVjdC5pbnRlZ2VyVmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludGVnZXJWYWx1ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmludGVnZXJWYWx1ZS5sb3cgPj4+IDAsIG9iamVjdC5pbnRlZ2VyVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kZWNpbWFsVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuZGVjaW1hbFZhbHVlID0gTnVtYmVyKG9iamVjdC5kZWNpbWFsVmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QucGVyY2VudFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnBlcmNlbnRWYWx1ZSA9IE51bWJlcihvYmplY3QucGVyY2VudFZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmJvb2xlYW5WYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5ib29sZWFuVmFsdWUgPSBCb29sZWFuKG9iamVjdC5ib29sZWFuVmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QudGltZXN0YW1wTXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLnRpbWVzdGFtcE1zID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LnRpbWVzdGFtcE1zKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudGltZXN0YW1wTXMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTXMgPSBwYXJzZUludChvYmplY3QudGltZXN0YW1wTXMsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudGltZXN0YW1wTXMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTXMgPSBvYmplY3QudGltZXN0YW1wTXM7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnRpbWVzdGFtcE1zID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC50aW1lc3RhbXBNcy5sb3cgPj4+IDAsIG9iamVjdC50aW1lc3RhbXBNcy5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZGF0ZVZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmRhdGVWYWx1ZSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGVWYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXRlVmFsdWUgPSBwYXJzZUludChvYmplY3QuZGF0ZVZhbHVlLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGVWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXRlVmFsdWUgPSBvYmplY3QuZGF0ZVZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kYXRlVmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kYXRlVmFsdWUubG93ID4+PiAwLCBvYmplY3QuZGF0ZVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZGF5RHVyYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF5RHVyYXRpb24gPSBvYmplY3QuZGF5RHVyYXRpb24gfCAwO1xuICAgICAgICAgIGlmIChvYmplY3QubW9uZXRhcnlWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5tb25ldGFyeVZhbHVlID0gTnVtYmVyKG9iamVjdC5tb25ldGFyeVZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmR1cmF0aW9uTXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmR1cmF0aW9uTXMgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZHVyYXRpb25NcykpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmR1cmF0aW9uTXMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZHVyYXRpb25NcyA9IHBhcnNlSW50KG9iamVjdC5kdXJhdGlvbk1zLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmR1cmF0aW9uTXMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZHVyYXRpb25NcyA9IG9iamVjdC5kdXJhdGlvbk1zO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kdXJhdGlvbk1zID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmR1cmF0aW9uTXMubG93ID4+PiAwLCBvYmplY3QuZHVyYXRpb25Ncy5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5udWxsVmFsdWUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm51bGxWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gb2JqZWN0Lm51bGxWYWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJOVUxMX1ZBTFVFXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnN0cmluZ1ZhbHVlID0gbWVzc2FnZS5zdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJzdHJpbmdWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pbnRlZ2VyVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50ZWdlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaW50ZWdlclZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QuaW50ZWdlclZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuaW50ZWdlclZhbHVlKSA6IG1lc3NhZ2UuaW50ZWdlclZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuaW50ZWdlclZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmludGVnZXJWYWx1ZSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5pbnRlZ2VyVmFsdWUubG93ID4+PiAwLCBtZXNzYWdlLmludGVnZXJWYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5pbnRlZ2VyVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiaW50ZWdlclZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRlY2ltYWxWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkZWNpbWFsVmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5kZWNpbWFsVmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UuZGVjaW1hbFZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLmRlY2ltYWxWYWx1ZSkgOiBtZXNzYWdlLmRlY2ltYWxWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkZWNpbWFsVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGVyY2VudFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBlcmNlbnRWYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnBlcmNlbnRWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5wZXJjZW50VmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UucGVyY2VudFZhbHVlKSA6IG1lc3NhZ2UucGVyY2VudFZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInBlcmNlbnRWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ib29sZWFuVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbGVhblZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuYm9vbGVhblZhbHVlID0gbWVzc2FnZS5ib29sZWFuVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiYm9vbGVhblZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcE1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpbWVzdGFtcE1zXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudGltZXN0YW1wTXMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXBNcyA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLnRpbWVzdGFtcE1zKSA6IG1lc3NhZ2UudGltZXN0YW1wTXM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC50aW1lc3RhbXBNcyA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS50aW1lc3RhbXBNcykgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS50aW1lc3RhbXBNcy5sb3cgPj4+IDAsIG1lc3NhZ2UudGltZXN0YW1wTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UudGltZXN0YW1wTXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwidGltZXN0YW1wTXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0ZVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGVWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRhdGVWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmRhdGVWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmRhdGVWYWx1ZSkgOiBtZXNzYWdlLmRhdGVWYWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmRhdGVWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kYXRlVmFsdWUpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZGF0ZVZhbHVlLmxvdyA+Pj4gMCwgbWVzc2FnZS5kYXRlVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZGF0ZVZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImRhdGVWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXlEdXJhdGlvbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXlEdXJhdGlvblwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmRheUR1cmF0aW9uID0gbWVzc2FnZS5kYXlEdXJhdGlvbjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkYXlEdXJhdGlvblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5tb25ldGFyeVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1vbmV0YXJ5VmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5tb25ldGFyeVZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLm1vbmV0YXJ5VmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSkgOiBtZXNzYWdlLm1vbmV0YXJ5VmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwibW9uZXRhcnlWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kdXJhdGlvbk1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImR1cmF0aW9uTXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kdXJhdGlvbk1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QuZHVyYXRpb25NcyA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmR1cmF0aW9uTXMpIDogbWVzc2FnZS5kdXJhdGlvbk1zO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuZHVyYXRpb25NcyA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5kdXJhdGlvbk1zKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmR1cmF0aW9uTXMubG93ID4+PiAwLCBtZXNzYWdlLmR1cmF0aW9uTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuZHVyYXRpb25NcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkdXJhdGlvbk1zXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJudWxsVmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5udWxsVmFsdWUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS5udWxsVmFsdWUgOiAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA6IG1lc3NhZ2UubnVsbFZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIm51bGxWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uU2NhbGFyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTY2FsYXI7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBBcnJheTIocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheTIucHJvdG90eXBlLnZhbHVlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEFycmF5Mi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkyKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZW5jb2RlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkFycmF5KCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheTIuaXNBcnJheShtZXNzYWdlLnZhbHVlcykpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnZlcmlmeShtZXNzYWdlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkFycmF5KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkyLmlzQXJyYXkob2JqZWN0LnZhbHVlcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5BcnJheS52YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkFycmF5LnZhbHVlczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QudmFsdWVzID0gW107XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci50b09iamVjdChtZXNzYWdlLnZhbHVlc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5BcnJheVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQXJyYXkyO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQXhpc1R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkF4aXNVbnNwZWNpZmllZFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJBeGlzTGluZWFyXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIkF4aXNMb2dhcml0aG1pY1wiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJBeGlzRGF0ZVRpbWVcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiQXhpc0NhdGVnb3J5XCJdID0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkRhc2hTdHlsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiRGFzaFN0eWxlVW5zcGVjaWZpZWRcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiU29saWRcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiU2hvcnREYXNoXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIlNob3J0RG90XCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlNob3J0RGFzaERvdFwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJTaG9ydERhc2hEb3REb3RcIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiRG90XCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIkRhc2hcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiTG9uZ0Rhc2hcIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiRGFzaERvdFwiXSA9IDk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwXSA9IFwiTG9uZ0Rhc2hEb3RcIl0gPSAxMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTFdID0gXCJMb25nRGFzaERvdERvdFwiXSA9IDExO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGVwb2NoX3Byb3RvO1xuICAgIH0oKTtcbiAgICAkcm9vdC5nb29nbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnb29nbGUgPSB7fTtcbiAgICAgIGdvb2dsZS5wcm90b2J1ZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdG9idWYgPSB7fTtcbiAgICAgICAgcHJvdG9idWYuU3RydWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gU3RydWN0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0ge307XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFN0cnVjdC5wcm90b3R5cGUuZmllbGRzID0gJHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgICAgICAgU3RydWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZmllbGRzXCIpKVxuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5mb3JrKCkudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5zdHJpbmcoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmVuY29kZShtZXNzYWdlLmZpZWxkc1trZXlzW2ldXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QoKSwga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmllbGRzID09PSAkdXRpbC5lbXB0eU9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgIGtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZzIgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnMiA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZzIgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmaWVsZHNcIikpIHtcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc09iamVjdChtZXNzYWdlLmZpZWxkcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmllbGRzOiBvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudmVyaWZ5KG1lc3NhZ2UuZmllbGRzW2tleVtpXV0pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcImZpZWxkcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0KVxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZmllbGRzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuU3RydWN0LmZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0LmZpZWxkcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZpZWxkc1trZXlzW2ldXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuU3RydWN0LmZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmllbGRzW2tleXNbaV1dID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmZyb21PYmplY3Qob2JqZWN0LmZpZWxkc1trZXlzW2ldXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vYmplY3RzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgIG9iamVjdC5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlzMjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAmJiAoa2V5czIgPSBPYmplY3Qua2V5cyhtZXNzYWdlLmZpZWxkcykpLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvYmplY3QuZmllbGRzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5czIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgb2JqZWN0LmZpZWxkc1trZXlzMltqXV0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudG9PYmplY3QobWVzc2FnZS5maWVsZHNba2V5czJbal1dLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuU3RydWN0XCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gU3RydWN0O1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLlZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gVmFsdWUocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubnVsbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLmJvb2xWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLnN0cnVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubGlzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWx1ZS5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcIm51bGxWYWx1ZVwiLCBcIm51bWJlclZhbHVlXCIsIFwic3RyaW5nVmFsdWVcIiwgXCJib29sVmFsdWVcIiwgXCJzdHJ1Y3RWYWx1ZVwiLCBcImxpc3RWYWx1ZVwiXSksXG4gICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBWYWx1ZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJudWxsVmFsdWVcIikpXG4gICAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS5udWxsVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVtYmVyVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm51bWJlclZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgICAgMTdcbiAgICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5udW1iZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RyaW5nVmFsdWVcIikpXG4gICAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYm9vbFZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UuYm9vbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cnVjdFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzdHJ1Y3RWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5lbmNvZGUobWVzc2FnZS5zdHJ1Y3RWYWx1ZSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDQyXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibGlzdFZhbHVlXCIpKVxuICAgICAgICAgICAgICAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmVuY29kZShtZXNzYWdlLmxpc3RWYWx1ZSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDUwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bWJlclZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9vbFZhbHVlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RydWN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpc3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5udWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFZhbHVlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bWJlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmtpbmQgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwia2luZDogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5udW1iZXJWYWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJWYWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nVmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1ZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmJvb2xWYWx1ZSAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYm9vbFZhbHVlOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJ1Y3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJ1Y3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC52ZXJpZnkobWVzc2FnZS5zdHJ1Y3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RydWN0VmFsdWUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGlzdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpc3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52ZXJpZnkobWVzc2FnZS5saXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcImxpc3RWYWx1ZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubnVsbFZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IG9iamVjdC5udWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJOVUxMX1ZBTFVFXCI6XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm51bWJlclZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UubnVtYmVyVmFsdWUgPSBOdW1iZXIob2JqZWN0Lm51bWJlclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5nVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IFN0cmluZyhvYmplY3Quc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5ib29sVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgbWVzc2FnZS5ib29sVmFsdWUgPSBCb29sZWFuKG9iamVjdC5ib29sVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5zdHJ1Y3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cnVjdFZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuVmFsdWUuc3RydWN0VmFsdWU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5zdHJ1Y3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZnJvbU9iamVjdChvYmplY3Quc3RydWN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5saXN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5saXN0VmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5saXN0VmFsdWU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5saXN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmZyb21PYmplY3Qob2JqZWN0Lmxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5udWxsVmFsdWUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS5udWxsVmFsdWUgOiAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA6IG1lc3NhZ2UubnVsbFZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcIm51bGxWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVtYmVyVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVtYmVyVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0Lm51bWJlclZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLm51bWJlclZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLm51bWJlclZhbHVlKSA6IG1lc3NhZ2UubnVtYmVyVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwibnVtYmVyVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ1ZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ1ZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdWYWx1ZSA9IG1lc3NhZ2Uuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwic3RyaW5nVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmJvb2xWYWx1ZSA9IG1lc3NhZ2UuYm9vbFZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcImJvb2xWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RydWN0VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RydWN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LnN0cnVjdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC50b09iamVjdChtZXNzYWdlLnN0cnVjdFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJzdHJ1Y3RWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGlzdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpc3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3QubGlzdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS50b09iamVjdChtZXNzYWdlLmxpc3RWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwibGlzdFZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2dvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFZhbHVlO1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLk51bGxWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIk5VTExfVkFMVUVcIl0gPSAwO1xuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcHJvdG9idWYuTGlzdFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gTGlzdFZhbHVlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudmFsdWVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICBMaXN0VmFsdWUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdFZhbHVlKHByb3BlcnRpZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5lbmNvZGUobWVzc2FnZS52YWx1ZXNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaCgkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpIHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudmFsdWVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudmVyaWZ5KG1lc3NhZ2UudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudmFsdWVzKSB7XG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52YWx1ZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlc1tpXSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZXNbal0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudG9PYmplY3QobWVzc2FnZS52YWx1ZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2dvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWVcIjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBMaXN0VmFsdWU7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHByb3RvYnVmO1xuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGdvb2dsZTtcbiAgICB9KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gJHJvb3Q7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVxdWlyZV9jaGFydF9kZWYoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/chart_def.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/common.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@epochlab/epoch-protos/dist/common.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\n\n// node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\") (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n      else (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n      if (typeof Float64Array !== \"undefined\") (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n      else (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length; )\n          buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n      }\n      return this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// src/common.js\nvar require_common = __commonJS({\n  \"src/common.js\"(exports2, module2) {\n    var $protobuf = require_minimal2();\n    var $Reader = $protobuf.Reader;\n    var $Writer = $protobuf.Writer;\n    var $util = $protobuf.util;\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.epoch_proto = function() {\n      var epoch_proto = {};\n      epoch_proto.EpochFolioDashboardWidget = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"WidgetUnspecified\"] = 0;\n        values[valuesById[1] = \"WidgetCard\"] = 1;\n        values[valuesById[2] = \"WidgetLines\"] = 2;\n        values[valuesById[3] = \"WidgetBar\"] = 3;\n        values[valuesById[4] = \"WidgetDataTable\"] = 4;\n        values[valuesById[5] = \"WidgetXRange\"] = 5;\n        values[valuesById[6] = \"WidgetHistogram\"] = 6;\n        values[valuesById[7] = \"WidgetPie\"] = 7;\n        values[valuesById[8] = \"WidgetHeatMap\"] = 8;\n        values[valuesById[9] = \"WidgetBoxPlot\"] = 9;\n        values[valuesById[10] = \"WidgetArea\"] = 10;\n        values[valuesById[11] = \"WidgetColumn\"] = 11;\n        return values;\n      }();\n      epoch_proto.EpochFolioType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"TypeUnspecified\"] = 0;\n        values[valuesById[1] = \"TypeString\"] = 1;\n        values[valuesById[2] = \"TypeInteger\"] = 2;\n        values[valuesById[3] = \"TypeDecimal\"] = 3;\n        values[valuesById[4] = \"TypePercent\"] = 4;\n        values[valuesById[5] = \"TypeBoolean\"] = 5;\n        values[valuesById[6] = \"TypeDateTime\"] = 6;\n        values[valuesById[7] = \"TypeDate\"] = 7;\n        values[valuesById[8] = \"TypeDayDuration\"] = 8;\n        values[valuesById[9] = \"TypeMonetary\"] = 9;\n        values[valuesById[10] = \"TypeDuration\"] = 10;\n        return values;\n      }();\n      epoch_proto.Scalar = function() {\n        function Scalar(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Scalar.prototype.stringValue = null;\n        Scalar.prototype.integerValue = null;\n        Scalar.prototype.decimalValue = null;\n        Scalar.prototype.percentValue = null;\n        Scalar.prototype.booleanValue = null;\n        Scalar.prototype.timestampMs = null;\n        Scalar.prototype.dateValue = null;\n        Scalar.prototype.dayDuration = null;\n        Scalar.prototype.monetaryValue = null;\n        Scalar.prototype.durationMs = null;\n        Scalar.prototype.nullValue = null;\n        var $oneOfFields;\n        Object.defineProperty(Scalar.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"integerValue\", \"decimalValue\", \"percentValue\", \"booleanValue\", \"timestampMs\", \"dateValue\", \"dayDuration\", \"monetaryValue\", \"durationMs\", \"nullValue\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Scalar.create = function create(properties) {\n          return new Scalar(properties);\n        };\n        Scalar.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.stringValue);\n          if (message.integerValue != null && Object.hasOwnProperty.call(message, \"integerValue\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.integerValue);\n          if (message.decimalValue != null && Object.hasOwnProperty.call(message, \"decimalValue\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.decimalValue);\n          if (message.percentValue != null && Object.hasOwnProperty.call(message, \"percentValue\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.percentValue);\n          if (message.booleanValue != null && Object.hasOwnProperty.call(message, \"booleanValue\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.booleanValue);\n          if (message.timestampMs != null && Object.hasOwnProperty.call(message, \"timestampMs\"))\n            writer.uint32(\n              /* id 6, wireType 0 =*/\n              48\n            ).int64(message.timestampMs);\n          if (message.dateValue != null && Object.hasOwnProperty.call(message, \"dateValue\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).int64(message.dateValue);\n          if (message.dayDuration != null && Object.hasOwnProperty.call(message, \"dayDuration\"))\n            writer.uint32(\n              /* id 8, wireType 0 =*/\n              64\n            ).int32(message.dayDuration);\n          if (message.monetaryValue != null && Object.hasOwnProperty.call(message, \"monetaryValue\"))\n            writer.uint32(\n              /* id 9, wireType 1 =*/\n              73\n            ).double(message.monetaryValue);\n          if (message.durationMs != null && Object.hasOwnProperty.call(message, \"durationMs\"))\n            writer.uint32(\n              /* id 10, wireType 0 =*/\n              80\n            ).int64(message.durationMs);\n          if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n            writer.uint32(\n              /* id 11, wireType 0 =*/\n              88\n            ).int32(message.nullValue);\n          return writer;\n        };\n        Scalar.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Scalar.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Scalar();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.stringValue = reader.string();\n                break;\n              }\n              case 2: {\n                message.integerValue = reader.int64();\n                break;\n              }\n              case 3: {\n                message.decimalValue = reader.double();\n                break;\n              }\n              case 4: {\n                message.percentValue = reader.double();\n                break;\n              }\n              case 5: {\n                message.booleanValue = reader.bool();\n                break;\n              }\n              case 6: {\n                message.timestampMs = reader.int64();\n                break;\n              }\n              case 7: {\n                message.dateValue = reader.int64();\n                break;\n              }\n              case 8: {\n                message.dayDuration = reader.int32();\n                break;\n              }\n              case 9: {\n                message.monetaryValue = reader.double();\n                break;\n              }\n              case 10: {\n                message.durationMs = reader.int64();\n                break;\n              }\n              case 11: {\n                message.nullValue = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Scalar.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Scalar.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties.value = 1;\n            if (!$util.isString(message.stringValue))\n              return \"stringValue: string expected\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high)))\n              return \"integerValue: integer|Long expected\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.decimalValue !== \"number\")\n              return \"decimalValue: number expected\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.percentValue !== \"number\")\n              return \"percentValue: number expected\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.booleanValue !== \"boolean\")\n              return \"booleanValue: boolean expected\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))\n              return \"timestampMs: integer|Long expected\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dateValue) && !(message.dateValue && $util.isInteger(message.dateValue.low) && $util.isInteger(message.dateValue.high)))\n              return \"dateValue: integer|Long expected\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dayDuration))\n              return \"dayDuration: integer expected\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.monetaryValue !== \"number\")\n              return \"monetaryValue: number expected\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))\n              return \"durationMs: integer|Long expected\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            switch (message.nullValue) {\n              default:\n                return \"nullValue: enum value expected\";\n              case 0:\n                break;\n            }\n          }\n          return null;\n        };\n        Scalar.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Scalar)\n            return object;\n          var message = new $root.epoch_proto.Scalar();\n          if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n          if (object.integerValue != null) {\n            if ($util.Long)\n              (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;\n            else if (typeof object.integerValue === \"string\")\n              message.integerValue = parseInt(object.integerValue, 10);\n            else if (typeof object.integerValue === \"number\")\n              message.integerValue = object.integerValue;\n            else if (typeof object.integerValue === \"object\")\n              message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();\n          }\n          if (object.decimalValue != null)\n            message.decimalValue = Number(object.decimalValue);\n          if (object.percentValue != null)\n            message.percentValue = Number(object.percentValue);\n          if (object.booleanValue != null)\n            message.booleanValue = Boolean(object.booleanValue);\n          if (object.timestampMs != null) {\n            if ($util.Long)\n              (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;\n            else if (typeof object.timestampMs === \"string\")\n              message.timestampMs = parseInt(object.timestampMs, 10);\n            else if (typeof object.timestampMs === \"number\")\n              message.timestampMs = object.timestampMs;\n            else if (typeof object.timestampMs === \"object\")\n              message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();\n          }\n          if (object.dateValue != null) {\n            if ($util.Long)\n              (message.dateValue = $util.Long.fromValue(object.dateValue)).unsigned = false;\n            else if (typeof object.dateValue === \"string\")\n              message.dateValue = parseInt(object.dateValue, 10);\n            else if (typeof object.dateValue === \"number\")\n              message.dateValue = object.dateValue;\n            else if (typeof object.dateValue === \"object\")\n              message.dateValue = new $util.LongBits(object.dateValue.low >>> 0, object.dateValue.high >>> 0).toNumber();\n          }\n          if (object.dayDuration != null)\n            message.dayDuration = object.dayDuration | 0;\n          if (object.monetaryValue != null)\n            message.monetaryValue = Number(object.monetaryValue);\n          if (object.durationMs != null) {\n            if ($util.Long)\n              (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = false;\n            else if (typeof object.durationMs === \"string\")\n              message.durationMs = parseInt(object.durationMs, 10);\n            else if (typeof object.durationMs === \"number\")\n              message.durationMs = object.durationMs;\n            else if (typeof object.durationMs === \"object\")\n              message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber();\n          }\n          switch (object.nullValue) {\n            default:\n              if (typeof object.nullValue === \"number\") {\n                message.nullValue = object.nullValue;\n                break;\n              }\n              break;\n            case \"NULL_VALUE\":\n            case 0:\n              message.nullValue = 0;\n              break;\n          }\n          return message;\n        };\n        Scalar.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n              object.value = \"stringValue\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (typeof message.integerValue === \"number\")\n              object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;\n            else\n              object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;\n            if (options.oneofs)\n              object.value = \"integerValue\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            object.decimalValue = options.json && !isFinite(message.decimalValue) ? String(message.decimalValue) : message.decimalValue;\n            if (options.oneofs)\n              object.value = \"decimalValue\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            object.percentValue = options.json && !isFinite(message.percentValue) ? String(message.percentValue) : message.percentValue;\n            if (options.oneofs)\n              object.value = \"percentValue\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            object.booleanValue = message.booleanValue;\n            if (options.oneofs)\n              object.value = \"booleanValue\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (typeof message.timestampMs === \"number\")\n              object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;\n            else\n              object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;\n            if (options.oneofs)\n              object.value = \"timestampMs\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (typeof message.dateValue === \"number\")\n              object.dateValue = options.longs === String ? String(message.dateValue) : message.dateValue;\n            else\n              object.dateValue = options.longs === String ? $util.Long.prototype.toString.call(message.dateValue) : options.longs === Number ? new $util.LongBits(message.dateValue.low >>> 0, message.dateValue.high >>> 0).toNumber() : message.dateValue;\n            if (options.oneofs)\n              object.value = \"dateValue\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            object.dayDuration = message.dayDuration;\n            if (options.oneofs)\n              object.value = \"dayDuration\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            object.monetaryValue = options.json && !isFinite(message.monetaryValue) ? String(message.monetaryValue) : message.monetaryValue;\n            if (options.oneofs)\n              object.value = \"monetaryValue\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (typeof message.durationMs === \"number\")\n              object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;\n            else\n              object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber() : message.durationMs;\n            if (options.oneofs)\n              object.value = \"durationMs\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n            if (options.oneofs)\n              object.value = \"nullValue\";\n          }\n          return object;\n        };\n        Scalar.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Scalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Scalar\";\n        };\n        return Scalar;\n      }();\n      epoch_proto.Array = function() {\n        function Array2(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Array2.prototype.values = $util.emptyArray;\n        Array2.create = function create(properties) {\n          return new Array2(properties);\n        };\n        Array2.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        Array2.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Array2.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Array();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Array2.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Array2.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array2.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        Array2.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Array)\n            return object;\n          var message = new $root.epoch_proto.Array();\n          if (object.values) {\n            if (!Array2.isArray(object.values))\n              throw TypeError(\".epoch_proto.Array.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Array.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        Array2.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        Array2.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Array2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Array\";\n        };\n        return Array2;\n      }();\n      epoch_proto.AxisType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"AxisUnspecified\"] = 0;\n        values[valuesById[1] = \"AxisLinear\"] = 1;\n        values[valuesById[2] = \"AxisLogarithmic\"] = 2;\n        values[valuesById[3] = \"AxisDateTime\"] = 3;\n        values[valuesById[4] = \"AxisCategory\"] = 4;\n        return values;\n      }();\n      epoch_proto.DashStyle = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"DashStyleUnspecified\"] = 0;\n        values[valuesById[1] = \"Solid\"] = 1;\n        values[valuesById[2] = \"ShortDash\"] = 2;\n        values[valuesById[3] = \"ShortDot\"] = 3;\n        values[valuesById[4] = \"ShortDashDot\"] = 4;\n        values[valuesById[5] = \"ShortDashDotDot\"] = 5;\n        values[valuesById[6] = \"Dot\"] = 6;\n        values[valuesById[7] = \"Dash\"] = 7;\n        values[valuesById[8] = \"LongDash\"] = 8;\n        values[valuesById[9] = \"DashDot\"] = 9;\n        values[valuesById[10] = \"LongDashDot\"] = 10;\n        values[valuesById[11] = \"LongDashDotDot\"] = 11;\n        return values;\n      }();\n      return epoch_proto;\n    }();\n    $root.google = function() {\n      var google = {};\n      google.protobuf = function() {\n        var protobuf = {};\n        protobuf.Struct = function() {\n          function Struct(properties) {\n            this.fields = {};\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Struct.prototype.fields = $util.emptyObject;\n          Struct.create = function create(properties) {\n            return new Struct(properties);\n          };\n          Struct.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.fields != null && Object.hasOwnProperty.call(message, \"fields\"))\n              for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {\n                writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork().uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).string(keys[i]);\n                $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(\n                  /* id 2, wireType 2 =*/\n                  18\n                ).fork()).ldelim().ldelim();\n              }\n            return writer;\n          };\n          Struct.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Struct.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (message.fields === $util.emptyObject)\n                    message.fields = {};\n                  var end2 = reader.uint32() + reader.pos;\n                  key = \"\";\n                  value = null;\n                  while (reader.pos < end2) {\n                    var tag2 = reader.uint32();\n                    switch (tag2 >>> 3) {\n                      case 1:\n                        key = reader.string();\n                        break;\n                      case 2:\n                        value = $root.google.protobuf.Value.decode(reader, reader.uint32());\n                        break;\n                      default:\n                        reader.skipType(tag2 & 7);\n                        break;\n                    }\n                  }\n                  message.fields[key] = value;\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Struct.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Struct.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.fields != null && message.hasOwnProperty(\"fields\")) {\n              if (!$util.isObject(message.fields))\n                return \"fields: object expected\";\n              var key = Object.keys(message.fields);\n              for (var i = 0; i < key.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);\n                if (error)\n                  return \"fields.\" + error;\n              }\n            }\n            return null;\n          };\n          Struct.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Struct)\n              return object;\n            var message = new $root.google.protobuf.Struct();\n            if (object.fields) {\n              if (typeof object.fields !== \"object\")\n                throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n              message.fields = {};\n              for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {\n                if (typeof object.fields[keys[i]] !== \"object\")\n                  throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n                message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);\n              }\n            }\n            return message;\n          };\n          Struct.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n              object.fields = {};\n            var keys2;\n            if (message.fields && (keys2 = Object.keys(message.fields)).length) {\n              object.fields = {};\n              for (var j = 0; j < keys2.length; ++j)\n                object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);\n            }\n            return object;\n          };\n          Struct.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Struct\";\n          };\n          return Struct;\n        }();\n        protobuf.Value = function() {\n          function Value(properties) {\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Value.prototype.nullValue = null;\n          Value.prototype.numberValue = null;\n          Value.prototype.stringValue = null;\n          Value.prototype.boolValue = null;\n          Value.prototype.structValue = null;\n          Value.prototype.listValue = null;\n          var $oneOfFields;\n          Object.defineProperty(Value.prototype, \"kind\", {\n            get: $util.oneOfGetter($oneOfFields = [\"nullValue\", \"numberValue\", \"stringValue\", \"boolValue\", \"structValue\", \"listValue\"]),\n            set: $util.oneOfSetter($oneOfFields)\n          });\n          Value.create = function create(properties) {\n            return new Value(properties);\n          };\n          Value.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n              writer.uint32(\n                /* id 1, wireType 0 =*/\n                8\n              ).int32(message.nullValue);\n            if (message.numberValue != null && Object.hasOwnProperty.call(message, \"numberValue\"))\n              writer.uint32(\n                /* id 2, wireType 1 =*/\n                17\n              ).double(message.numberValue);\n            if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.stringValue);\n            if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n              writer.uint32(\n                /* id 4, wireType 0 =*/\n                32\n              ).bool(message.boolValue);\n            if (message.structValue != null && Object.hasOwnProperty.call(message, \"structValue\"))\n              $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n            if (message.listValue != null && Object.hasOwnProperty.call(message, \"listValue\"))\n              $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(\n                /* id 6, wireType 2 =*/\n                50\n              ).fork()).ldelim();\n            return writer;\n          };\n          Value.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Value.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  message.nullValue = reader.int32();\n                  break;\n                }\n                case 2: {\n                  message.numberValue = reader.double();\n                  break;\n                }\n                case 3: {\n                  message.stringValue = reader.string();\n                  break;\n                }\n                case 4: {\n                  message.boolValue = reader.bool();\n                  break;\n                }\n                case 5: {\n                  message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());\n                  break;\n                }\n                case 6: {\n                  message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Value.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Value.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            var properties = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              properties.kind = 1;\n              switch (message.nullValue) {\n                default:\n                  return \"nullValue: enum value expected\";\n                case 0:\n                  break;\n              }\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.numberValue !== \"number\")\n                return \"numberValue: number expected\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.boolValue !== \"boolean\")\n                return \"boolValue: boolean expected\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.Struct.verify(message.structValue);\n                if (error)\n                  return \"structValue.\" + error;\n              }\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.ListValue.verify(message.listValue);\n                if (error)\n                  return \"listValue.\" + error;\n              }\n            }\n            return null;\n          };\n          Value.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Value)\n              return object;\n            var message = new $root.google.protobuf.Value();\n            switch (object.nullValue) {\n              default:\n                if (typeof object.nullValue === \"number\") {\n                  message.nullValue = object.nullValue;\n                  break;\n                }\n                break;\n              case \"NULL_VALUE\":\n              case 0:\n                message.nullValue = 0;\n                break;\n            }\n            if (object.numberValue != null)\n              message.numberValue = Number(object.numberValue);\n            if (object.stringValue != null)\n              message.stringValue = String(object.stringValue);\n            if (object.boolValue != null)\n              message.boolValue = Boolean(object.boolValue);\n            if (object.structValue != null) {\n              if (typeof object.structValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.structValue: object expected\");\n              message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);\n            }\n            if (object.listValue != null) {\n              if (typeof object.listValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.listValue: object expected\");\n              message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);\n            }\n            return message;\n          };\n          Value.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n              if (options.oneofs)\n                object.kind = \"nullValue\";\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;\n              if (options.oneofs)\n                object.kind = \"numberValue\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              object.stringValue = message.stringValue;\n              if (options.oneofs)\n                object.kind = \"stringValue\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              object.boolValue = message.boolValue;\n              if (options.oneofs)\n                object.kind = \"boolValue\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);\n              if (options.oneofs)\n                object.kind = \"structValue\";\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);\n              if (options.oneofs)\n                object.kind = \"listValue\";\n            }\n            return object;\n          };\n          Value.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Value\";\n          };\n          return Value;\n        }();\n        protobuf.NullValue = function() {\n          var valuesById = {}, values = Object.create(valuesById);\n          values[valuesById[0] = \"NULL_VALUE\"] = 0;\n          return values;\n        }();\n        protobuf.ListValue = function() {\n          function ListValue(properties) {\n            this.values = [];\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          ListValue.prototype.values = $util.emptyArray;\n          ListValue.create = function create(properties) {\n            return new ListValue(properties);\n          };\n          ListValue.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.values != null && message.values.length)\n              for (var i = 0; i < message.values.length; ++i)\n                $root.google.protobuf.Value.encode(message.values[i], writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork()).ldelim();\n            return writer;\n          };\n          ListValue.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          ListValue.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (!(message.values && message.values.length))\n                    message.values = [];\n                  message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          ListValue.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          ListValue.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.values != null && message.hasOwnProperty(\"values\")) {\n              if (!Array.isArray(message.values))\n                return \"values: array expected\";\n              for (var i = 0; i < message.values.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.values[i]);\n                if (error)\n                  return \"values.\" + error;\n              }\n            }\n            return null;\n          };\n          ListValue.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.ListValue)\n              return object;\n            var message = new $root.google.protobuf.ListValue();\n            if (object.values) {\n              if (!Array.isArray(object.values))\n                throw TypeError(\".google.protobuf.ListValue.values: array expected\");\n              message.values = [];\n              for (var i = 0; i < object.values.length; ++i) {\n                if (typeof object.values[i] !== \"object\")\n                  throw TypeError(\".google.protobuf.ListValue.values: object expected\");\n                message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);\n              }\n            }\n            return message;\n          };\n          ListValue.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n              object.values = [];\n            if (message.values && message.values.length) {\n              object.values = [];\n              for (var j = 0; j < message.values.length; ++j)\n                object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);\n            }\n            return object;\n          };\n          ListValue.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.ListValue\";\n          };\n          return ListValue;\n        }();\n        return protobuf;\n      }();\n      return google;\n    }();\n    module2.exports = $root;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (require_common());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvY29tbW9uLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUMxRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBTSxvQkFBb0IscUJBQU0sSUFBSSxxQkFBTSxZQUFZLHFCQUFNLHFCQUFxQixxQkFBTTtBQUN4SCxpQ0FBaUMscUJBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsaUJBQWlCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRCxpRUFBZSxnQkFBZ0IsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9ub2RlX21vZHVsZXMvQGVwb2NobGFiL2Vwb2NoLXByb3Rvcy9kaXN0L2NvbW1vbi5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kMikgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kMiB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZDIgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZDIpLCBtb2QyLmV4cG9ydHM7XG59O1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9hc3Byb21pc2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBhc1Byb21pc2U7XG4gICAgZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCBvZmZzZXQgPSAwLCBpbmRleCA9IDIsIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIpIHtcbiAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtczIgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCBvZmZzZXQyID0gMDtcbiAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldDIgPCBwYXJhbXMyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBwYXJhbXMyW29mZnNldDIrK10gPSBhcmd1bWVudHNbb2Zmc2V0Ml07XG4gICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAocGVuZGluZykge1xuICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9iYXNlNjQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYmFzZTY0ID0gZXhwb3J0czI7XG4gICAgYmFzZTY0Lmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChzdHJpbmcpIHtcbiAgICAgIHZhciBwID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmICghcClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB2YXIgbiA9IDA7XG4gICAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXG4gICAgICAgICsrbjtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XG4gICAgfTtcbiAgICB2YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcbiAgICB2YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XG4gICAgZm9yIChpID0gMDsgaSA8IDY0OyApXG4gICAgICBzNjRbYjY0W2ldID0gaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpIC0gNTkgfCA0M10gPSBpKys7XG4gICAgdmFyIGk7XG4gICAgYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBwYXJ0cyA9IG51bGwsIGNodW5rID0gW107XG4gICAgICB2YXIgaTIgPSAwLCBqID0gMCwgdDtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcbiAgICAgICAgc3dpdGNoIChqKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbYiA+PiAyXTtcbiAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XG4gICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNodW5rW2kyKytdID0gYjY0W3QgfCBiID4+IDRdO1xuICAgICAgICAgICAgdCA9IChiICYgMTUpIDw8IDI7XG4gICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNodW5rW2kyKytdID0gYjY0W3QgfCBiID4+IDZdO1xuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbYiAmIDYzXTtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkyID4gODE5MSkge1xuICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XG4gICAgICAgICAgaTIgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaikge1xuICAgICAgICBjaHVua1tpMisrXSA9IGI2NFt0XTtcbiAgICAgICAgY2h1bmtbaTIrK10gPSA2MTtcbiAgICAgICAgaWYgKGogPT09IDEpXG4gICAgICAgICAgY2h1bmtbaTIrK10gPSA2MTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICBpZiAoaTIpXG4gICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaTIpKSk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpMikpO1xuICAgIH07XG4gICAgdmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xuICAgIGJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xuICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgdmFyIGogPSAwLCB0O1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHN0cmluZy5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkyKyspO1xuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHZvaWQgMClcbiAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XG4gICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xuICAgICAgICAgICAgdCA9IGM7XG4gICAgICAgICAgICBqID0gMztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDMpIDw8IDYgfCBjO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGogPT09IDEpXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XG4gICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgfTtcbiAgICBiYXNlNjQudGVzdCA9IGZ1bmN0aW9uIHRlc3Qoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyaW5nKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qc1xudmFyIHJlcXVpcmVfZXZlbnRlbWl0dGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XG4gICAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcbiAgICAgICAgZm4sXG4gICAgICAgIGN0eDogY3R4IHx8IHRoaXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XG4gICAgICBpZiAoZXZ0ID09PSB2b2lkIDApXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChmbiA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IClcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxuICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcbiAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSwgaSA9IDE7XG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKVxuICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyApXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzXG52YXIgcmVxdWlyZV9mbG9hdCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcbiAgICBmdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMzKSB7XG4gICAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbLTBdKSwgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksIGxlID0gZjhiWzNdID09PSAxMjg7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjMyWzBdID0gdmFsO1xuICAgICAgICAgIGJ1Zltwb3NdID0gZjhiWzBdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XG4gICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjMyWzBdID0gdmFsO1xuICAgICAgICAgIGJ1Zltwb3NdID0gZjhiWzNdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XG4gICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xuICAgICAgICBleHBvcnRzMy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICByZXR1cm4gZjMyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjhiWzNdID0gYnVmW3Bvc107XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XG4gICAgICAgICAgcmV0dXJuIGYzMlswXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcbiAgICAgICAgZXhwb3J0czMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XG4gICAgICB9KSgpO1xuICAgICAgZWxzZSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcbiAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgIHZhbCA9IC12YWw7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gMClcbiAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IChcbiAgICAgICAgICAgICAgLyogcG9zaXRpdmUgKi9cbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgLyogbmVnYXRpdmUgMCAqL1xuICAgICAgICAgICAgICAyMTQ3NDgzNjQ4XG4gICAgICAgICAgICApLCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcbiAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSBpZiAodmFsID4gMzQwMjgyMzQ2NjM4NTI4ODZlMjIpXG4gICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xuICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDExNzU0OTQzNTA4MjIyODc1ZS01NClcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMTQwMTI5ODQ2NDMyNDgxN2UtNjApKSA+Pj4gMCwgYnVmLCBwb3MpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLCBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSwgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLCBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LCBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xuICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1ID8gbWFudGlzc2EgPyBOYU4gOiBzaWduICogSW5maW5pdHkgOiBleHBvbmVudCA9PT0gMCA/IHNpZ24gKiAxNDAxMjk4NDY0MzI0ODE3ZS02MCAqIG1hbnRpc3NhIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcbiAgICAgICAgZXhwb3J0czMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xuICAgICAgfSkoKTtcbiAgICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLCBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSwgbGUgPSBmOGJbN10gPT09IDEyODtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjY0WzBdID0gdmFsO1xuICAgICAgICAgIGJ1Zltwb3NdID0gZjhiWzBdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XG4gICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcbiAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XG4gICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmNjRbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbN107XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XG4gICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XG4gICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xuICAgICAgICBleHBvcnRzMy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjhiWzBdID0gYnVmW3Bvc107XG4gICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xuICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XG4gICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xuICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcbiAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XG4gICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xuICAgICAgICAgIHJldHVybiBmNjRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjhiWzddID0gYnVmW3Bvc107XG4gICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xuICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcbiAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XG4gICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xuICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcbiAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XG4gICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xuICAgICAgICAgIHJldHVybiBmNjRbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XG4gICAgICAgIGV4cG9ydHMzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xuICAgICAgfSkoKTtcbiAgICAgIGVsc2UgKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xuICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgdmFsID0gLXZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IChcbiAgICAgICAgICAgICAgLyogcG9zaXRpdmUgKi9cbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgLyogbmVnYXRpdmUgMCAqL1xuICAgICAgICAgICAgICAyMTQ3NDgzNjQ4XG4gICAgICAgICAgICApLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mikge1xuICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xuICAgICAgICAgICAgaWYgKHZhbCA8IDIyMjUwNzM4NTg1MDcyMDE0ZS0zMjQpIHtcbiAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XG4gICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcbiAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcbiAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xuICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSwgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLCBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XG4gICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3ID8gbWFudGlzc2EgPyBOYU4gOiBzaWduICogSW5maW5pdHkgOiBleHBvbmVudCA9PT0gMCA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYSA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XG4gICAgICAgIGV4cG9ydHMzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xuICAgICAgfSkoKTtcbiAgICAgIHJldHVybiBleHBvcnRzMztcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG4gICAgICBidWZbcG9zICsgMV0gPSB2YWwgPj4+IDggJiAyNTU7XG4gICAgICBidWZbcG9zICsgMl0gPSB2YWwgPj4+IDE2ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDNdID0gdmFsID4+PiAyNDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmW3Bvc10gPSB2YWwgPj4+IDI0O1xuICAgICAgYnVmW3BvcyArIDFdID0gdmFsID4+PiAxNiAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAyXSA9IHZhbCA+Pj4gOCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAzXSA9IHZhbCAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xuICAgICAgcmV0dXJuIChidWZbcG9zXSB8IGJ1Zltwb3MgKyAxXSA8PCA4IHwgYnVmW3BvcyArIDJdIDw8IDE2IHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xuICAgICAgcmV0dXJuIChidWZbcG9zXSA8PCAyNCB8IGJ1Zltwb3MgKyAxXSA8PCAxNiB8IGJ1Zltwb3MgKyAyXSA8PCA4IHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfaW5xdWlyZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xuICAgIGZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLCBcInJlXCIpKShtb2R1bGVOYW1lKTtcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXG4gICAgICAgICAgcmV0dXJuIG1vZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzXG52YXIgcmVxdWlyZV91dGY4ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1dGY4ID0gZXhwb3J0czI7XG4gICAgdXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcbiAgICAgIHZhciBsZW4gPSAwLCBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpXG4gICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxuICAgICAgICAgIGxlbiArPSAyO1xuICAgICAgICBlbHNlIGlmICgoYyAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDY0NTEyKSA9PT0gNTYzMjApIHtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgbGVuICs9IDQ7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGxlbiArPSAzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbjtcbiAgICB9O1xuICAgIHV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgICAgIGlmIChsZW4gPCAxKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBwYXJ0cyA9IG51bGwsIGNodW5rID0gW10sIGkgPSAwLCB0O1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XG4gICAgICAgIGlmICh0IDwgMTI4KVxuICAgICAgICAgIGNodW5rW2krK10gPSB0O1xuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXG4gICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XG4gICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDY1NTM2O1xuICAgICAgICAgIGNodW5rW2krK10gPSA1NTI5NiArICh0ID4+IDEwKTtcbiAgICAgICAgICBjaHVua1tpKytdID0gNTYzMjAgKyAodCAmIDEwMjMpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XG4gICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XG4gICAgfTtcbiAgICB1dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQsIGMxLCBjMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiB8IDE5MjtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgJiA2MyB8IDEyODtcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiA2NDUxMikgPT09IDU1Mjk2ICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgNjQ1MTIpID09PSA1NjMyMCkge1xuICAgICAgICAgIGMxID0gNjU1MzYgKyAoKGMxICYgMTAyMykgPDwgMTApICsgKGMyICYgMTAyMyk7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCB8IDI0MDtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAmIDYzIHwgMTI4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiB8IDIyNDtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAmIDYzIHwgMTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzXG52YXIgcmVxdWlyZV9wb29sID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHBvb2w7XG4gICAgZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcbiAgICAgIHZhciBTSVpFID0gc2l6ZSB8fCA4MTkyO1xuICAgICAgdmFyIE1BWCA9IFNJWkUgPj4+IDE7XG4gICAgICB2YXIgc2xhYiA9IG51bGw7XG4gICAgICB2YXIgb2Zmc2V0ID0gU0laRTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUyKSB7XG4gICAgICAgIGlmIChzaXplMiA8IDEgfHwgc2l6ZTIgPiBNQVgpXG4gICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUyKTtcbiAgICAgICAgaWYgKG9mZnNldCArIHNpemUyID4gU0laRSkge1xuICAgICAgICAgIHNsYWIgPSBhbGxvYyhTSVpFKTtcbiAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUyKTtcbiAgICAgICAgaWYgKG9mZnNldCAmIDcpXG4gICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgIH07XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanNcbnZhciByZXF1aXJlX2xvbmdiaXRzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IExvbmdCaXRzO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG4gICAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG4gICAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG4gICAgfVxuICAgIHZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB6ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIHplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIHZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcbiAgICBMb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xuICAgIH07XG4gICAgTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsIGhpID0gfnRoaXMuaGkgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgICByZXR1cm4gdXRpbC5Mb25nID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKSA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xuICAgIH07XG4gICAgdmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG4gICAgTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKSB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4IHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2IHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMCxcbiAgICAgICAgKGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KSB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4IHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2IHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICAgKTtcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0LFxuICAgICAgICB0aGlzLmhpICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICAgICk7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICAgIHZhciBtYXNrID0gdGhpcy5oaSA+PiAzMTtcbiAgICAgIHRoaXMuaGkgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgICAgdGhpcy5sbyA9ICh0aGlzLmxvIDw8IDEgXiBtYXNrKSA+Pj4gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgICAgdGhpcy5sbyA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgICB0aGlzLmhpID0gKHRoaXMuaGkgPj4+IDEgXiBtYXNrKSA+Pj4gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgIHZhciBwYXJ0MCA9IHRoaXMubG8sIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCwgcGFydDIgPSB0aGlzLmhpID4+PiAyNDtcbiAgICAgIHJldHVybiBwYXJ0MiA9PT0gMCA/IHBhcnQxID09PSAwID8gcGFydDAgPCAxNjM4NCA/IHBhcnQwIDwgMTI4ID8gMSA6IDIgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNCA6IHBhcnQxIDwgMTYzODQgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2IDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDggOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qc1xudmFyIHJlcXVpcmVfbWluaW1hbCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciB1dGlsID0gZXhwb3J0czI7XG4gICAgdXRpbC5hc1Byb21pc2UgPSByZXF1aXJlX2FzcHJvbWlzZSgpO1xuICAgIHV0aWwuYmFzZTY0ID0gcmVxdWlyZV9iYXNlNjQoKTtcbiAgICB1dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmVfZXZlbnRlbWl0dGVyKCk7XG4gICAgdXRpbC5mbG9hdCA9IHJlcXVpcmVfZmxvYXQoKTtcbiAgICB1dGlsLmlucXVpcmUgPSByZXF1aXJlX2lucXVpcmUoKTtcbiAgICB1dGlsLnV0ZjggPSByZXF1aXJlX3V0ZjgoKTtcbiAgICB1dGlsLnBvb2wgPSByZXF1aXJlX3Bvb2woKTtcbiAgICB1dGlsLkxvbmdCaXRzID0gcmVxdWlyZV9sb25nYml0cygpO1xuICAgIHV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCAmJiBnbG9iYWwucHJvY2VzcyAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucyAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcbiAgICB1dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdyB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmIHx8IGV4cG9ydHMyO1xuICAgIHV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IChcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBbXVxuICAgICk7XG4gICAgdXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IChcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB7fVxuICAgICk7XG4gICAgdXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG4gICAgfTtcbiAgICB1dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfTtcbiAgICB1dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gICAgfTtcbiAgICB1dGlsLmlzc2V0ID0gLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIHV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB1dGlsLkJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlcjIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICByZXR1cm4gQnVmZmVyMi5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyMiA6IChcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIG51bGxcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSgpO1xuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgIHV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiID8gdXRpbC5CdWZmZXIgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpIDogdXRpbC5CdWZmZXIgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSkgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IHNpemVPckFycmF5IDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xuICAgIH07XG4gICAgdXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSA6IEFycmF5O1xuICAgIHV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZyB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHV0aWwuZ2xvYmFsLkxvbmcgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcbiAgICB1dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcbiAgICB1dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcbiAgICB1dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG4gICAgdXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKSA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG4gICAgfTtcbiAgICB1dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHtcbiAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHZvaWQgMCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgdXRpbC5tZXJnZSA9IG1lcmdlO1xuICAgIHV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcbiAgICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSB9KTtcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKVxuICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXJyb3IsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiB2b2lkIDAsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgLy8gY29uZmlndXJhYmxlOiBmYWxzZSB3b3VsZCBhY2N1cmF0ZWx5IHByZXNlcnZlIHRoZSBiZWhhdmlvciBvZlxuICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYnV0IEknbSBndWVzc2luZyB0aGF0IHdhcyBub3QgaW50ZW50aW9uYWwuXG4gICAgICAgICAgLy8gRm9yIGFuIGFjdHVhbCBlcnJvciBzdWJjbGFzcywgdGhpcyBwcm9wZXJ0eSB3b3VsZFxuICAgICAgICAgIC8vIGJlIGNvbmZpZ3VyYWJsZS5cbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IHtcbiAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIEN1c3RvbUVycm9yO1xuICAgIH1cbiAgICB1dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG4gICAgdXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuICAgIHV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkyID0ga2V5cy5sZW5ndGggLSAxOyBpMiA+IC0xOyAtLWkyKVxuICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2kyXV0gPT09IDEgJiYgdGhpc1trZXlzW2kyXV0gIT09IHZvaWQgMCAmJiB0aGlzW2tleXNbaTJdXSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBrZXlzW2kyXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB1dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgICB9O1xuICAgIH07XG4gICAgdXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgICAgbG9uZ3M6IFN0cmluZyxcbiAgICAgIGVudW1zOiBTdHJpbmcsXG4gICAgICBieXRlczogU3RyaW5nLFxuICAgICAganNvbjogdHJ1ZVxuICAgIH07XG4gICAgdXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgQnVmZmVyMiA9IHV0aWwuQnVmZmVyO1xuICAgICAgaWYgKCFCdWZmZXIyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIyLmZyb20gfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgIH07XG4gICAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIyLmFsbG9jVW5zYWZlIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcjIoc2l6ZSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzXG52YXIgcmVxdWlyZV93cml0ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBXcml0ZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICB2YXIgQnVmZmVyV3JpdGVyO1xuICAgIHZhciBMb25nQml0cyA9IHV0aWwuTG9uZ0JpdHM7XG4gICAgdmFyIGJhc2U2NCA9IHV0aWwuYmFzZTY0O1xuICAgIHZhciB1dGY4ID0gdXRpbC51dGY4O1xuICAgIGZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuICAgICAgdGhpcy5mbiA9IGZuO1xuICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICB9XG4gICAgZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG4gICAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcbiAgICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuICAgICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuICAgICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGVyKCkge1xuICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuICAgICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlMigpIHtcbiAgICAgIHJldHVybiB1dGlsLkJ1ZmZlciA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgfSkoKTtcbiAgICAgIH0gOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIFdyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbiAgICB9O1xuICAgIGlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcbiAgICBXcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgICB9XG4gICAgICBidWZbcG9zXSA9IHZhbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgfVxuICAgIFZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcbiAgICBWYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuICAgIFdyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKSA8IDEyOCA/IDEgOiB2YWx1ZSA8IDE2Mzg0ID8gMiA6IHZhbHVlIDwgMjA5NzE1MiA/IDMgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDQgOiA1LFxuICAgICAgICB2YWx1ZVxuICAgICAgKSkubGVuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgICAgfVxuICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbiAgICB9XG4gICAgV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDFdID0gdmFsID4+PiA4ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDJdID0gdmFsID4+PiAxNiAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAzXSA9IHZhbCA+Pj4gMjQ7XG4gICAgfVxuICAgIFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldCA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpO1xuICAgIH0gOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICAgIHJldHVybiBsZW4gPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLCB0YWlsID0gdGhpcy50YWlsLCBsZW4gPSB0aGlzLmxlbjtcbiAgICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7XG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCBidWYgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSwgcG9zID0gMDtcbiAgICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9O1xuICAgIFdyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzXG52YXIgcmVxdWlyZV93cml0ZXJfYnVmZmVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcbiAgICB2YXIgV3JpdGVyID0gcmVxdWlyZV93cml0ZXIoKTtcbiAgICAoQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgICAgV3JpdGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG4gICAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTtcbiAgICAgIH0gOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICBpZiAodmFsLmNvcHkpXG4gICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKVxuICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgICAgaWYgKHZhbC5sZW5ndGggPCA0MClcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG4gICAgfVxuICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgICAgdGhpcy51aW50MzIobGVuKTtcbiAgICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qc1xudmFyIHJlcXVpcmVfcmVhZGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gUmVhZGVyO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgdmFyIEJ1ZmZlclJlYWRlcjtcbiAgICB2YXIgTG9uZ0JpdHMgPSB1dGlsLkxvbmdCaXRzO1xuICAgIHZhciB1dGY4ID0gdXRpbC51dGY4O1xuICAgIGZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuICAgICAgdGhpcy5idWYgPSBidWZmZXI7XG4gICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheTIoYnVmZmVyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUyKCkge1xuICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIyKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcjIpID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIyKSA6IGNyZWF0ZV9hcnJheShidWZmZXIyKTtcbiAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgIH0gOiBjcmVhdGVfYXJyYXk7XG4gICAgfTtcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICAgIFJlYWRlci5wcm90b3R5cGUudWludDMyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgNykgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTUpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH0oKTtcbiAgICBSZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHtcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xuICAgIH1cbiAgICBSZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkge1xuICAgICAgcmV0dXJuIChidWZbZW5kIC0gNF0gfCBidWZbZW5kIC0gM10gPDwgOCB8IGJ1ZltlbmQgLSAyXSA8PCAxNiB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG4gICAgfVxuICAgIFJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuICAgICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuICAgICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVhZEZpeGVkNjQoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcbiAgICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG4gICAgfVxuICAgIFJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuICAgICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zICs9IDg7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLCBzdGFydCA9IHRoaXMucG9zLCBlbmQgPSB0aGlzLnBvcyArIGxlbmd0aDtcbiAgICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpXG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIHZhciBuYXRpdmVCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUJ1ZmZlciA/IG5hdGl2ZUJ1ZmZlci5hbGxvYygwKSA6IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuICAgICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IChcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgXCJ0b051bWJlclwiXG4gICAgICApO1xuICAgICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzXG52YXIgcmVxdWlyZV9yZWFkZXJfYnVmZmVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcbiAgICB2YXIgUmVhZGVyID0gcmVxdWlyZV9yZWFkZXIoKTtcbiAgICAoQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcbiAgICB9XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG4gICAgfTtcbiAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpO1xuICAgICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZSA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKSA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG4gICAgfTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzXG52YXIgcmVxdWlyZV9zZXJ2aWNlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBTZXJ2aWNlO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG4gICAgZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG4gICAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuICAgICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xuICAgIH1cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgICB2YXIgc2VsZjIgPSB0aGlzO1xuICAgICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYyLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuICAgICAgaWYgKCFzZWxmMi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZjIucnBjSW1wbChcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZjIucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHNlbGYyLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGYyLmVuZChcbiAgICAgICAgICAgICAgICAvKiBlbmRlZEJ5UlBDICovXG4gICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZjIucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgICAgICAgc2VsZjIuZW1pdChcImVycm9yXCIsIGVycjIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycjIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmMi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYyLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfTtcbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpXG4gICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qc1xudmFyIHJlcXVpcmVfcnBjID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHJwYyA9IGV4cG9ydHMyO1xuICAgIHJwYy5TZXJ2aWNlID0gcmVxdWlyZV9zZXJ2aWNlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanNcbnZhciByZXF1aXJlX3Jvb3RzID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSB7fTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzXG52YXIgcmVxdWlyZV9pbmRleF9taW5pbWFsID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwcm90b2J1ZiA9IGV4cG9ydHMyO1xuICAgIHByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG4gICAgcHJvdG9idWYuV3JpdGVyID0gcmVxdWlyZV93cml0ZXIoKTtcbiAgICBwcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlX3dyaXRlcl9idWZmZXIoKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIgPSByZXF1aXJlX3JlYWRlcigpO1xuICAgIHByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmVfcmVhZGVyX2J1ZmZlcigpO1xuICAgIHByb3RvYnVmLnV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBwcm90b2J1Zi5ycGMgPSByZXF1aXJlX3JwYygpO1xuICAgIHByb3RvYnVmLnJvb3RzID0gcmVxdWlyZV9yb290cygpO1xuICAgIHByb3RvYnVmLmNvbmZpZ3VyZSA9IGNvbmZpZ3VyZTtcbiAgICBmdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcbiAgICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xuICAgIH1cbiAgICBjb25maWd1cmUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanNcbnZhciByZXF1aXJlX21pbmltYWwyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcmVxdWlyZV9pbmRleF9taW5pbWFsKCk7XG4gIH1cbn0pO1xuXG4vLyBzcmMvY29tbW9uLmpzXG52YXIgcmVxdWlyZV9jb21tb24gPSBfX2NvbW1vbkpTKHtcbiAgXCJzcmMvY29tbW9uLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICB2YXIgJHByb3RvYnVmID0gcmVxdWlyZV9taW5pbWFsMigpO1xuICAgIHZhciAkUmVhZGVyID0gJHByb3RvYnVmLlJlYWRlcjtcbiAgICB2YXIgJFdyaXRlciA9ICRwcm90b2J1Zi5Xcml0ZXI7XG4gICAgdmFyICR1dGlsID0gJHByb3RvYnVmLnV0aWw7XG4gICAgdmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcbiAgICAkcm9vdC5lcG9jaF9wcm90byA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVwb2NoX3Byb3RvID0ge307XG4gICAgICBlcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJXaWRnZXRVbnNwZWNpZmllZFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJXaWRnZXRDYXJkXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIldpZGdldExpbmVzXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIldpZGdldEJhclwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJXaWRnZXREYXRhVGFibGVcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiV2lkZ2V0WFJhbmdlXCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIldpZGdldEhpc3RvZ3JhbVwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJXaWRnZXRQaWVcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiV2lkZ2V0SGVhdE1hcFwiXSA9IDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzldID0gXCJXaWRnZXRCb3hQbG90XCJdID0gOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJXaWRnZXRBcmVhXCJdID0gMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiV2lkZ2V0Q29sdW1uXCJdID0gMTE7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5FcG9jaEZvbGlvVHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiVHlwZVVuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlR5cGVTdHJpbmdcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiVHlwZUludGVnZXJcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiVHlwZURlY2ltYWxcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiVHlwZVBlcmNlbnRcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiVHlwZUJvb2xlYW5cIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiVHlwZURhdGVUaW1lXCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIlR5cGVEYXRlXCJdID0gNztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlR5cGVEYXlEdXJhdGlvblwiXSA9IDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzldID0gXCJUeXBlTW9uZXRhcnlcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIlR5cGVEdXJhdGlvblwiXSA9IDEwO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uU2NhbGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjYWxhcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5pbnRlZ2VyVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmRlY2ltYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUucGVyY2VudFZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnRpbWVzdGFtcE1zID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kYXRlVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmRheUR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5tb25ldGFyeVZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kdXJhdGlvbk1zID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5udWxsVmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJzdHJpbmdWYWx1ZVwiLCBcImludGVnZXJWYWx1ZVwiLCBcImRlY2ltYWxWYWx1ZVwiLCBcInBlcmNlbnRWYWx1ZVwiLCBcImJvb2xlYW5WYWx1ZVwiLCBcInRpbWVzdGFtcE1zXCIsIFwiZGF0ZVZhbHVlXCIsIFwiZGF5RHVyYXRpb25cIiwgXCJtb25ldGFyeVZhbHVlXCIsIFwiZHVyYXRpb25Nc1wiLCBcIm51bGxWYWx1ZVwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBTY2FsYXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInN0cmluZ1ZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2Uuc3RyaW5nVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmludGVnZXJWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaW50ZWdlclZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMTZcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS5pbnRlZ2VyVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRlY2ltYWxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGVjaW1hbFZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMjVcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UuZGVjaW1hbFZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wZXJjZW50VmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInBlcmNlbnRWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDMzXG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnBlcmNlbnRWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJib29sZWFuVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UuYm9vbGVhblZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXBNcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGltZXN0YW1wTXNcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA0OFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLnRpbWVzdGFtcE1zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRlVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGVWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDcsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDU2XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UuZGF0ZVZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXlEdXJhdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF5RHVyYXRpb25cIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA4LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA2NFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLmRheUR1cmF0aW9uKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5tb25ldGFyeVZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJtb25ldGFyeVZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgOSwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgNzNcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZHVyYXRpb25Nc1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEwLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4MFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLmR1cmF0aW9uTXMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibnVsbFZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMTEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDg4XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UubnVsbFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRlY2ltYWxWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBlcmNlbnRWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJvb2xlYW5WYWx1ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXlEdXJhdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nVmFsdWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pbnRlZ2VyVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50ZWdlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludGVnZXJWYWx1ZSkgJiYgIShtZXNzYWdlLmludGVnZXJWYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRlZ2VyVmFsdWUubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRlZ2VyVmFsdWUuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJpbnRlZ2VyVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kZWNpbWFsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVjaW1hbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGVjaW1hbFZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkZWNpbWFsVmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wZXJjZW50VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGVyY2VudFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UucGVyY2VudFZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJwZXJjZW50VmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ib29sZWFuVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbGVhblZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblZhbHVlOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcE1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpbWVzdGFtcE1zXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRpbWVzdGFtcE1zKSAmJiAhKG1lc3NhZ2UudGltZXN0YW1wTXMgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudGltZXN0YW1wTXMubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50aW1lc3RhbXBNcy5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInRpbWVzdGFtcE1zOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0ZVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGVWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXRlVmFsdWUpICYmICEobWVzc2FnZS5kYXRlVmFsdWUgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0ZVZhbHVlLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0ZVZhbHVlLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0ZVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF5RHVyYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF5RHVyYXRpb25cIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF5RHVyYXRpb24pKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXlEdXJhdGlvbjogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5tb25ldGFyeVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1vbmV0YXJ5VmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tb25ldGFyeVZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJtb25ldGFyeVZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkdXJhdGlvbk1zXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmR1cmF0aW9uTXMpICYmICEobWVzc2FnZS5kdXJhdGlvbk1zICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmR1cmF0aW9uTXMubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kdXJhdGlvbk1zLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZHVyYXRpb25NczogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJudWxsVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5udWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsVmFsdWU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhcigpO1xuICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5nVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSBTdHJpbmcob2JqZWN0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmludGVnZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludGVnZXJWYWx1ZSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludGVnZXJWYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSBwYXJzZUludChvYmplY3QuaW50ZWdlclZhbHVlLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludGVnZXJWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSBvYmplY3QuaW50ZWdlclZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRlZ2VyVmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnRlZ2VyVmFsdWUubG93ID4+PiAwLCBvYmplY3QuaW50ZWdlclZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZGVjaW1hbFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmRlY2ltYWxWYWx1ZSA9IE51bWJlcihvYmplY3QuZGVjaW1hbFZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnBlcmNlbnRWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5wZXJjZW50VmFsdWUgPSBOdW1iZXIob2JqZWN0LnBlcmNlbnRWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5ib29sZWFuVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuYm9vbGVhblZhbHVlID0gQm9vbGVhbihvYmplY3QuYm9vbGVhblZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnRpbWVzdGFtcE1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS50aW1lc3RhbXBNcyA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBNcykpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnRpbWVzdGFtcE1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gcGFyc2VJbnQob2JqZWN0LnRpbWVzdGFtcE1zLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnRpbWVzdGFtcE1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gb2JqZWN0LnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC50aW1lc3RhbXBNcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudGltZXN0YW1wTXMubG93ID4+PiAwLCBvYmplY3QudGltZXN0YW1wTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmRhdGVWYWx1ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kYXRlVmFsdWUpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kYXRlVmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gcGFyc2VJbnQob2JqZWN0LmRhdGVWYWx1ZSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kYXRlVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gb2JqZWN0LmRhdGVWYWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGF0ZVZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGVWYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGF0ZVZhbHVlLmxvdyA+Pj4gMCwgb2JqZWN0LmRhdGVWYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRheUR1cmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmRheUR1cmF0aW9uID0gb2JqZWN0LmRheUR1cmF0aW9uIHwgMDtcbiAgICAgICAgICBpZiAob2JqZWN0Lm1vbmV0YXJ5VmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSA9IE51bWJlcihvYmplY3QubW9uZXRhcnlWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5kdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5kdXJhdGlvbk1zID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmR1cmF0aW9uTXMpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kdXJhdGlvbk1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSBwYXJzZUludChvYmplY3QuZHVyYXRpb25NcywgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kdXJhdGlvbk1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSBvYmplY3QuZHVyYXRpb25NcztcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZHVyYXRpb25NcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kdXJhdGlvbk1zLmxvdyA+Pj4gMCwgb2JqZWN0LmR1cmF0aW9uTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5udWxsVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IG9iamVjdC5udWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTlVMTF9WQUxVRVwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5zdHJpbmdWYWx1ZSA9IG1lc3NhZ2Uuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwic3RyaW5nVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW50ZWdlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludGVnZXJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludGVnZXJWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmludGVnZXJWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludGVnZXJWYWx1ZSkgOiBtZXNzYWdlLmludGVnZXJWYWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmludGVnZXJWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pbnRlZ2VyVmFsdWUpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaW50ZWdlclZhbHVlLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnRlZ2VyVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaW50ZWdlclZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImludGVnZXJWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kZWNpbWFsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVjaW1hbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuZGVjaW1hbFZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRlY2ltYWxWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5kZWNpbWFsVmFsdWUpIDogbWVzc2FnZS5kZWNpbWFsVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGVjaW1hbFZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBlcmNlbnRWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwZXJjZW50VmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5wZXJjZW50VmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UucGVyY2VudFZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLnBlcmNlbnRWYWx1ZSkgOiBtZXNzYWdlLnBlcmNlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJwZXJjZW50VmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJvb2xlYW5WYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJvb2xlYW5WYWx1ZSA9IG1lc3NhZ2UuYm9vbGVhblZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImJvb2xlYW5WYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXBNcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aW1lc3RhbXBNc1wiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnRpbWVzdGFtcE1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS50aW1lc3RhbXBNcykgOiBtZXNzYWdlLnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudGltZXN0YW1wTXMpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudGltZXN0YW1wTXMubG93ID4+PiAwLCBtZXNzYWdlLnRpbWVzdGFtcE1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInRpbWVzdGFtcE1zXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGVWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRlVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kYXRlVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRlVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kYXRlVmFsdWUpIDogbWVzc2FnZS5kYXRlVmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRlVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGF0ZVZhbHVlKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRhdGVWYWx1ZS5sb3cgPj4+IDAsIG1lc3NhZ2UuZGF0ZVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmRhdGVWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkYXRlVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF5RHVyYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF5RHVyYXRpb25cIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5kYXlEdXJhdGlvbiA9IG1lc3NhZ2UuZGF5RHVyYXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGF5RHVyYXRpb25cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb25ldGFyeVZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QubW9uZXRhcnlWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5tb25ldGFyeVZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLm1vbmV0YXJ5VmFsdWUpIDogbWVzc2FnZS5tb25ldGFyeVZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIm1vbmV0YXJ5VmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkdXJhdGlvbk1zXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZHVyYXRpb25NcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmR1cmF0aW9uTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kdXJhdGlvbk1zKSA6IG1lc3NhZ2UuZHVyYXRpb25NcztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmR1cmF0aW9uTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZHVyYXRpb25NcykgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kdXJhdGlvbk1zLmxvdyA+Pj4gMCwgbWVzc2FnZS5kdXJhdGlvbk1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmR1cmF0aW9uTXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZHVyYXRpb25Nc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QubnVsbFZhbHVlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UubnVsbFZhbHVlIDogJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gOiBtZXNzYWdlLm51bGxWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJudWxsVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlNjYWxhclwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2NhbGFyO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQXJyYXkyKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkyLnByb3RvdHlwZS52YWx1ZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBBcnJheTIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Mihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLnZhbHVlc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BcnJheSgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkyLmlzQXJyYXkobWVzc2FnZS52YWx1ZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci52ZXJpZnkobWVzc2FnZS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BcnJheSgpO1xuICAgICAgICAgIGlmIChvYmplY3QudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5Mi5pc0FycmF5KG9iamVjdC52YWx1ZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQXJyYXkudmFsdWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5BcnJheS52YWx1ZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZnJvbU9iamVjdChvYmplY3QudmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudG9PYmplY3QobWVzc2FnZS52YWx1ZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQXJyYXlcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFycmF5MjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkF4aXNUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJBeGlzVW5zcGVjaWZpZWRcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiQXhpc0xpbmVhclwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJBeGlzTG9nYXJpdGhtaWNcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiQXhpc0RhdGVUaW1lXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIkF4aXNDYXRlZ29yeVwiXSA9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5EYXNoU3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkRhc2hTdHlsZVVuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlNvbGlkXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlNob3J0RGFzaFwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJTaG9ydERvdFwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJTaG9ydERhc2hEb3RcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiU2hvcnREYXNoRG90RG90XCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIkRvdFwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJEYXNoXCJdID0gNztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIkxvbmdEYXNoXCJdID0gODtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkRhc2hEb3RcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIkxvbmdEYXNoRG90XCJdID0gMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiTG9uZ0Rhc2hEb3REb3RcIl0gPSAxMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBlcG9jaF9wcm90bztcbiAgICB9KCk7XG4gICAgJHJvb3QuZ29vZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ29vZ2xlID0ge307XG4gICAgICBnb29nbGUucHJvdG9idWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3RvYnVmID0ge307XG4gICAgICAgIHByb3RvYnVmLlN0cnVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIFN0cnVjdChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBTdHJ1Y3QucHJvdG90eXBlLmZpZWxkcyA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICAgIFN0cnVjdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3QocHJvcGVydGllcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImZpZWxkc1wiKSlcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICkuZm9yaygpLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICkuc3RyaW5nKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5lbmNvZGUobWVzc2FnZS5maWVsZHNba2V5c1tpXV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCkubGRlbGltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0KCksIGtleSwgdmFsdWU7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICBrZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcyID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZzIgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcyICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZmllbGRzXCIpKSB7XG4gICAgICAgICAgICAgIGlmICghJHV0aWwuaXNPYmplY3QobWVzc2FnZS5maWVsZHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhtZXNzYWdlLmZpZWxkcyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnZlcmlmeShtZXNzYWdlLmZpZWxkc1trZXlbaV1dKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJmaWVsZHMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdClcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZmllbGRzKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZpZWxkcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdC5maWVsZHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5maWVsZHNba2V5c1tpXV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkc1trZXlzW2ldXSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC5maWVsZHNba2V5c1tpXV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2JqZWN0cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICBvYmplY3QuZmllbGRzID0ge307XG4gICAgICAgICAgICB2YXIga2V5czI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgJiYgKGtleXMyID0gT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMyLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgIG9iamVjdC5maWVsZHNba2V5czJbal1dID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnRvT2JqZWN0KG1lc3NhZ2UuZmllbGRzW2tleXMyW2pdXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZ29vZ2xlLnByb3RvYnVmLlN0cnVjdFwiO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFN0cnVjdDtcbiAgICAgICAgfSgpO1xuICAgICAgICBwcm90b2J1Zi5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIFZhbHVlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLm51bGxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLm51bWJlclZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5ib29sVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5zdHJ1Y3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLmxpc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsdWUucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJudWxsVmFsdWVcIiwgXCJudW1iZXJWYWx1ZVwiLCBcInN0cmluZ1ZhbHVlXCIsIFwiYm9vbFZhbHVlXCIsIFwic3RydWN0VmFsdWVcIiwgXCJsaXN0VmFsdWVcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVmFsdWUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUocHJvcGVydGllcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibnVsbFZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICApLmludDMyKG1lc3NhZ2UubnVsbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJudW1iZXJWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAgIDE3XG4gICAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubnVtYmVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInN0cmluZ1ZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5zdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJvb2xWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLmJvb2xWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJ1Y3RWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RydWN0VmFsdWVcIikpXG4gICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZW5jb2RlKG1lc3NhZ2Uuc3RydWN0VmFsdWUsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICA0MlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5saXN0VmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImxpc3RWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS5lbmNvZGUobWVzc2FnZS5saXN0VmFsdWUsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICA1MFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1iZXJWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmJvb2xWYWx1ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cnVjdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5saXN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxWYWx1ZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udW1iZXJWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJudW1iZXJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UubnVtYmVyVmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyVmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdWYWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmtpbmQgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwia2luZDogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ib29sVmFsdWUgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xWYWx1ZTogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RydWN0VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RydWN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QudmVyaWZ5KG1lc3NhZ2Uuc3RydWN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cnVjdFZhbHVlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaXN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmVyaWZ5KG1lc3NhZ2UubGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJsaXN0VmFsdWUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUpXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lm51bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm51bGxWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSBvYmplY3QubnVsbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiTlVMTF9WQUxVRVwiOlxuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5udW1iZXJWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICBtZXNzYWdlLm51bWJlclZhbHVlID0gTnVtYmVyKG9iamVjdC5udW1iZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnN0cmluZ1ZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSBTdHJpbmcob2JqZWN0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYm9vbFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuYm9vbFZhbHVlID0gQm9vbGVhbihvYmplY3QuYm9vbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RydWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJ1Y3RWYWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnN0cnVjdFZhbHVlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RydWN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0LmZyb21PYmplY3Qob2JqZWN0LnN0cnVjdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubGlzdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubGlzdFZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuVmFsdWUubGlzdFZhbHVlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UubGlzdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC5saXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3QubnVsbFZhbHVlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UubnVsbFZhbHVlIDogJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gOiBtZXNzYWdlLm51bGxWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJudWxsVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bWJlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5udW1iZXJWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5udW1iZXJWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5udW1iZXJWYWx1ZSkgOiBtZXNzYWdlLm51bWJlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcIm51bWJlclZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nVmFsdWUgPSBtZXNzYWdlLnN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcInN0cmluZ1ZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5ib29sVmFsdWUgPSBtZXNzYWdlLmJvb2xWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJib29sVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cnVjdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cnVjdFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5zdHJ1Y3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QudG9PYmplY3QobWVzc2FnZS5zdHJ1Y3RWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwic3RydWN0VmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaXN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0Lmxpc3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudG9PYmplY3QobWVzc2FnZS5saXN0VmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcImxpc3RWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuVmFsdWVcIjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBWYWx1ZTtcbiAgICAgICAgfSgpO1xuICAgICAgICBwcm90b2J1Zi5OdWxsVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJOVUxMX1ZBTFVFXCJdID0gMDtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLkxpc3RWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIExpc3RWYWx1ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnZhbHVlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgTGlzdFZhbHVlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RWYWx1ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZW5jb2RlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzLnB1c2goJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpKSB7XG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnZhbHVlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnZlcmlmeShtZXNzYWdlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUpXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlcykge1xuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnZhbHVlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmFsdWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXNbaV0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZnJvbU9iamVjdChvYmplY3QudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWVzID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVzW2pdID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gTGlzdFZhbHVlO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBwcm90b2J1ZjtcbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBnb29nbGU7XG4gICAgfSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9ICRyb290O1xuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlcXVpcmVfY29tbW9uKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/common.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/table_def.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@epochlab/epoch-protos/dist/table_def.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\n\n// node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\") (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n      else (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n      if (typeof Float64Array !== \"undefined\") (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n      else (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length; )\n          buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n      }\n      return this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// src/table_def.js\nvar require_table_def = __commonJS({\n  \"src/table_def.js\"(exports2, module2) {\n    var $protobuf = require_minimal2();\n    var $Reader = $protobuf.Reader;\n    var $Writer = $protobuf.Writer;\n    var $util = $protobuf.util;\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.epoch_proto = function() {\n      var epoch_proto = {};\n      epoch_proto.ColumnDef = function() {\n        function ColumnDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        ColumnDef.prototype.id = \"\";\n        ColumnDef.prototype.name = \"\";\n        ColumnDef.prototype.type = 0;\n        ColumnDef.create = function create(properties) {\n          return new ColumnDef(properties);\n        };\n        ColumnDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.id);\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.name);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          return writer;\n        };\n        ColumnDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        ColumnDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.ColumnDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.id = reader.string();\n                break;\n              }\n              case 2: {\n                message.name = reader.string();\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ColumnDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        ColumnDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.id != null && message.hasOwnProperty(\"id\")) {\n            if (!$util.isString(message.id))\n              return \"id: string expected\";\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n                break;\n            }\n          return null;\n        };\n        ColumnDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.ColumnDef)\n            return object;\n          var message = new $root.epoch_proto.ColumnDef();\n          if (object.id != null)\n            message.id = String(object.id);\n          if (object.name != null)\n            message.name = String(object.name);\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"TypeUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"TypeString\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"TypeInteger\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"TypeDecimal\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"TypePercent\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"TypeBoolean\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"TypeDateTime\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"TypeDate\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"TypeDayDuration\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"TypeMonetary\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"TypeDuration\":\n            case 10:\n              message.type = 10;\n              break;\n          }\n          return message;\n        };\n        ColumnDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.id = \"\";\n            object.name = \"\";\n            object.type = options.enums === String ? \"TypeUnspecified\" : 0;\n          }\n          if (message.id != null && message.hasOwnProperty(\"id\"))\n            object.id = message.id;\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioType[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioType[message.type] : message.type;\n          return object;\n        };\n        ColumnDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        ColumnDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.ColumnDef\";\n        };\n        return ColumnDef;\n      }();\n      epoch_proto.TableRow = function() {\n        function TableRow(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TableRow.prototype.values = $util.emptyArray;\n        TableRow.create = function create(properties) {\n          return new TableRow(properties);\n        };\n        TableRow.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        TableRow.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TableRow.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TableRow();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TableRow.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TableRow.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        TableRow.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TableRow)\n            return object;\n          var message = new $root.epoch_proto.TableRow();\n          if (object.values) {\n            if (!Array.isArray(object.values))\n              throw TypeError(\".epoch_proto.TableRow.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.TableRow.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        TableRow.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        TableRow.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TableRow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TableRow\";\n        };\n        return TableRow;\n      }();\n      epoch_proto.TableData = function() {\n        function TableData(properties) {\n          this.rows = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TableData.prototype.rows = $util.emptyArray;\n        TableData.create = function create(properties) {\n          return new TableData(properties);\n        };\n        TableData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.rows != null && message.rows.length)\n            for (var i = 0; i < message.rows.length; ++i)\n              $root.epoch_proto.TableRow.encode(message.rows[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        TableData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TableData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TableData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.rows && message.rows.length))\n                  message.rows = [];\n                message.rows.push($root.epoch_proto.TableRow.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TableData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TableData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.rows != null && message.hasOwnProperty(\"rows\")) {\n            if (!Array.isArray(message.rows))\n              return \"rows: array expected\";\n            for (var i = 0; i < message.rows.length; ++i) {\n              var error = $root.epoch_proto.TableRow.verify(message.rows[i]);\n              if (error)\n                return \"rows.\" + error;\n            }\n          }\n          return null;\n        };\n        TableData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TableData)\n            return object;\n          var message = new $root.epoch_proto.TableData();\n          if (object.rows) {\n            if (!Array.isArray(object.rows))\n              throw TypeError(\".epoch_proto.TableData.rows: array expected\");\n            message.rows = [];\n            for (var i = 0; i < object.rows.length; ++i) {\n              if (typeof object.rows[i] !== \"object\")\n                throw TypeError(\".epoch_proto.TableData.rows: object expected\");\n              message.rows[i] = $root.epoch_proto.TableRow.fromObject(object.rows[i]);\n            }\n          }\n          return message;\n        };\n        TableData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.rows = [];\n          if (message.rows && message.rows.length) {\n            object.rows = [];\n            for (var j = 0; j < message.rows.length; ++j)\n              object.rows[j] = $root.epoch_proto.TableRow.toObject(message.rows[j], options);\n          }\n          return object;\n        };\n        TableData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TableData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TableData\";\n        };\n        return TableData;\n      }();\n      epoch_proto.Table = function() {\n        function Table(properties) {\n          this.columns = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Table.prototype.type = 0;\n        Table.prototype.category = \"\";\n        Table.prototype.title = \"\";\n        Table.prototype.columns = $util.emptyArray;\n        Table.prototype.data = null;\n        Table.create = function create(properties) {\n          return new Table(properties);\n        };\n        Table.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.category);\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).string(message.title);\n          if (message.columns != null && message.columns.length)\n            for (var i = 0; i < message.columns.length; ++i)\n              $root.epoch_proto.ColumnDef.encode(message.columns[i], writer.uint32(\n                /* id 4, wireType 2 =*/\n                34\n              ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.TableData.encode(message.data, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          return writer;\n        };\n        Table.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Table.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Table();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.category = reader.string();\n                break;\n              }\n              case 3: {\n                message.title = reader.string();\n                break;\n              }\n              case 4: {\n                if (!(message.columns && message.columns.length))\n                  message.columns = [];\n                message.columns.push($root.epoch_proto.ColumnDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 5: {\n                message.data = $root.epoch_proto.TableData.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Table.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Table.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.columns != null && message.hasOwnProperty(\"columns\")) {\n            if (!Array.isArray(message.columns))\n              return \"columns: array expected\";\n            for (var i = 0; i < message.columns.length; ++i) {\n              var error = $root.epoch_proto.ColumnDef.verify(message.columns[i]);\n              if (error)\n                return \"columns.\" + error;\n            }\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.TableData.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          return null;\n        };\n        Table.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Table)\n            return object;\n          var message = new $root.epoch_proto.Table();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.columns) {\n            if (!Array.isArray(object.columns))\n              throw TypeError(\".epoch_proto.Table.columns: array expected\");\n            message.columns = [];\n            for (var i = 0; i < object.columns.length; ++i) {\n              if (typeof object.columns[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Table.columns: object expected\");\n              message.columns[i] = $root.epoch_proto.ColumnDef.fromObject(object.columns[i]);\n            }\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.Table.data: object expected\");\n            message.data = $root.epoch_proto.TableData.fromObject(object.data);\n          }\n          return message;\n        };\n        Table.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.columns = [];\n          if (options.defaults) {\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n            object.title = \"\";\n            object.data = null;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.columns && message.columns.length) {\n            object.columns = [];\n            for (var j = 0; j < message.columns.length; ++j)\n              object.columns[j] = $root.epoch_proto.ColumnDef.toObject(message.columns[j], options);\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.TableData.toObject(message.data, options);\n          return object;\n        };\n        Table.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Table.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Table\";\n        };\n        return Table;\n      }();\n      epoch_proto.CardData = function() {\n        function CardData(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        CardData.prototype.title = \"\";\n        CardData.prototype.value = null;\n        CardData.prototype.type = 0;\n        CardData.prototype.group = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        CardData.create = function create(properties) {\n          return new CardData(properties);\n        };\n        CardData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.title);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            $root.epoch_proto.Scalar.encode(message.value, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          if (message.group != null && Object.hasOwnProperty.call(message, \"group\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint64(message.group);\n          return writer;\n        };\n        CardData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        CardData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.CardData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.title = reader.string();\n                break;\n              }\n              case 2: {\n                message.value = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              case 4: {\n                message.group = reader.uint64();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        CardData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        CardData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.value);\n            if (error)\n              return \"value.\" + error;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n                break;\n            }\n          if (message.group != null && message.hasOwnProperty(\"group\")) {\n            if (!$util.isInteger(message.group) && !(message.group && $util.isInteger(message.group.low) && $util.isInteger(message.group.high)))\n              return \"group: integer|Long expected\";\n          }\n          return null;\n        };\n        CardData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.CardData)\n            return object;\n          var message = new $root.epoch_proto.CardData();\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.value != null) {\n            if (typeof object.value !== \"object\")\n              throw TypeError(\".epoch_proto.CardData.value: object expected\");\n            message.value = $root.epoch_proto.Scalar.fromObject(object.value);\n          }\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"TypeUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"TypeString\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"TypeInteger\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"TypeDecimal\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"TypePercent\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"TypeBoolean\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"TypeDateTime\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"TypeDate\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"TypeDayDuration\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"TypeMonetary\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"TypeDuration\":\n            case 10:\n              message.type = 10;\n              break;\n          }\n          if (object.group != null) {\n            if ($util.Long)\n              (message.group = $util.Long.fromValue(object.group)).unsigned = true;\n            else if (typeof object.group === \"string\")\n              message.group = parseInt(object.group, 10);\n            else if (typeof object.group === \"number\")\n              message.group = object.group;\n            else if (typeof object.group === \"object\")\n              message.group = new $util.LongBits(object.group.low >>> 0, object.group.high >>> 0).toNumber(true);\n          }\n          return message;\n        };\n        CardData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.title = \"\";\n            object.value = null;\n            object.type = options.enums === String ? \"TypeUnspecified\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.group = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.group = options.longs === String ? \"0\" : 0;\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = $root.epoch_proto.Scalar.toObject(message.value, options);\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioType[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioType[message.type] : message.type;\n          if (message.group != null && message.hasOwnProperty(\"group\"))\n            if (typeof message.group === \"number\")\n              object.group = options.longs === String ? String(message.group) : message.group;\n            else\n              object.group = options.longs === String ? $util.Long.prototype.toString.call(message.group) : options.longs === Number ? new $util.LongBits(message.group.low >>> 0, message.group.high >>> 0).toNumber(true) : message.group;\n          return object;\n        };\n        CardData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        CardData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.CardData\";\n        };\n        return CardData;\n      }();\n      epoch_proto.CardDef = function() {\n        function CardDef(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        CardDef.prototype.type = 0;\n        CardDef.prototype.category = \"\";\n        CardDef.prototype.data = $util.emptyArray;\n        CardDef.prototype.groupSize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        CardDef.create = function create(properties) {\n          return new CardDef(properties);\n        };\n        CardDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.category);\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.CardData.encode(message.data[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.groupSize != null && Object.hasOwnProperty.call(message, \"groupSize\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint64(message.groupSize);\n          return writer;\n        };\n        CardDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        CardDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.CardDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.category = reader.string();\n                break;\n              }\n              case 3: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.CardData.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.groupSize = reader.uint64();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        CardDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        CardDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.CardData.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          if (message.groupSize != null && message.hasOwnProperty(\"groupSize\")) {\n            if (!$util.isInteger(message.groupSize) && !(message.groupSize && $util.isInteger(message.groupSize.low) && $util.isInteger(message.groupSize.high)))\n              return \"groupSize: integer|Long expected\";\n          }\n          return null;\n        };\n        CardDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.CardDef)\n            return object;\n          var message = new $root.epoch_proto.CardDef();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.CardDef.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.CardDef.data: object expected\");\n              message.data[i] = $root.epoch_proto.CardData.fromObject(object.data[i]);\n            }\n          }\n          if (object.groupSize != null) {\n            if ($util.Long)\n              (message.groupSize = $util.Long.fromValue(object.groupSize)).unsigned = true;\n            else if (typeof object.groupSize === \"string\")\n              message.groupSize = parseInt(object.groupSize, 10);\n            else if (typeof object.groupSize === \"number\")\n              message.groupSize = object.groupSize;\n            else if (typeof object.groupSize === \"object\")\n              message.groupSize = new $util.LongBits(object.groupSize.low >>> 0, object.groupSize.high >>> 0).toNumber(true);\n          }\n          return message;\n        };\n        CardDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults) {\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.groupSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.groupSize = options.longs === String ? \"0\" : 0;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.CardData.toObject(message.data[j], options);\n          }\n          if (message.groupSize != null && message.hasOwnProperty(\"groupSize\"))\n            if (typeof message.groupSize === \"number\")\n              object.groupSize = options.longs === String ? String(message.groupSize) : message.groupSize;\n            else\n              object.groupSize = options.longs === String ? $util.Long.prototype.toString.call(message.groupSize) : options.longs === Number ? new $util.LongBits(message.groupSize.low >>> 0, message.groupSize.high >>> 0).toNumber(true) : message.groupSize;\n          return object;\n        };\n        CardDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        CardDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.CardDef\";\n        };\n        return CardDef;\n      }();\n      epoch_proto.EpochFolioDashboardWidget = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"WidgetUnspecified\"] = 0;\n        values[valuesById[1] = \"WidgetCard\"] = 1;\n        values[valuesById[2] = \"WidgetLines\"] = 2;\n        values[valuesById[3] = \"WidgetBar\"] = 3;\n        values[valuesById[4] = \"WidgetDataTable\"] = 4;\n        values[valuesById[5] = \"WidgetXRange\"] = 5;\n        values[valuesById[6] = \"WidgetHistogram\"] = 6;\n        values[valuesById[7] = \"WidgetPie\"] = 7;\n        values[valuesById[8] = \"WidgetHeatMap\"] = 8;\n        values[valuesById[9] = \"WidgetBoxPlot\"] = 9;\n        values[valuesById[10] = \"WidgetArea\"] = 10;\n        values[valuesById[11] = \"WidgetColumn\"] = 11;\n        return values;\n      }();\n      epoch_proto.EpochFolioType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"TypeUnspecified\"] = 0;\n        values[valuesById[1] = \"TypeString\"] = 1;\n        values[valuesById[2] = \"TypeInteger\"] = 2;\n        values[valuesById[3] = \"TypeDecimal\"] = 3;\n        values[valuesById[4] = \"TypePercent\"] = 4;\n        values[valuesById[5] = \"TypeBoolean\"] = 5;\n        values[valuesById[6] = \"TypeDateTime\"] = 6;\n        values[valuesById[7] = \"TypeDate\"] = 7;\n        values[valuesById[8] = \"TypeDayDuration\"] = 8;\n        values[valuesById[9] = \"TypeMonetary\"] = 9;\n        values[valuesById[10] = \"TypeDuration\"] = 10;\n        return values;\n      }();\n      epoch_proto.Scalar = function() {\n        function Scalar(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Scalar.prototype.stringValue = null;\n        Scalar.prototype.integerValue = null;\n        Scalar.prototype.decimalValue = null;\n        Scalar.prototype.percentValue = null;\n        Scalar.prototype.booleanValue = null;\n        Scalar.prototype.timestampMs = null;\n        Scalar.prototype.dateValue = null;\n        Scalar.prototype.dayDuration = null;\n        Scalar.prototype.monetaryValue = null;\n        Scalar.prototype.durationMs = null;\n        Scalar.prototype.nullValue = null;\n        var $oneOfFields;\n        Object.defineProperty(Scalar.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"integerValue\", \"decimalValue\", \"percentValue\", \"booleanValue\", \"timestampMs\", \"dateValue\", \"dayDuration\", \"monetaryValue\", \"durationMs\", \"nullValue\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Scalar.create = function create(properties) {\n          return new Scalar(properties);\n        };\n        Scalar.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.stringValue);\n          if (message.integerValue != null && Object.hasOwnProperty.call(message, \"integerValue\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.integerValue);\n          if (message.decimalValue != null && Object.hasOwnProperty.call(message, \"decimalValue\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.decimalValue);\n          if (message.percentValue != null && Object.hasOwnProperty.call(message, \"percentValue\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.percentValue);\n          if (message.booleanValue != null && Object.hasOwnProperty.call(message, \"booleanValue\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.booleanValue);\n          if (message.timestampMs != null && Object.hasOwnProperty.call(message, \"timestampMs\"))\n            writer.uint32(\n              /* id 6, wireType 0 =*/\n              48\n            ).int64(message.timestampMs);\n          if (message.dateValue != null && Object.hasOwnProperty.call(message, \"dateValue\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).int64(message.dateValue);\n          if (message.dayDuration != null && Object.hasOwnProperty.call(message, \"dayDuration\"))\n            writer.uint32(\n              /* id 8, wireType 0 =*/\n              64\n            ).int32(message.dayDuration);\n          if (message.monetaryValue != null && Object.hasOwnProperty.call(message, \"monetaryValue\"))\n            writer.uint32(\n              /* id 9, wireType 1 =*/\n              73\n            ).double(message.monetaryValue);\n          if (message.durationMs != null && Object.hasOwnProperty.call(message, \"durationMs\"))\n            writer.uint32(\n              /* id 10, wireType 0 =*/\n              80\n            ).int64(message.durationMs);\n          if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n            writer.uint32(\n              /* id 11, wireType 0 =*/\n              88\n            ).int32(message.nullValue);\n          return writer;\n        };\n        Scalar.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Scalar.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Scalar();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.stringValue = reader.string();\n                break;\n              }\n              case 2: {\n                message.integerValue = reader.int64();\n                break;\n              }\n              case 3: {\n                message.decimalValue = reader.double();\n                break;\n              }\n              case 4: {\n                message.percentValue = reader.double();\n                break;\n              }\n              case 5: {\n                message.booleanValue = reader.bool();\n                break;\n              }\n              case 6: {\n                message.timestampMs = reader.int64();\n                break;\n              }\n              case 7: {\n                message.dateValue = reader.int64();\n                break;\n              }\n              case 8: {\n                message.dayDuration = reader.int32();\n                break;\n              }\n              case 9: {\n                message.monetaryValue = reader.double();\n                break;\n              }\n              case 10: {\n                message.durationMs = reader.int64();\n                break;\n              }\n              case 11: {\n                message.nullValue = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Scalar.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Scalar.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties.value = 1;\n            if (!$util.isString(message.stringValue))\n              return \"stringValue: string expected\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high)))\n              return \"integerValue: integer|Long expected\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.decimalValue !== \"number\")\n              return \"decimalValue: number expected\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.percentValue !== \"number\")\n              return \"percentValue: number expected\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.booleanValue !== \"boolean\")\n              return \"booleanValue: boolean expected\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))\n              return \"timestampMs: integer|Long expected\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dateValue) && !(message.dateValue && $util.isInteger(message.dateValue.low) && $util.isInteger(message.dateValue.high)))\n              return \"dateValue: integer|Long expected\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dayDuration))\n              return \"dayDuration: integer expected\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.monetaryValue !== \"number\")\n              return \"monetaryValue: number expected\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))\n              return \"durationMs: integer|Long expected\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            switch (message.nullValue) {\n              default:\n                return \"nullValue: enum value expected\";\n              case 0:\n                break;\n            }\n          }\n          return null;\n        };\n        Scalar.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Scalar)\n            return object;\n          var message = new $root.epoch_proto.Scalar();\n          if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n          if (object.integerValue != null) {\n            if ($util.Long)\n              (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;\n            else if (typeof object.integerValue === \"string\")\n              message.integerValue = parseInt(object.integerValue, 10);\n            else if (typeof object.integerValue === \"number\")\n              message.integerValue = object.integerValue;\n            else if (typeof object.integerValue === \"object\")\n              message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();\n          }\n          if (object.decimalValue != null)\n            message.decimalValue = Number(object.decimalValue);\n          if (object.percentValue != null)\n            message.percentValue = Number(object.percentValue);\n          if (object.booleanValue != null)\n            message.booleanValue = Boolean(object.booleanValue);\n          if (object.timestampMs != null) {\n            if ($util.Long)\n              (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;\n            else if (typeof object.timestampMs === \"string\")\n              message.timestampMs = parseInt(object.timestampMs, 10);\n            else if (typeof object.timestampMs === \"number\")\n              message.timestampMs = object.timestampMs;\n            else if (typeof object.timestampMs === \"object\")\n              message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();\n          }\n          if (object.dateValue != null) {\n            if ($util.Long)\n              (message.dateValue = $util.Long.fromValue(object.dateValue)).unsigned = false;\n            else if (typeof object.dateValue === \"string\")\n              message.dateValue = parseInt(object.dateValue, 10);\n            else if (typeof object.dateValue === \"number\")\n              message.dateValue = object.dateValue;\n            else if (typeof object.dateValue === \"object\")\n              message.dateValue = new $util.LongBits(object.dateValue.low >>> 0, object.dateValue.high >>> 0).toNumber();\n          }\n          if (object.dayDuration != null)\n            message.dayDuration = object.dayDuration | 0;\n          if (object.monetaryValue != null)\n            message.monetaryValue = Number(object.monetaryValue);\n          if (object.durationMs != null) {\n            if ($util.Long)\n              (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = false;\n            else if (typeof object.durationMs === \"string\")\n              message.durationMs = parseInt(object.durationMs, 10);\n            else if (typeof object.durationMs === \"number\")\n              message.durationMs = object.durationMs;\n            else if (typeof object.durationMs === \"object\")\n              message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber();\n          }\n          switch (object.nullValue) {\n            default:\n              if (typeof object.nullValue === \"number\") {\n                message.nullValue = object.nullValue;\n                break;\n              }\n              break;\n            case \"NULL_VALUE\":\n            case 0:\n              message.nullValue = 0;\n              break;\n          }\n          return message;\n        };\n        Scalar.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n              object.value = \"stringValue\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (typeof message.integerValue === \"number\")\n              object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;\n            else\n              object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;\n            if (options.oneofs)\n              object.value = \"integerValue\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            object.decimalValue = options.json && !isFinite(message.decimalValue) ? String(message.decimalValue) : message.decimalValue;\n            if (options.oneofs)\n              object.value = \"decimalValue\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            object.percentValue = options.json && !isFinite(message.percentValue) ? String(message.percentValue) : message.percentValue;\n            if (options.oneofs)\n              object.value = \"percentValue\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            object.booleanValue = message.booleanValue;\n            if (options.oneofs)\n              object.value = \"booleanValue\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (typeof message.timestampMs === \"number\")\n              object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;\n            else\n              object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;\n            if (options.oneofs)\n              object.value = \"timestampMs\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (typeof message.dateValue === \"number\")\n              object.dateValue = options.longs === String ? String(message.dateValue) : message.dateValue;\n            else\n              object.dateValue = options.longs === String ? $util.Long.prototype.toString.call(message.dateValue) : options.longs === Number ? new $util.LongBits(message.dateValue.low >>> 0, message.dateValue.high >>> 0).toNumber() : message.dateValue;\n            if (options.oneofs)\n              object.value = \"dateValue\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            object.dayDuration = message.dayDuration;\n            if (options.oneofs)\n              object.value = \"dayDuration\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            object.monetaryValue = options.json && !isFinite(message.monetaryValue) ? String(message.monetaryValue) : message.monetaryValue;\n            if (options.oneofs)\n              object.value = \"monetaryValue\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (typeof message.durationMs === \"number\")\n              object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;\n            else\n              object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber() : message.durationMs;\n            if (options.oneofs)\n              object.value = \"durationMs\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n            if (options.oneofs)\n              object.value = \"nullValue\";\n          }\n          return object;\n        };\n        Scalar.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Scalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Scalar\";\n        };\n        return Scalar;\n      }();\n      epoch_proto.Array = function() {\n        function Array2(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Array2.prototype.values = $util.emptyArray;\n        Array2.create = function create(properties) {\n          return new Array2(properties);\n        };\n        Array2.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        Array2.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Array2.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Array();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Array2.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Array2.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array2.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        Array2.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Array)\n            return object;\n          var message = new $root.epoch_proto.Array();\n          if (object.values) {\n            if (!Array2.isArray(object.values))\n              throw TypeError(\".epoch_proto.Array.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Array.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        Array2.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        Array2.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Array2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Array\";\n        };\n        return Array2;\n      }();\n      epoch_proto.AxisType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"AxisUnspecified\"] = 0;\n        values[valuesById[1] = \"AxisLinear\"] = 1;\n        values[valuesById[2] = \"AxisLogarithmic\"] = 2;\n        values[valuesById[3] = \"AxisDateTime\"] = 3;\n        values[valuesById[4] = \"AxisCategory\"] = 4;\n        return values;\n      }();\n      epoch_proto.DashStyle = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"DashStyleUnspecified\"] = 0;\n        values[valuesById[1] = \"Solid\"] = 1;\n        values[valuesById[2] = \"ShortDash\"] = 2;\n        values[valuesById[3] = \"ShortDot\"] = 3;\n        values[valuesById[4] = \"ShortDashDot\"] = 4;\n        values[valuesById[5] = \"ShortDashDotDot\"] = 5;\n        values[valuesById[6] = \"Dot\"] = 6;\n        values[valuesById[7] = \"Dash\"] = 7;\n        values[valuesById[8] = \"LongDash\"] = 8;\n        values[valuesById[9] = \"DashDot\"] = 9;\n        values[valuesById[10] = \"LongDashDot\"] = 10;\n        values[valuesById[11] = \"LongDashDotDot\"] = 11;\n        return values;\n      }();\n      return epoch_proto;\n    }();\n    $root.google = function() {\n      var google = {};\n      google.protobuf = function() {\n        var protobuf = {};\n        protobuf.Struct = function() {\n          function Struct(properties) {\n            this.fields = {};\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Struct.prototype.fields = $util.emptyObject;\n          Struct.create = function create(properties) {\n            return new Struct(properties);\n          };\n          Struct.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.fields != null && Object.hasOwnProperty.call(message, \"fields\"))\n              for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {\n                writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork().uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).string(keys[i]);\n                $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(\n                  /* id 2, wireType 2 =*/\n                  18\n                ).fork()).ldelim().ldelim();\n              }\n            return writer;\n          };\n          Struct.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Struct.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (message.fields === $util.emptyObject)\n                    message.fields = {};\n                  var end2 = reader.uint32() + reader.pos;\n                  key = \"\";\n                  value = null;\n                  while (reader.pos < end2) {\n                    var tag2 = reader.uint32();\n                    switch (tag2 >>> 3) {\n                      case 1:\n                        key = reader.string();\n                        break;\n                      case 2:\n                        value = $root.google.protobuf.Value.decode(reader, reader.uint32());\n                        break;\n                      default:\n                        reader.skipType(tag2 & 7);\n                        break;\n                    }\n                  }\n                  message.fields[key] = value;\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Struct.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Struct.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.fields != null && message.hasOwnProperty(\"fields\")) {\n              if (!$util.isObject(message.fields))\n                return \"fields: object expected\";\n              var key = Object.keys(message.fields);\n              for (var i = 0; i < key.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);\n                if (error)\n                  return \"fields.\" + error;\n              }\n            }\n            return null;\n          };\n          Struct.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Struct)\n              return object;\n            var message = new $root.google.protobuf.Struct();\n            if (object.fields) {\n              if (typeof object.fields !== \"object\")\n                throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n              message.fields = {};\n              for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {\n                if (typeof object.fields[keys[i]] !== \"object\")\n                  throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n                message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);\n              }\n            }\n            return message;\n          };\n          Struct.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n              object.fields = {};\n            var keys2;\n            if (message.fields && (keys2 = Object.keys(message.fields)).length) {\n              object.fields = {};\n              for (var j = 0; j < keys2.length; ++j)\n                object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);\n            }\n            return object;\n          };\n          Struct.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Struct\";\n          };\n          return Struct;\n        }();\n        protobuf.Value = function() {\n          function Value(properties) {\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Value.prototype.nullValue = null;\n          Value.prototype.numberValue = null;\n          Value.prototype.stringValue = null;\n          Value.prototype.boolValue = null;\n          Value.prototype.structValue = null;\n          Value.prototype.listValue = null;\n          var $oneOfFields;\n          Object.defineProperty(Value.prototype, \"kind\", {\n            get: $util.oneOfGetter($oneOfFields = [\"nullValue\", \"numberValue\", \"stringValue\", \"boolValue\", \"structValue\", \"listValue\"]),\n            set: $util.oneOfSetter($oneOfFields)\n          });\n          Value.create = function create(properties) {\n            return new Value(properties);\n          };\n          Value.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n              writer.uint32(\n                /* id 1, wireType 0 =*/\n                8\n              ).int32(message.nullValue);\n            if (message.numberValue != null && Object.hasOwnProperty.call(message, \"numberValue\"))\n              writer.uint32(\n                /* id 2, wireType 1 =*/\n                17\n              ).double(message.numberValue);\n            if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.stringValue);\n            if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n              writer.uint32(\n                /* id 4, wireType 0 =*/\n                32\n              ).bool(message.boolValue);\n            if (message.structValue != null && Object.hasOwnProperty.call(message, \"structValue\"))\n              $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n            if (message.listValue != null && Object.hasOwnProperty.call(message, \"listValue\"))\n              $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(\n                /* id 6, wireType 2 =*/\n                50\n              ).fork()).ldelim();\n            return writer;\n          };\n          Value.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Value.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  message.nullValue = reader.int32();\n                  break;\n                }\n                case 2: {\n                  message.numberValue = reader.double();\n                  break;\n                }\n                case 3: {\n                  message.stringValue = reader.string();\n                  break;\n                }\n                case 4: {\n                  message.boolValue = reader.bool();\n                  break;\n                }\n                case 5: {\n                  message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());\n                  break;\n                }\n                case 6: {\n                  message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Value.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Value.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            var properties = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              properties.kind = 1;\n              switch (message.nullValue) {\n                default:\n                  return \"nullValue: enum value expected\";\n                case 0:\n                  break;\n              }\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.numberValue !== \"number\")\n                return \"numberValue: number expected\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.boolValue !== \"boolean\")\n                return \"boolValue: boolean expected\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.Struct.verify(message.structValue);\n                if (error)\n                  return \"structValue.\" + error;\n              }\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.ListValue.verify(message.listValue);\n                if (error)\n                  return \"listValue.\" + error;\n              }\n            }\n            return null;\n          };\n          Value.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Value)\n              return object;\n            var message = new $root.google.protobuf.Value();\n            switch (object.nullValue) {\n              default:\n                if (typeof object.nullValue === \"number\") {\n                  message.nullValue = object.nullValue;\n                  break;\n                }\n                break;\n              case \"NULL_VALUE\":\n              case 0:\n                message.nullValue = 0;\n                break;\n            }\n            if (object.numberValue != null)\n              message.numberValue = Number(object.numberValue);\n            if (object.stringValue != null)\n              message.stringValue = String(object.stringValue);\n            if (object.boolValue != null)\n              message.boolValue = Boolean(object.boolValue);\n            if (object.structValue != null) {\n              if (typeof object.structValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.structValue: object expected\");\n              message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);\n            }\n            if (object.listValue != null) {\n              if (typeof object.listValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.listValue: object expected\");\n              message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);\n            }\n            return message;\n          };\n          Value.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n              if (options.oneofs)\n                object.kind = \"nullValue\";\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;\n              if (options.oneofs)\n                object.kind = \"numberValue\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              object.stringValue = message.stringValue;\n              if (options.oneofs)\n                object.kind = \"stringValue\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              object.boolValue = message.boolValue;\n              if (options.oneofs)\n                object.kind = \"boolValue\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);\n              if (options.oneofs)\n                object.kind = \"structValue\";\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);\n              if (options.oneofs)\n                object.kind = \"listValue\";\n            }\n            return object;\n          };\n          Value.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Value\";\n          };\n          return Value;\n        }();\n        protobuf.NullValue = function() {\n          var valuesById = {}, values = Object.create(valuesById);\n          values[valuesById[0] = \"NULL_VALUE\"] = 0;\n          return values;\n        }();\n        protobuf.ListValue = function() {\n          function ListValue(properties) {\n            this.values = [];\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          ListValue.prototype.values = $util.emptyArray;\n          ListValue.create = function create(properties) {\n            return new ListValue(properties);\n          };\n          ListValue.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.values != null && message.values.length)\n              for (var i = 0; i < message.values.length; ++i)\n                $root.google.protobuf.Value.encode(message.values[i], writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork()).ldelim();\n            return writer;\n          };\n          ListValue.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          ListValue.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (!(message.values && message.values.length))\n                    message.values = [];\n                  message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          ListValue.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          ListValue.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.values != null && message.hasOwnProperty(\"values\")) {\n              if (!Array.isArray(message.values))\n                return \"values: array expected\";\n              for (var i = 0; i < message.values.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.values[i]);\n                if (error)\n                  return \"values.\" + error;\n              }\n            }\n            return null;\n          };\n          ListValue.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.ListValue)\n              return object;\n            var message = new $root.google.protobuf.ListValue();\n            if (object.values) {\n              if (!Array.isArray(object.values))\n                throw TypeError(\".google.protobuf.ListValue.values: array expected\");\n              message.values = [];\n              for (var i = 0; i < object.values.length; ++i) {\n                if (typeof object.values[i] !== \"object\")\n                  throw TypeError(\".google.protobuf.ListValue.values: object expected\");\n                message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);\n              }\n            }\n            return message;\n          };\n          ListValue.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n              object.values = [];\n            if (message.values && message.values.length) {\n              object.values = [];\n              for (var j = 0; j < message.values.length; ++j)\n                object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);\n            }\n            return object;\n          };\n          ListValue.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.ListValue\";\n          };\n          return ListValue;\n        }();\n        return protobuf;\n      }();\n      return google;\n    }();\n    module2.exports = $root;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (require_table_def());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvdGFibGVfZGVmLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUMxRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBTSxvQkFBb0IscUJBQU0sSUFBSSxxQkFBTSxZQUFZLHFCQUFNLHFCQUFxQixxQkFBTTtBQUN4SCxpQ0FBaUMscUJBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsaUJBQWlCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFlLG1CQUFtQixFQUFDIiwic291cmNlcyI6WyIvaG9tZS9hZGVzb2xhL0Vwb2NoTGFiL0Vwb2NoRGFzaGJvYXJkL2pzL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvdGFibGVfZGVmLmVzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2NvbW1vbkpTID0gKGNiLCBtb2QyKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QyIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kMiA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kMiksIG1vZDIuZXhwb3J0cztcbn07XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanNcbnZhciByZXF1aXJlX2FzcHJvbWlzZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9hc3Byb21pc2UvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGFzUHJvbWlzZTtcbiAgICBmdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eCkge1xuICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksIG9mZnNldCA9IDAsIGluZGV4ID0gMiwgcGVuZGluZyA9IHRydWU7XG4gICAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVycikge1xuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcGFyYW1zMiA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksIG9mZnNldDIgPSAwO1xuICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0MiA8IHBhcmFtczIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHBhcmFtczJbb2Zmc2V0MisrXSA9IGFyZ3VtZW50c1tvZmZzZXQyXTtcbiAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanNcbnZhciByZXF1aXJlX2Jhc2U2NCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBiYXNlNjQgPSBleHBvcnRzMjtcbiAgICBiYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xuICAgICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKCFwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIHZhciBuID0gMDtcbiAgICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcbiAgICAgICAgKytuO1xuICAgICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcbiAgICB9O1xuICAgIHZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xuICAgIHZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IClcbiAgICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcbiAgICB2YXIgaTtcbiAgICBiYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIHBhcnRzID0gbnVsbCwgY2h1bmsgPSBbXTtcbiAgICAgIHZhciBpMiA9IDAsIGogPSAwLCB0O1xuICAgICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xuICAgICAgICBzd2l0Y2ggKGopIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFtiID4+IDJdO1xuICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcbiAgICAgICAgICAgIGogPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbdCB8IGIgPj4gNF07XG4gICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICAgIGogPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbdCB8IGIgPj4gNl07XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFtiICYgNjNdO1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPiA4MTkxKSB7XG4gICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcbiAgICAgICAgICBpMiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChqKSB7XG4gICAgICAgIGNodW5rW2kyKytdID0gYjY0W3RdO1xuICAgICAgICBjaHVua1tpMisrXSA9IDYxO1xuICAgICAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgICBjaHVua1tpMisrXSA9IDYxO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgIGlmIChpMilcbiAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpMikpKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkyKSk7XG4gICAgfTtcbiAgICB2YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XG4gICAgYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICB2YXIgaiA9IDAsIHQ7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgc3RyaW5nLmxlbmd0aDsgKSB7XG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaTIrKyk7XG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XG4gICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgaiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcbiAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgaiA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XG4gICAgICAgICAgICB0ID0gYztcbiAgICAgICAgICAgIGogPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuICAgIGJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcbiAgICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzXG52YXIgcmVxdWlyZV9ldmVudGVtaXR0ZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcbiAgICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xuICAgICAgICBmbixcbiAgICAgICAgY3R4OiBjdHggfHwgdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcbiAgICAgIGlmIChldnQgPT09IHZvaWQgMClcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGZuID09PSB2b2lkIDApXG4gICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKVxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXG4gICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xuICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICB2YXIgYXJncyA9IFtdLCBpID0gMTtcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyApXG4gICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IClcbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanNcbnZhciByZXF1aXJlX2Zsb2F0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xuICAgIGZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0czMpIHtcbiAgICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFstMF0pLCBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSwgbGUgPSBmOGJbM10gPT09IDEyODtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmMzJbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbMF07XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmMzJbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3NdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XG4gICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xuICAgICAgICAgIHJldHVybiBmMzJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICByZXR1cm4gZjMyWzBdO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcbiAgICAgIH0pKCk7XG4gICAgICBlbHNlIChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xuICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgdmFsID0gLXZhbDtcbiAgICAgICAgICBpZiAodmFsID09PSAwKVxuICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gKFxuICAgICAgICAgICAgICAvKiBwb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAvKiBuZWdhdGl2ZSAwICovXG4gICAgICAgICAgICAgIDIxNDc0ODM2NDhcbiAgICAgICAgICAgICksIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxuICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzNDAyODIzNDY2Mzg1Mjg4NmUyMilcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSBpZiAodmFsIDwgMTE3NTQ5NDM1MDgyMjI4NzVlLTU0KVxuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxNDAxMjk4NDY0MzI0ODE3ZS02MCkpID4+PiAwLCBidWYsIHBvcyk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xuICAgICAgICBleHBvcnRzMy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLCBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XG4gICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTUgPyBtYW50aXNzYSA/IE5hTiA6IHNpZ24gKiBJbmZpbml0eSA6IGV4cG9uZW50ID09PSAwID8gc2lnbiAqIDE0MDEyOTg0NjQzMjQ4MTdlLTYwICogbWFudGlzc2EgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLCBsZSA9IGY4Yls3XSA9PT0gMTI4O1xuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBmNjRbMF0gPSB2YWw7XG4gICAgICAgICAgYnVmW3Bvc10gPSBmOGJbMF07XG4gICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcbiAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcbiAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XG4gICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGY2NFswXSA9IHZhbDtcbiAgICAgICAgICBidWZbcG9zXSA9IGY4Yls3XTtcbiAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XG4gICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcbiAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XG4gICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcbiAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XG4gICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xuICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcbiAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XG4gICAgICAgICAgcmV0dXJuIGY2NFswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcbiAgICAgICAgICBmOGJbN10gPSBidWZbcG9zXTtcbiAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XG4gICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xuICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XG4gICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcbiAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XG4gICAgICAgICAgcmV0dXJuIGY2NFswXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XG4gICAgICB9KSgpO1xuICAgICAgZWxzZSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XG4gICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICB2YWwgPSAtdmFsO1xuICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gKFxuICAgICAgICAgICAgICAvKiBwb3NpdGl2ZSAqL1xuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAvKiBuZWdhdGl2ZSAwICovXG4gICAgICAgICAgICAgIDIxNDc0ODM2NDhcbiAgICAgICAgICAgICksIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMTc5NzY5MzEzNDg2MjMxNTdlMjkyKSB7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWFudGlzc2E7XG4gICAgICAgICAgICBpZiAodmFsIDwgMjIyNTA3Mzg1ODUwNzIwMTRlLTMyNCkge1xuICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcbiAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xuICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XG4gICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcbiAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLCBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NywgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcbiAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDcgPyBtYW50aXNzYSA/IE5hTiA6IHNpZ24gKiBJbmZpbml0eSA6IGV4cG9uZW50ID09PSAwID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcbiAgICAgICAgZXhwb3J0czMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIGV4cG9ydHMzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAxXSA9IHZhbCA+Pj4gOCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAyXSA9IHZhbCA+Pj4gMTYgJiAyNTU7XG4gICAgICBidWZbcG9zICsgM10gPSB2YWwgPj4+IDI0O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCA+Pj4gMjQ7XG4gICAgICBidWZbcG9zICsgMV0gPSB2YWwgPj4+IDE2ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDJdID0gdmFsID4+PiA4ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDNdID0gdmFsICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XG4gICAgICByZXR1cm4gKGJ1Zltwb3NdIHwgYnVmW3BvcyArIDFdIDw8IDggfCBidWZbcG9zICsgMl0gPDwgMTYgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XG4gICAgICByZXR1cm4gKGJ1Zltwb3NdIDw8IDI0IHwgYnVmW3BvcyArIDFdIDw8IDE2IHwgYnVmW3BvcyArIDJdIDw8IDggfCBidWZbcG9zICsgM10pID4+PiAwO1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9pbnF1aXJlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XG4gICAgZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sIFwicmVcIikpKG1vZHVsZU5hbWUpO1xuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcbiAgICAgICAgICByZXR1cm4gbW9kO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanNcbnZhciByZXF1aXJlX3V0ZjggPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHV0ZjggPSBleHBvcnRzMjtcbiAgICB1dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xuICAgICAgdmFyIGxlbiA9IDAsIGMgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOClcbiAgICAgICAgICBsZW4gKz0gMTtcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgICAgbGVuICs9IDI7XG4gICAgICAgIGVsc2UgaWYgKChjICYgNjQ1MTIpID09PSA1NTI5NiAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgNjQ1MTIpID09PSA1NjMyMCkge1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBsZW4gKz0gNDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbGVuICs9IDM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH07XG4gICAgdXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgaWYgKGxlbiA8IDEpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgdmFyIHBhcnRzID0gbnVsbCwgY2h1bmsgPSBbXSwgaSA9IDAsIHQ7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcbiAgICAgICAgaWYgKHQgPCAxMjgpXG4gICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcbiAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcbiAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gNjU1MzY7XG4gICAgICAgICAgY2h1bmtbaSsrXSA9IDU1Mjk2ICsgKHQgPj4gMTApO1xuICAgICAgICAgIGNodW5rW2krK10gPSA1NjMyMCArICh0ICYgMTAyMyk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcbiAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcbiAgICB9O1xuICAgIHV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzdGFydCA9IG9mZnNldCwgYzEsIGMyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2IHwgMTkyO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAmIDYzIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDY0NTEyKSA9PT0gNTUyOTYgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiA2NDUxMikgPT09IDU2MzIwKSB7XG4gICAgICAgICAgYzEgPSA2NTUzNiArICgoYzEgJiAxMDIzKSA8PCAxMCkgKyAoYzIgJiAxMDIzKTtcbiAgICAgICAgICArK2k7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4IHwgMjQwO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICYgNjMgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyIHwgMjI0O1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICYgNjMgfCAxMjg7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICYgNjMgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanNcbnZhciByZXF1aXJlX3Bvb2wgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gcG9vbDtcbiAgICBmdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xuICAgICAgdmFyIFNJWkUgPSBzaXplIHx8IDgxOTI7XG4gICAgICB2YXIgTUFYID0gU0laRSA+Pj4gMTtcbiAgICAgIHZhciBzbGFiID0gbnVsbDtcbiAgICAgIHZhciBvZmZzZXQgPSBTSVpFO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZTIpIHtcbiAgICAgICAgaWYgKHNpemUyIDwgMSB8fCBzaXplMiA+IE1BWClcbiAgICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZTIpO1xuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZTIgPiBTSVpFKSB7XG4gICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xuICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCBvZmZzZXQgKz0gc2l6ZTIpO1xuICAgICAgICBpZiAob2Zmc2V0ICYgNylcbiAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IHwgNykgKyAxO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qc1xudmFyIHJlcXVpcmVfbG9uZ2JpdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gTG9uZ0JpdHM7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcbiAgICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcbiAgICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbiAgICB9XG4gICAgdmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH07XG4gICAgdmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuICAgIExvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCwgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG4gICAgfTtcbiAgICBMb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCwgaGkgPSB+dGhpcy5oaSA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5NjtcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICAgIHJldHVybiB1dGlsLkxvbmcgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG4gICAgfTtcbiAgICB2YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcbiAgICBMb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDggfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTYgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwLFxuICAgICAgICAoY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDggfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTYgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgICApO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQsXG4gICAgICAgIHRoaXMuaGkgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICAgKTtcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgICAgdmFyIG1hc2sgPSB0aGlzLmhpID4+IDMxO1xuICAgICAgdGhpcy5oaSA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgICB0aGlzLmxvID0gKHRoaXMubG8gPDwgMSBeIG1hc2spID4+PiAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgICB0aGlzLmxvID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICAgIHRoaXMuaGkgPSAodGhpcy5oaSA+Pj4gMSBeIG1hc2spID4+PiAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgdmFyIHBhcnQwID0gdGhpcy5sbywgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLCBwYXJ0MiA9IHRoaXMuaGkgPj4+IDI0O1xuICAgICAgcmV0dXJuIHBhcnQyID09PSAwID8gcGFydDEgPT09IDAgPyBwYXJ0MCA8IDE2Mzg0ID8gcGFydDAgPCAxMjggPyAxIDogMiA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0IDogcGFydDEgPCAxNjM4NCA/IHBhcnQxIDwgMTI4ID8gNSA6IDYgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOCA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzXG52YXIgcmVxdWlyZV9taW5pbWFsID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHV0aWwgPSBleHBvcnRzMjtcbiAgICB1dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmVfYXNwcm9taXNlKCk7XG4gICAgdXRpbC5iYXNlNjQgPSByZXF1aXJlX2Jhc2U2NCgpO1xuICAgIHV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZV9ldmVudGVtaXR0ZXIoKTtcbiAgICB1dGlsLmZsb2F0ID0gcmVxdWlyZV9mbG9hdCgpO1xuICAgIHV0aWwuaW5xdWlyZSA9IHJlcXVpcmVfaW5xdWlyZSgpO1xuICAgIHV0aWwudXRmOCA9IHJlcXVpcmVfdXRmOCgpO1xuICAgIHV0aWwucG9vbCA9IHJlcXVpcmVfcG9vbCgpO1xuICAgIHV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlX2xvbmdiaXRzKCk7XG4gICAgdXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsICYmIGdsb2JhbC5wcm9jZXNzICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuICAgIHV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93IHx8IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgZXhwb3J0czI7XG4gICAgdXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogKFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIFtdXG4gICAgKTtcbiAgICB1dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogKFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHt9XG4gICAgKTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiAgICB9O1xuICAgIHV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9O1xuICAgIHV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbiAgICB9O1xuICAgIHV0aWwuaXNzZXQgPSAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gICAgICovXG4gICAgdXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHV0aWwuQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyMiA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIHJldHVybiBCdWZmZXIyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIyIDogKFxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KCk7XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgdXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCIgPyB1dGlsLkJ1ZmZlciA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSkgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSkgOiB1dGlsLkJ1ZmZlciA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KSA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiID8gc2l6ZU9yQXJyYXkgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG4gICAgfTtcbiAgICB1dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IDogQXJyYXk7XG4gICAgdXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5nbG9iYWwuTG9uZyB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuICAgIHV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuICAgIHV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuICAgIHV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcbiAgICB1dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbiAgICB9O1xuICAgIHV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkge1xuICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdm9pZCAwIHx8ICFpZk5vdFNldClcbiAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICB1dGlsLm1lcmdlID0gbWVyZ2U7XG4gICAgdXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuICAgICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9IH0pO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpXG4gICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgICBDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBDdXN0b21FcnJvcixcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IHZvaWQgMCxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAvLyBjb25maWd1cmFibGU6IGZhbHNlIHdvdWxkIGFjY3VyYXRlbHkgcHJlc2VydmUgdGhlIGJlaGF2aW9yIG9mXG4gICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBidXQgSSdtIGd1ZXNzaW5nIHRoYXQgd2FzIG5vdCBpbnRlbnRpb25hbC5cbiAgICAgICAgICAvLyBGb3IgYW4gYWN0dWFsIGVycm9yIHN1YmNsYXNzLCB0aGlzIHByb3BlcnR5IHdvdWxkXG4gICAgICAgICAgLy8gYmUgY29uZmlndXJhYmxlLlxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzoge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG4gICAgfVxuICAgIHV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcbiAgICB1dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG4gICAgdXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaTIgPSBrZXlzLmxlbmd0aCAtIDE7IGkyID4gLTE7IC0taTIpXG4gICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaTJdXSA9PT0gMSAmJiB0aGlzW2tleXNbaTJdXSAhPT0gdm9pZCAwICYmIHRoaXNba2V5c1tpMl1dICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGtleXNbaTJdO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB1dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgICBsb25nczogU3RyaW5nLFxuICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAgICBqc29uOiB0cnVlXG4gICAgfTtcbiAgICB1dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBCdWZmZXIyID0gdXRpbC5CdWZmZXI7XG4gICAgICBpZiAoIUJ1ZmZlcjIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlcjIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlcjIuZnJvbSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyMih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgfTtcbiAgICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlcjIuYWxsb2NVbnNhZmUgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyMihzaXplKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanNcbnZhciByZXF1aXJlX3dyaXRlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFdyaXRlcjtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIHZhciBCdWZmZXJXcml0ZXI7XG4gICAgdmFyIExvbmdCaXRzID0gdXRpbC5Mb25nQml0cztcbiAgICB2YXIgYmFzZTY0ID0gdXRpbC5iYXNlNjQ7XG4gICAgdmFyIHV0ZjggPSB1dGlsLnV0Zjg7XG4gICAgZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG4gICAgICB0aGlzLmZuID0gZm47XG4gICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgIH1cbiAgICBmdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcbiAgICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuICAgICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG4gICAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG4gICAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0ZXIoKSB7XG4gICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG4gICAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG4gICAgfVxuICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUyKCkge1xuICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICB9KSgpO1xuICAgICAgfSA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xuICAgIH07XG4gICAgaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuICAgIFdyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xuICAgIH1cbiAgICBmdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGJ1Zltwb3NdID0gdmFsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgICAgdGhpcy5sZW4gPSBsZW47XG4gICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB9XG4gICAgVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuICAgIFZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG4gICAgV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApIDwgMTI4ID8gMSA6IHZhbHVlIDwgMTYzODQgPyAyIDogdmFsdWUgPCAyMDk3MTUyID8gMyA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNCA6IDUsXG4gICAgICAgIHZhbHVlXG4gICAgICApKS5sZW47XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSA6IHRoaXMudWludDMyKHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgICAgfVxuICAgICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgICB9XG4gICAgICBidWZbcG9zKytdID0gdmFsLmxvO1xuICAgIH1cbiAgICBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG4gICAgICBidWZbcG9zICsgMV0gPSB2YWwgPj4+IDggJiAyNTU7XG4gICAgICBidWZbcG9zICsgMl0gPSB2YWwgPj4+IDE2ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDNdID0gdmFsID4+PiAyNDtcbiAgICB9XG4gICAgV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuICAgIFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0ID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmLnNldCh2YWwsIHBvcyk7XG4gICAgfSA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgICAgcmV0dXJuIGxlbiA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSkgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsIHRhaWwgPSB0aGlzLnRhaWwsIGxlbiA9IHRoaXMubGVuO1xuICAgICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDtcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIGJ1ZiA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLCBwb3MgPSAwO1xuICAgICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH07XG4gICAgV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanNcbnZhciByZXF1aXJlX3dyaXRlcl9idWZmZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuICAgIHZhciBXcml0ZXIgPSByZXF1aXJlX3dyaXRlcigpO1xuICAgIChCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcbiAgICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCIgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpO1xuICAgICAgfSA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGlmICh2YWwuY29weSlcbiAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyApXG4gICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgfTtcbiAgICB9O1xuICAgIEJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgICAgdGhpcy51aW50MzIobGVuKTtcbiAgICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBpZiAodmFsLmxlbmd0aCA8IDQwKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbiAgICB9XG4gICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzXG52YXIgcmVxdWlyZV9yZWFkZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBSZWFkZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICB2YXIgQnVmZmVyUmVhZGVyO1xuICAgIHZhciBMb25nQml0cyA9IHV0aWwuTG9uZ0JpdHM7XG4gICAgdmFyIHV0ZjggPSB1dGlsLnV0Zjg7XG4gICAgZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG4gICAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9IDogZnVuY3Rpb24gY3JlYXRlX2FycmF5MihidWZmZXIpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZTIoKSB7XG4gICAgICByZXR1cm4gdXRpbC5CdWZmZXIgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcjIpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyMikgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcjIpIDogY3JlYXRlX2FycmF5KGJ1ZmZlcjIpO1xuICAgICAgICB9KShidWZmZXIpO1xuICAgICAgfSA6IGNyZWF0ZV9hcnJheTtcbiAgICB9O1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gICAgUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCA3KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxNSkgPDwgMjgpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIFJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkge1xuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+IDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG4gICAgfVxuICAgIFJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7XG4gICAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XSB8IGJ1ZltlbmQgLSAzXSA8PCA4IHwgYnVmW2VuZCAtIDJdIDw8IDE2IHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbiAgICB9XG4gICAgUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWFkRml4ZWQ2NCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuICAgICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbiAgICB9XG4gICAgUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICAgIHRoaXMucG9zICs9IDQ7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG4gICAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gODtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksIHN0YXJ0ID0gdGhpcy5wb3MsIGVuZCA9IHRoaXMucG9zICsgbGVuZ3RoO1xuICAgICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgdmFyIG5hdGl2ZUJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgICAgICByZXR1cm4gbmF0aXZlQnVmZmVyID8gbmF0aXZlQnVmZmVyLmFsbG9jKDApIDogbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4gICAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogKFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBcInRvTnVtYmVyXCJcbiAgICAgICk7XG4gICAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanNcbnZhciByZXF1aXJlX3JlYWRlcl9idWZmZXIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuICAgIHZhciBSZWFkZXIgPSByZXF1aXJlX3JlYWRlcigpO1xuICAgIChCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICBmdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuICAgIH1cbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbiAgICB9O1xuICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7XG4gICAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbiAgICB9O1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanNcbnZhciByZXF1aXJlX3NlcnZpY2UgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFNlcnZpY2U7XG4gICAgdmFyIHV0aWwgPSByZXF1aXJlX21pbmltYWwoKTtcbiAgICAoU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG4gICAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcbiAgICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG4gICAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG4gICAgfVxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgIHZhciBzZWxmMiA9IHRoaXM7XG4gICAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZjIsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG4gICAgICBpZiAoIXNlbGYyLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmMi5ycGNJbXBsKFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmMi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgc2VsZjIuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZjIuZW5kKFxuICAgICAgICAgICAgICAgIC8qIGVuZGVkQnlSUEMgKi9cbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmMi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICBzZWxmMi5lbWl0KFwiZXJyb3JcIiwgZXJyMiwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYyLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZjIuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIFNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQylcbiAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzXG52YXIgcmVxdWlyZV9ycGMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcnBjID0gZXhwb3J0czI7XG4gICAgcnBjLlNlcnZpY2UgPSByZXF1aXJlX3NlcnZpY2UoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qc1xudmFyIHJlcXVpcmVfcm9vdHMgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHt9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanNcbnZhciByZXF1aXJlX2luZGV4X21pbmltYWwgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHByb3RvYnVmID0gZXhwb3J0czI7XG4gICAgcHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcbiAgICBwcm90b2J1Zi5Xcml0ZXIgPSByZXF1aXJlX3dyaXRlcigpO1xuICAgIHByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmVfd3JpdGVyX2J1ZmZlcigpO1xuICAgIHByb3RvYnVmLlJlYWRlciA9IHJlcXVpcmVfcmVhZGVyKCk7XG4gICAgcHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZV9yZWFkZXJfYnVmZmVyKCk7XG4gICAgcHJvdG9idWYudXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIHByb3RvYnVmLnJwYyA9IHJlcXVpcmVfcnBjKCk7XG4gICAgcHJvdG9idWYucm9vdHMgPSByZXF1aXJlX3Jvb3RzKCk7XG4gICAgcHJvdG9idWYuY29uZmlndXJlID0gY29uZmlndXJlO1xuICAgIGZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG4gICAgfVxuICAgIGNvbmZpZ3VyZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qc1xudmFyIHJlcXVpcmVfbWluaW1hbDIgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSByZXF1aXJlX2luZGV4X21pbmltYWwoKTtcbiAgfVxufSk7XG5cbi8vIHNyYy90YWJsZV9kZWYuanNcbnZhciByZXF1aXJlX3RhYmxlX2RlZiA9IF9fY29tbW9uSlMoe1xuICBcInNyYy90YWJsZV9kZWYuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIHZhciAkcHJvdG9idWYgPSByZXF1aXJlX21pbmltYWwyKCk7XG4gICAgdmFyICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyO1xuICAgIHZhciAkV3JpdGVyID0gJHByb3RvYnVmLldyaXRlcjtcbiAgICB2YXIgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcbiAgICB2YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuICAgICRyb290LmVwb2NoX3Byb3RvID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXBvY2hfcHJvdG8gPSB7fTtcbiAgICAgIGVwb2NoX3Byb3RvLkNvbHVtbkRlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2x1bW5EZWYocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ29sdW1uRGVmLnByb3RvdHlwZS5pZCA9IFwiXCI7XG4gICAgICAgIENvbHVtbkRlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgIENvbHVtbkRlZi5wcm90b3R5cGUudHlwZSA9IDA7XG4gICAgICAgIENvbHVtbkRlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29sdW1uRGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaWRcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5pZCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibmFtZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAyNFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIENvbHVtbkRlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIENvbHVtbkRlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNvbHVtbkRlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlkXCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuaWQpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJpZDogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLm5hbWUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJuYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNvbHVtbkRlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QuaWQgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSBTdHJpbmcob2JqZWN0LmlkKTtcbiAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVVbnNwZWNpZmllZFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlU3RyaW5nXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVJbnRlZ2VyXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVEZWNpbWFsXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVQZXJjZW50XCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVCb29sZWFuXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVEYXRlVGltZVwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGF0ZVwiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGF5RHVyYXRpb25cIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZU1vbmV0YXJ5XCI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVEdXJhdGlvblwiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5pZCA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiVHlwZVVuc3BlY2lmaWVkXCIgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSlcbiAgICAgICAgICAgIG9iamVjdC5pZCA9IG1lc3NhZ2UuaWQ7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvVHlwZVttZXNzYWdlLnR5cGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvVHlwZVttZXNzYWdlLnR5cGVdIDogbWVzc2FnZS50eXBlO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIENvbHVtbkRlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5Db2x1bW5EZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbHVtbkRlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlRhYmxlUm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRhYmxlUm93KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGFibGVSb3cucHJvdG90eXBlLnZhbHVlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRhYmxlUm93LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZVJvdyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZW5jb2RlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlUm93LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdygpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlUm93LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS52YWx1ZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci52ZXJpZnkobWVzc2FnZS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVSb3cpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlUm93KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlUm93LnZhbHVlczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uVGFibGVSb3cudmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudG9PYmplY3QobWVzc2FnZS52YWx1ZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlRhYmxlUm93XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWJsZVJvdztcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlRhYmxlRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUYWJsZURhdGEocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMucm93cyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGFibGVEYXRhLnByb3RvdHlwZS5yb3dzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGFibGVEYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZURhdGEocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnJvd3MgIT0gbnVsbCAmJiBtZXNzYWdlLnJvd3MubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnJvd3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlRhYmxlUm93LmVuY29kZShtZXNzYWdlLnJvd3NbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVEYXRhLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVEYXRhLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVEYXRhKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnJvd3MgJiYgbWVzc2FnZS5yb3dzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnJvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJvd3MucHVzaCgkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uucm93cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyb3dzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5yb3dzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwicm93czogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5yb3dzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlUm93LnZlcmlmeShtZXNzYWdlLnJvd3NbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicm93cy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVEYXRhLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5UYWJsZURhdGEpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YSgpO1xuICAgICAgICAgIGlmIChvYmplY3Qucm93cykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5yb3dzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlRGF0YS5yb3dzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2Uucm93cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qucm93cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5yb3dzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZURhdGEucm93czogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnJvd3NbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdy5mcm9tT2JqZWN0KG9iamVjdC5yb3dzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnJvd3MgPSBbXTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5yb3dzICYmIG1lc3NhZ2Uucm93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5yb3dzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uucm93cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnJvd3Nbal0gPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdy50b09iamVjdChtZXNzYWdlLnJvd3Nbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZURhdGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVEYXRhLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uVGFibGVEYXRhXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWJsZURhdGE7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5UYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUYWJsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5jb2x1bW5zID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBUYWJsZS5wcm90b3R5cGUudHlwZSA9IDA7XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5jYXRlZ29yeSA9IFwiXCI7XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS50aXRsZSA9IFwiXCI7XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5jb2x1bW5zID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGFibGUucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuICAgICAgICBUYWJsZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgVGFibGUocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidHlwZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDhcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2F0ZWdvcnlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5jYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRpdGxlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UudGl0bGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNvbHVtbnMgIT0gbnVsbCAmJiBtZXNzYWdlLmNvbHVtbnMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNvbHVtbnMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNvbHVtbkRlZi5lbmNvZGUobWVzc2FnZS5jb2x1bW5zW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMzRcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGFcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5UYWJsZURhdGEuZW5jb2RlKG1lc3NhZ2UuZGF0YSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNDJcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGUoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNvbHVtbnMgJiYgbWVzc2FnZS5jb2x1bW5zLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbHVtbnMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVEYXRhLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yeTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpdGxlXCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudGl0bGUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ0aXRsZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNvbHVtbnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY29sdW1uc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY29sdW1ucykpXG4gICAgICAgICAgICAgIHJldHVybiBcImNvbHVtbnM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY29sdW1ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYudmVyaWZ5KG1lc3NhZ2UuY29sdW1uc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb2x1bW5zLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVEYXRhLnZlcmlmeShtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGUpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlKCk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFVuc3BlY2lmaWVkXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0TGluZXNcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QmFyXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldERhdGFUYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRYUmFuZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0SGlzdG9ncmFtXCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFBpZVwiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRIZWF0TWFwXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEJveFBsb3RcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QXJlYVwiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENvbHVtblwiOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmNhdGVnb3J5ICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5ID0gU3RyaW5nKG9iamVjdC5jYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKG9iamVjdC50aXRsZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IFN0cmluZyhvYmplY3QudGl0bGUpO1xuICAgICAgICAgIGlmIChvYmplY3QuY29sdW1ucykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5jb2x1bW5zKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlLmNvbHVtbnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jb2x1bW5zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5jb2x1bW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNvbHVtbnNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlLmNvbHVtbnM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5jb2x1bW5zW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uQ29sdW1uRGVmLmZyb21PYmplY3Qob2JqZWN0LmNvbHVtbnNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlLmRhdGE6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YS5mcm9tT2JqZWN0KG9iamVjdC5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY29sdW1ucyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiV2lkZ2V0VW5zcGVjaWZpZWRcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnkgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0W21lc3NhZ2UudHlwZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UudHlwZSA6ICRyb290LmVwb2NoX3Byb3RvLkVwb2NoRm9saW9EYXNoYm9hcmRXaWRnZXRbbWVzc2FnZS50eXBlXSA6IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yeSA9IG1lc3NhZ2UuY2F0ZWdvcnk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpXG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBtZXNzYWdlLnRpdGxlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNvbHVtbnMgJiYgbWVzc2FnZS5jb2x1bW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5jb2x1bW5zLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QuY29sdW1uc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkNvbHVtbkRlZi50b09iamVjdChtZXNzYWdlLmNvbHVtbnNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpXG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YS50b09iamVjdChtZXNzYWdlLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uVGFibGVcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRhYmxlO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQ2FyZERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FyZERhdGEocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ2FyZERhdGEucHJvdG90eXBlLnRpdGxlID0gXCJcIjtcbiAgICAgICAgQ2FyZERhdGEucHJvdG90eXBlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgQ2FyZERhdGEucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBDYXJkRGF0YS5wcm90b3R5cGUuZ3JvdXAgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gICAgICAgIENhcmREYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYXJkRGF0YShwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGl0bGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS50aXRsZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInZhbHVlXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLnZhbHVlLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAyNFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmdyb3VwICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJncm91cFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICApLnVpbnQ2NChtZXNzYWdlLmdyb3VwKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREYXRhLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERhdGEoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXAgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREYXRhLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aXRsZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRpdGxlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGl0bGU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnZlcmlmeShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWUuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ncm91cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncm91cFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5ncm91cCkgJiYgIShtZXNzYWdlLmdyb3VwICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmdyb3VwLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZ3JvdXAuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJncm91cDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERhdGEpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNhcmREYXRhKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC50aXRsZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IFN0cmluZyhvYmplY3QudGl0bGUpO1xuICAgICAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DYXJkRGF0YS52YWx1ZTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlVW5zcGVjaWZpZWRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZVN0cmluZ1wiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlSW50ZWdlclwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGVjaW1hbFwiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlUGVyY2VudFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlQm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGF0ZVRpbWVcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURheUR1cmF0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVNb25ldGFyeVwiOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRHVyYXRpb25cIjpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5ncm91cCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZ3JvdXAgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZ3JvdXApKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lmdyb3VwID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwID0gcGFyc2VJbnQob2JqZWN0Lmdyb3VwLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lmdyb3VwID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwID0gb2JqZWN0Lmdyb3VwO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZ3JvdXAubG93ID4+PiAwLCBvYmplY3QuZ3JvdXAuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJUeXBlVW5zcGVjaWZpZWRcIiA6IDA7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXAgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5ncm91cCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpXG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBtZXNzYWdlLnRpdGxlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb1R5cGVbbWVzc2FnZS50eXBlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS50eXBlIDogJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb1R5cGVbbWVzc2FnZS50eXBlXSA6IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5ncm91cCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncm91cFwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ncm91cCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0Lmdyb3VwID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZ3JvdXApIDogbWVzc2FnZS5ncm91cDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0Lmdyb3VwID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmdyb3VwKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmdyb3VwLmxvdyA+Pj4gMCwgbWVzc2FnZS5ncm91cC5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UuZ3JvdXA7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5DYXJkRGF0YVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2FyZERhdGE7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5DYXJkRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhcmREZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ2FyZERlZi5wcm90b3R5cGUudHlwZSA9IDA7XG4gICAgICAgIENhcmREZWYucHJvdG90eXBlLmNhdGVnb3J5ID0gXCJcIjtcbiAgICAgICAgQ2FyZERlZi5wcm90b3R5cGUuZGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIENhcmREZWYucHJvdG90eXBlLmdyb3VwU2l6ZSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgICAgICAgQ2FyZERlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2FyZERlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNhdGVnb3J5XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNhcmREYXRhLmVuY29kZShtZXNzYWdlLmRhdGFbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBTaXplICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJncm91cFNpemVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAzMlxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS5ncm91cFNpemUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yeSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEucHVzaCgkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwU2l6ZSA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yeTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGF0YSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YS52ZXJpZnkobWVzc2FnZS5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXBTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImdyb3VwU2l6ZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5ncm91cFNpemUpICYmICEobWVzc2FnZS5ncm91cFNpemUgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZ3JvdXBTaXplLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZ3JvdXBTaXplLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JvdXBTaXplOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWYoKTtcbiAgICAgICAgICBzd2l0Y2ggKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0VW5zcGVjaWZpZWRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0Q2FyZFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRMaW5lc1wiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRCYXJcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0RGF0YVRhYmxlXCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFhSYW5nZVwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRIaXN0b2dyYW1cIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0UGllXCI6XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEhlYXRNYXBcIjpcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0Qm94UGxvdFwiOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRBcmVhXCI6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0Q29sdW1uXCI6XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuY2F0ZWdvcnkgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnkgPSBTdHJpbmcob2JqZWN0LmNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGF0YSkpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DYXJkRGVmLmRhdGE6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGFbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNhcmREZWYuZGF0YTogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGFbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YS5mcm9tT2JqZWN0KG9iamVjdC5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5ncm91cFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmdyb3VwU2l6ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5ncm91cFNpemUpKS51bnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lmdyb3VwU2l6ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cFNpemUgPSBwYXJzZUludChvYmplY3QuZ3JvdXBTaXplLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0Lmdyb3VwU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cFNpemUgPSBvYmplY3QuZ3JvdXBTaXplO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cFNpemUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBTaXplID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5ncm91cFNpemUubG93ID4+PiAwLCBvYmplY3QuZ3JvdXBTaXplLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBbXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIldpZGdldFVuc3BlY2lmaWVkXCIgOiAwO1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5ID0gXCJcIjtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9iamVjdC5ncm91cFNpemUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5ncm91cFNpemUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldFttZXNzYWdlLnR5cGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0W21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlcIikpXG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnkgPSBtZXNzYWdlLmNhdGVnb3J5O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QuZGF0YVtqXSA9ICRyb290LmVwb2NoX3Byb3RvLkNhcmREYXRhLnRvT2JqZWN0KG1lc3NhZ2UuZGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmdyb3VwU2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncm91cFNpemVcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZ3JvdXBTaXplID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXBTaXplID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZ3JvdXBTaXplKSA6IG1lc3NhZ2UuZ3JvdXBTaXplO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXBTaXplID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmdyb3VwU2l6ZSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5ncm91cFNpemUubG93ID4+PiAwLCBtZXNzYWdlLmdyb3VwU2l6ZS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UuZ3JvdXBTaXplO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkNhcmREZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhcmREZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJXaWRnZXRVbnNwZWNpZmllZFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJXaWRnZXRDYXJkXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIldpZGdldExpbmVzXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIldpZGdldEJhclwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJXaWRnZXREYXRhVGFibGVcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiV2lkZ2V0WFJhbmdlXCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIldpZGdldEhpc3RvZ3JhbVwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJXaWRnZXRQaWVcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiV2lkZ2V0SGVhdE1hcFwiXSA9IDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzldID0gXCJXaWRnZXRCb3hQbG90XCJdID0gOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJXaWRnZXRBcmVhXCJdID0gMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiV2lkZ2V0Q29sdW1uXCJdID0gMTE7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5FcG9jaEZvbGlvVHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiVHlwZVVuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlR5cGVTdHJpbmdcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiVHlwZUludGVnZXJcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiVHlwZURlY2ltYWxcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiVHlwZVBlcmNlbnRcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiVHlwZUJvb2xlYW5cIl0gPSA1O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs2XSA9IFwiVHlwZURhdGVUaW1lXCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIlR5cGVEYXRlXCJdID0gNztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIlR5cGVEYXlEdXJhdGlvblwiXSA9IDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzldID0gXCJUeXBlTW9uZXRhcnlcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIlR5cGVEdXJhdGlvblwiXSA9IDEwO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uU2NhbGFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFNjYWxhcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnN0cmluZ1ZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5pbnRlZ2VyVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmRlY2ltYWxWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUucGVyY2VudFZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5ib29sZWFuVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnRpbWVzdGFtcE1zID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kYXRlVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLmRheUR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5tb25ldGFyeVZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kdXJhdGlvbk1zID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5udWxsVmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2NhbGFyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJzdHJpbmdWYWx1ZVwiLCBcImludGVnZXJWYWx1ZVwiLCBcImRlY2ltYWxWYWx1ZVwiLCBcInBlcmNlbnRWYWx1ZVwiLCBcImJvb2xlYW5WYWx1ZVwiLCBcInRpbWVzdGFtcE1zXCIsIFwiZGF0ZVZhbHVlXCIsIFwiZGF5RHVyYXRpb25cIiwgXCJtb25ldGFyeVZhbHVlXCIsIFwiZHVyYXRpb25Nc1wiLCBcIm51bGxWYWx1ZVwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBTY2FsYXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhcihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInN0cmluZ1ZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2Uuc3RyaW5nVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmludGVnZXJWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaW50ZWdlclZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMTZcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS5pbnRlZ2VyVmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRlY2ltYWxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGVjaW1hbFZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgMjVcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UuZGVjaW1hbFZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wZXJjZW50VmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInBlcmNlbnRWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDMzXG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnBlcmNlbnRWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJib29sZWFuVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA0MFxuICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UuYm9vbGVhblZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXBNcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGltZXN0YW1wTXNcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA0OFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLnRpbWVzdGFtcE1zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRlVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhdGVWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDcsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDU2XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UuZGF0ZVZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXlEdXJhdGlvbiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF5RHVyYXRpb25cIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA4LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA2NFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLmRheUR1cmF0aW9uKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5tb25ldGFyeVZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJtb25ldGFyeVZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgOSwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgNzNcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZHVyYXRpb25Nc1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEwLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4MFxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLmR1cmF0aW9uTXMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibnVsbFZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMTEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDg4XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UubnVsbFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRlY2ltYWxWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBlcmNlbnRWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJvb2xlYW5WYWx1ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXlEdXJhdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAxMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nVmFsdWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pbnRlZ2VyVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW50ZWdlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmludGVnZXJWYWx1ZSkgJiYgIShtZXNzYWdlLmludGVnZXJWYWx1ZSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRlZ2VyVmFsdWUubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRlZ2VyVmFsdWUuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJpbnRlZ2VyVmFsdWU6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kZWNpbWFsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVjaW1hbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGVjaW1hbFZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkZWNpbWFsVmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wZXJjZW50VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGVyY2VudFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UucGVyY2VudFZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJwZXJjZW50VmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ib29sZWFuVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbGVhblZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblZhbHVlOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcE1zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpbWVzdGFtcE1zXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRpbWVzdGFtcE1zKSAmJiAhKG1lc3NhZ2UudGltZXN0YW1wTXMgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudGltZXN0YW1wTXMubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50aW1lc3RhbXBNcy5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInRpbWVzdGFtcE1zOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0ZVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGVWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kYXRlVmFsdWUpICYmICEobWVzc2FnZS5kYXRlVmFsdWUgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0ZVZhbHVlLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0ZVZhbHVlLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0ZVZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF5RHVyYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF5RHVyYXRpb25cIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF5RHVyYXRpb24pKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXlEdXJhdGlvbjogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5tb25ldGFyeVZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1vbmV0YXJ5VmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5tb25ldGFyeVZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJtb25ldGFyeVZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkdXJhdGlvbk1zXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmR1cmF0aW9uTXMpICYmICEobWVzc2FnZS5kdXJhdGlvbk1zICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmR1cmF0aW9uTXMubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kdXJhdGlvbk1zLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZHVyYXRpb25NczogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJudWxsVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5udWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsVmFsdWU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhcigpO1xuICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5nVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSBTdHJpbmcob2JqZWN0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmludGVnZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmludGVnZXJWYWx1ZSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludGVnZXJWYWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSBwYXJzZUludChvYmplY3QuaW50ZWdlclZhbHVlLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmludGVnZXJWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPSBvYmplY3QuaW50ZWdlclZhbHVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRlZ2VyVmFsdWUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5pbnRlZ2VyVmFsdWUubG93ID4+PiAwLCBvYmplY3QuaW50ZWdlclZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZGVjaW1hbFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmRlY2ltYWxWYWx1ZSA9IE51bWJlcihvYmplY3QuZGVjaW1hbFZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnBlcmNlbnRWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5wZXJjZW50VmFsdWUgPSBOdW1iZXIob2JqZWN0LnBlcmNlbnRWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5ib29sZWFuVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuYm9vbGVhblZhbHVlID0gQm9vbGVhbihvYmplY3QuYm9vbGVhblZhbHVlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnRpbWVzdGFtcE1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS50aW1lc3RhbXBNcyA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC50aW1lc3RhbXBNcykpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnRpbWVzdGFtcE1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gcGFyc2VJbnQob2JqZWN0LnRpbWVzdGFtcE1zLCAxMCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnRpbWVzdGFtcE1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcE1zID0gb2JqZWN0LnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC50aW1lc3RhbXBNcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QudGltZXN0YW1wTXMubG93ID4+PiAwLCBvYmplY3QudGltZXN0YW1wTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmRhdGVWYWx1ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kYXRlVmFsdWUpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kYXRlVmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gcGFyc2VJbnQob2JqZWN0LmRhdGVWYWx1ZSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kYXRlVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0ZVZhbHVlID0gb2JqZWN0LmRhdGVWYWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGF0ZVZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGVWYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZGF0ZVZhbHVlLmxvdyA+Pj4gMCwgb2JqZWN0LmRhdGVWYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRheUR1cmF0aW9uICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmRheUR1cmF0aW9uID0gb2JqZWN0LmRheUR1cmF0aW9uIHwgMDtcbiAgICAgICAgICBpZiAob2JqZWN0Lm1vbmV0YXJ5VmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSA9IE51bWJlcihvYmplY3QubW9uZXRhcnlWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5kdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5kdXJhdGlvbk1zID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LmR1cmF0aW9uTXMpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kdXJhdGlvbk1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSBwYXJzZUludChvYmplY3QuZHVyYXRpb25NcywgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5kdXJhdGlvbk1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmR1cmF0aW9uTXMgPSBvYmplY3QuZHVyYXRpb25NcztcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZHVyYXRpb25NcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5kdXJhdGlvbk1zLmxvdyA+Pj4gMCwgb2JqZWN0LmR1cmF0aW9uTXMuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5udWxsVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IG9iamVjdC5udWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTlVMTF9WQUxVRVwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5zdHJpbmdWYWx1ZSA9IG1lc3NhZ2Uuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwic3RyaW5nVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW50ZWdlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludGVnZXJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmludGVnZXJWYWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmludGVnZXJWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmludGVnZXJWYWx1ZSkgOiBtZXNzYWdlLmludGVnZXJWYWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmludGVnZXJWYWx1ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5pbnRlZ2VyVmFsdWUpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuaW50ZWdlclZhbHVlLmxvdyA+Pj4gMCwgbWVzc2FnZS5pbnRlZ2VyVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuaW50ZWdlclZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImludGVnZXJWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kZWNpbWFsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGVjaW1hbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuZGVjaW1hbFZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLmRlY2ltYWxWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5kZWNpbWFsVmFsdWUpIDogbWVzc2FnZS5kZWNpbWFsVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGVjaW1hbFZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBlcmNlbnRWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwZXJjZW50VmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5wZXJjZW50VmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UucGVyY2VudFZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLnBlcmNlbnRWYWx1ZSkgOiBtZXNzYWdlLnBlcmNlbnRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJwZXJjZW50VmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJvb2xlYW5WYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJvb2xlYW5WYWx1ZSA9IG1lc3NhZ2UuYm9vbGVhblZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImJvb2xlYW5WYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXBNcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aW1lc3RhbXBNc1wiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnRpbWVzdGFtcE1zID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS50aW1lc3RhbXBNcykgOiBtZXNzYWdlLnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QudGltZXN0YW1wTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UudGltZXN0YW1wTXMpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UudGltZXN0YW1wTXMubG93ID4+PiAwLCBtZXNzYWdlLnRpbWVzdGFtcE1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLnRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInRpbWVzdGFtcE1zXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGVWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRlVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5kYXRlVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRlVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kYXRlVmFsdWUpIDogbWVzc2FnZS5kYXRlVmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRlVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZGF0ZVZhbHVlKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmRhdGVWYWx1ZS5sb3cgPj4+IDAsIG1lc3NhZ2UuZGF0ZVZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmRhdGVWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJkYXRlVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF5RHVyYXRpb24gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF5RHVyYXRpb25cIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5kYXlEdXJhdGlvbiA9IG1lc3NhZ2UuZGF5RHVyYXRpb247XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGF5RHVyYXRpb25cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb25ldGFyeVZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QubW9uZXRhcnlWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5tb25ldGFyeVZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLm1vbmV0YXJ5VmFsdWUpIDogbWVzc2FnZS5tb25ldGFyeVZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcIm1vbmV0YXJ5VmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZHVyYXRpb25NcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkdXJhdGlvbk1zXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZHVyYXRpb25NcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LmR1cmF0aW9uTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5kdXJhdGlvbk1zKSA6IG1lc3NhZ2UuZHVyYXRpb25NcztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LmR1cmF0aW9uTXMgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuZHVyYXRpb25NcykgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kdXJhdGlvbk1zLmxvdyA+Pj4gMCwgbWVzc2FnZS5kdXJhdGlvbk1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmR1cmF0aW9uTXM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZHVyYXRpb25Nc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QubnVsbFZhbHVlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UubnVsbFZhbHVlIDogJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gOiBtZXNzYWdlLm51bGxWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJudWxsVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlNjYWxhclwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU2NhbGFyO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQXJyYXkyKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkyLnByb3RvdHlwZS52YWx1ZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBBcnJheTIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFycmF5Mihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLnZhbHVlc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BcnJheSgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkyLmlzQXJyYXkobWVzc2FnZS52YWx1ZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci52ZXJpZnkobWVzc2FnZS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkFycmF5KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BcnJheSgpO1xuICAgICAgICAgIGlmIChvYmplY3QudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5Mi5pc0FycmF5KG9iamVjdC52YWx1ZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQXJyYXkudmFsdWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5BcnJheS52YWx1ZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZnJvbU9iamVjdChvYmplY3QudmFsdWVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudG9PYmplY3QobWVzc2FnZS52YWx1ZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQXJyYXlcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEFycmF5MjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkF4aXNUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJBeGlzVW5zcGVjaWZpZWRcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiQXhpc0xpbmVhclwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJBeGlzTG9nYXJpdGhtaWNcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiQXhpc0RhdGVUaW1lXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIkF4aXNDYXRlZ29yeVwiXSA9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5EYXNoU3R5bGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkRhc2hTdHlsZVVuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlNvbGlkXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlNob3J0RGFzaFwiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJTaG9ydERvdFwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJTaG9ydERhc2hEb3RcIl0gPSA0O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs1XSA9IFwiU2hvcnREYXNoRG90RG90XCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIkRvdFwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJEYXNoXCJdID0gNztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIkxvbmdEYXNoXCJdID0gODtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOV0gPSBcIkRhc2hEb3RcIl0gPSA5O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMF0gPSBcIkxvbmdEYXNoRG90XCJdID0gMTA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzExXSA9IFwiTG9uZ0Rhc2hEb3REb3RcIl0gPSAxMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBlcG9jaF9wcm90bztcbiAgICB9KCk7XG4gICAgJHJvb3QuZ29vZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ29vZ2xlID0ge307XG4gICAgICBnb29nbGUucHJvdG9idWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3RvYnVmID0ge307XG4gICAgICAgIHByb3RvYnVmLlN0cnVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIFN0cnVjdChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBTdHJ1Y3QucHJvdG90eXBlLmZpZWxkcyA9ICR1dGlsLmVtcHR5T2JqZWN0O1xuICAgICAgICAgIFN0cnVjdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJ1Y3QocHJvcGVydGllcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImZpZWxkc1wiKSlcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICkuZm9yaygpLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICAgICkuc3RyaW5nKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5lbmNvZGUobWVzc2FnZS5maWVsZHNba2V5c1tpXV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCkubGRlbGltKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0KCksIGtleSwgdmFsdWU7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmllbGRzID0ge307XG4gICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICBrZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWcyID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZzIgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcyICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZmllbGRzXCIpKSB7XG4gICAgICAgICAgICAgIGlmICghJHV0aWwuaXNPYmplY3QobWVzc2FnZS5maWVsZHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhtZXNzYWdlLmZpZWxkcyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnZlcmlmeShtZXNzYWdlLmZpZWxkc1trZXlbaV1dKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJmaWVsZHMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdClcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZmllbGRzKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZpZWxkcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdC5maWVsZHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5maWVsZHNba2V5c1tpXV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5maWVsZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkc1trZXlzW2ldXSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC5maWVsZHNba2V5c1tpXV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2JqZWN0cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICBvYmplY3QuZmllbGRzID0ge307XG4gICAgICAgICAgICB2YXIga2V5czI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5maWVsZHMgJiYgKGtleXMyID0gT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMyLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgIG9iamVjdC5maWVsZHNba2V5czJbal1dID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnRvT2JqZWN0KG1lc3NhZ2UuZmllbGRzW2tleXMyW2pdXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZ29vZ2xlLnByb3RvYnVmLlN0cnVjdFwiO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFN0cnVjdDtcbiAgICAgICAgfSgpO1xuICAgICAgICBwcm90b2J1Zi5WYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIFZhbHVlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLm51bGxWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLm51bWJlclZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUuc3RyaW5nVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5ib29sVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5zdHJ1Y3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLmxpc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmFsdWUucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJudWxsVmFsdWVcIiwgXCJudW1iZXJWYWx1ZVwiLCBcInN0cmluZ1ZhbHVlXCIsIFwiYm9vbFZhbHVlXCIsIFwic3RydWN0VmFsdWVcIiwgXCJsaXN0VmFsdWVcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgVmFsdWUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWUocHJvcGVydGllcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bGxWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibnVsbFZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICApLmludDMyKG1lc3NhZ2UubnVsbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJudW1iZXJWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAgIDE3XG4gICAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubnVtYmVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInN0cmluZ1ZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5zdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJvb2xWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLmJvb2xWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJ1Y3RWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RydWN0VmFsdWVcIikpXG4gICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZW5jb2RlKG1lc3NhZ2Uuc3RydWN0VmFsdWUsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICA0MlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5saXN0VmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImxpc3RWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS5lbmNvZGUobWVzc2FnZS5saXN0VmFsdWUsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICA1MFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1iZXJWYWx1ZSA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmJvb2xWYWx1ZSA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cnVjdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5saXN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxWYWx1ZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udW1iZXJWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJudW1iZXJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UubnVtYmVyVmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyVmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyaW5nVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RyaW5nVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdWYWx1ZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmtpbmQgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwia2luZDogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5ib29sVmFsdWUgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImJvb2xWYWx1ZTogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RydWN0VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RydWN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QudmVyaWZ5KG1lc3NhZ2Uuc3RydWN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cnVjdFZhbHVlLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaXN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmVyaWZ5KG1lc3NhZ2UubGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJsaXN0VmFsdWUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUpXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUoKTtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lm51bGxWYWx1ZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm51bGxWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSBvYmplY3QubnVsbFZhbHVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiTlVMTF9WQUxVRVwiOlxuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5udW1iZXJWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICBtZXNzYWdlLm51bWJlclZhbHVlID0gTnVtYmVyKG9iamVjdC5udW1iZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnN0cmluZ1ZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyaW5nVmFsdWUgPSBTdHJpbmcob2JqZWN0LnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYm9vbFZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuYm9vbFZhbHVlID0gQm9vbGVhbihvYmplY3QuYm9vbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RydWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdHJ1Y3RWYWx1ZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnN0cnVjdFZhbHVlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RydWN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0LmZyb21PYmplY3Qob2JqZWN0LnN0cnVjdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QubGlzdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubGlzdFZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuVmFsdWUubGlzdFZhbHVlOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UubGlzdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC5saXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3QubnVsbFZhbHVlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UubnVsbFZhbHVlIDogJHJvb3QuZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVttZXNzYWdlLm51bGxWYWx1ZV0gOiBtZXNzYWdlLm51bGxWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJudWxsVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bWJlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5udW1iZXJWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5udW1iZXJWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5udW1iZXJWYWx1ZSkgOiBtZXNzYWdlLm51bWJlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcIm51bWJlclZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3Quc3RyaW5nVmFsdWUgPSBtZXNzYWdlLnN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcInN0cmluZ1ZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ib29sVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm9vbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5ib29sVmFsdWUgPSBtZXNzYWdlLmJvb2xWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJib29sVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cnVjdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cnVjdFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5zdHJ1Y3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QudG9PYmplY3QobWVzc2FnZS5zdHJ1Y3RWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwic3RydWN0VmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaXN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0Lmxpc3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudG9PYmplY3QobWVzc2FnZS5saXN0VmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcImxpc3RWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuVmFsdWVcIjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBWYWx1ZTtcbiAgICAgICAgfSgpO1xuICAgICAgICBwcm90b2J1Zi5OdWxsVmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJOVUxMX1ZBTFVFXCJdID0gMDtcbiAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLkxpc3RWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZ1bmN0aW9uIExpc3RWYWx1ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnZhbHVlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgICAgTGlzdFZhbHVlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RWYWx1ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZW5jb2RlKG1lc3NhZ2UudmFsdWVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzLnB1c2goJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpKSB7XG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnZhbHVlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnZlcmlmeShtZXNzYWdlLnZhbHVlc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUpXG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlcykge1xuICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnZhbHVlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmFsdWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudmFsdWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUudmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXNbaV0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZnJvbU9iamVjdChvYmplY3QudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWVzID0gW107XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWVzW2pdID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlXCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gTGlzdFZhbHVlO1xuICAgICAgICB9KCk7XG4gICAgICAgIHJldHVybiBwcm90b2J1ZjtcbiAgICAgIH0oKTtcbiAgICAgIHJldHVybiBnb29nbGU7XG4gICAgfSgpO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9ICRyb290O1xuICB9XG59KTtcbmV4cG9ydCBkZWZhdWx0IHJlcXVpcmVfdGFibGVfZGVmKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/table_def.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/tearsheet.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@epochlab/epoch-protos/dist/tearsheet.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod2) => function __require() {\n  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n};\n\n// node_modules/@protobufjs/aspromise/index.js\nvar require_aspromise = __commonJS({\n  \"node_modules/@protobufjs/aspromise/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = asPromise;\n    function asPromise(fn, ctx) {\n      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;\n      while (index < arguments.length)\n        params[offset++] = arguments[index++];\n      return new Promise(function executor(resolve, reject) {\n        params[offset] = function callback(err) {\n          if (pending) {\n            pending = false;\n            if (err)\n              reject(err);\n            else {\n              var params2 = new Array(arguments.length - 1), offset2 = 0;\n              while (offset2 < params2.length)\n                params2[offset2++] = arguments[offset2];\n              resolve.apply(null, params2);\n            }\n          }\n        };\n        try {\n          fn.apply(ctx || null, params);\n        } catch (err) {\n          if (pending) {\n            pending = false;\n            reject(err);\n          }\n        }\n      });\n    }\n  }\n});\n\n// node_modules/@protobufjs/base64/index.js\nvar require_base64 = __commonJS({\n  \"node_modules/@protobufjs/base64/index.js\"(exports2) {\n    \"use strict\";\n    var base64 = exports2;\n    base64.length = function length(string) {\n      var p = string.length;\n      if (!p)\n        return 0;\n      var n = 0;\n      while (--p % 4 > 1 && string.charAt(p) === \"=\")\n        ++n;\n      return Math.ceil(string.length * 3) / 4 - n;\n    };\n    var b64 = new Array(64);\n    var s64 = new Array(123);\n    for (i = 0; i < 64; )\n      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\n    var i;\n    base64.encode = function encode(buffer, start, end) {\n      var parts = null, chunk = [];\n      var i2 = 0, j = 0, t;\n      while (start < end) {\n        var b = buffer[start++];\n        switch (j) {\n          case 0:\n            chunk[i2++] = b64[b >> 2];\n            t = (b & 3) << 4;\n            j = 1;\n            break;\n          case 1:\n            chunk[i2++] = b64[t | b >> 4];\n            t = (b & 15) << 2;\n            j = 2;\n            break;\n          case 2:\n            chunk[i2++] = b64[t | b >> 6];\n            chunk[i2++] = b64[b & 63];\n            j = 0;\n            break;\n        }\n        if (i2 > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i2 = 0;\n        }\n      }\n      if (j) {\n        chunk[i2++] = b64[t];\n        chunk[i2++] = 61;\n        if (j === 1)\n          chunk[i2++] = 61;\n      }\n      if (parts) {\n        if (i2)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i2));\n    };\n    var invalidEncoding = \"invalid encoding\";\n    base64.decode = function decode(string, buffer, offset) {\n      var start = offset;\n      var j = 0, t;\n      for (var i2 = 0; i2 < string.length; ) {\n        var c = string.charCodeAt(i2++);\n        if (c === 61 && j > 1)\n          break;\n        if ((c = s64[c]) === void 0)\n          throw Error(invalidEncoding);\n        switch (j) {\n          case 0:\n            t = c;\n            j = 1;\n            break;\n          case 1:\n            buffer[offset++] = t << 2 | (c & 48) >> 4;\n            t = c;\n            j = 2;\n            break;\n          case 2:\n            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\n            t = c;\n            j = 3;\n            break;\n          case 3:\n            buffer[offset++] = (t & 3) << 6 | c;\n            j = 0;\n            break;\n        }\n      }\n      if (j === 1)\n        throw Error(invalidEncoding);\n      return offset - start;\n    };\n    base64.test = function test(string) {\n      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\n    };\n  }\n});\n\n// node_modules/@protobufjs/eventemitter/index.js\nvar require_eventemitter = __commonJS({\n  \"node_modules/@protobufjs/eventemitter/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = EventEmitter;\n    function EventEmitter() {\n      this._listeners = {};\n    }\n    EventEmitter.prototype.on = function on(evt, fn, ctx) {\n      (this._listeners[evt] || (this._listeners[evt] = [])).push({\n        fn,\n        ctx: ctx || this\n      });\n      return this;\n    };\n    EventEmitter.prototype.off = function off(evt, fn) {\n      if (evt === void 0)\n        this._listeners = {};\n      else {\n        if (fn === void 0)\n          this._listeners[evt] = [];\n        else {\n          var listeners = this._listeners[evt];\n          for (var i = 0; i < listeners.length; )\n            if (listeners[i].fn === fn)\n              listeners.splice(i, 1);\n            else\n              ++i;\n        }\n      }\n      return this;\n    };\n    EventEmitter.prototype.emit = function emit(evt) {\n      var listeners = this._listeners[evt];\n      if (listeners) {\n        var args = [], i = 1;\n        for (; i < arguments.length; )\n          args.push(arguments[i++]);\n        for (i = 0; i < listeners.length; )\n          listeners[i].fn.apply(listeners[i++].ctx, args);\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/@protobufjs/float/index.js\nvar require_float = __commonJS({\n  \"node_modules/@protobufjs/float/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = factory(factory);\n    function factory(exports3) {\n      if (typeof Float32Array !== \"undefined\") (function() {\n        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;\n        function writeFloat_f32_cpy(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n        }\n        function writeFloat_f32_rev(val, buf, pos) {\n          f32[0] = val;\n          buf[pos] = f8b[3];\n          buf[pos + 1] = f8b[2];\n          buf[pos + 2] = f8b[1];\n          buf[pos + 3] = f8b[0];\n        }\n        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\n        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\n        function readFloat_f32_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          return f32[0];\n        }\n        function readFloat_f32_rev(buf, pos) {\n          f8b[3] = buf[pos];\n          f8b[2] = buf[pos + 1];\n          f8b[1] = buf[pos + 2];\n          f8b[0] = buf[pos + 3];\n          return f32[0];\n        }\n        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\n        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\n      })();\n      else (function() {\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0)\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos);\n          else if (isNaN(val))\n            writeUint(2143289344, buf, pos);\n          else if (val > 34028234663852886e22)\n            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\n          else if (val < 11754943508222875e-54)\n            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);\n          else {\n            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\n            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\n          }\n        }\n        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\n        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\n        function readFloat_ieee754(readUint, buf, pos) {\n          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;\n          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\n        }\n        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\n        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\n      })();\n      if (typeof Float64Array !== \"undefined\") (function() {\n        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;\n        function writeDouble_f64_cpy(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[0];\n          buf[pos + 1] = f8b[1];\n          buf[pos + 2] = f8b[2];\n          buf[pos + 3] = f8b[3];\n          buf[pos + 4] = f8b[4];\n          buf[pos + 5] = f8b[5];\n          buf[pos + 6] = f8b[6];\n          buf[pos + 7] = f8b[7];\n        }\n        function writeDouble_f64_rev(val, buf, pos) {\n          f64[0] = val;\n          buf[pos] = f8b[7];\n          buf[pos + 1] = f8b[6];\n          buf[pos + 2] = f8b[5];\n          buf[pos + 3] = f8b[4];\n          buf[pos + 4] = f8b[3];\n          buf[pos + 5] = f8b[2];\n          buf[pos + 6] = f8b[1];\n          buf[pos + 7] = f8b[0];\n        }\n        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\n        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\n        function readDouble_f64_cpy(buf, pos) {\n          f8b[0] = buf[pos];\n          f8b[1] = buf[pos + 1];\n          f8b[2] = buf[pos + 2];\n          f8b[3] = buf[pos + 3];\n          f8b[4] = buf[pos + 4];\n          f8b[5] = buf[pos + 5];\n          f8b[6] = buf[pos + 6];\n          f8b[7] = buf[pos + 7];\n          return f64[0];\n        }\n        function readDouble_f64_rev(buf, pos) {\n          f8b[7] = buf[pos];\n          f8b[6] = buf[pos + 1];\n          f8b[5] = buf[pos + 2];\n          f8b[4] = buf[pos + 3];\n          f8b[3] = buf[pos + 4];\n          f8b[2] = buf[pos + 5];\n          f8b[1] = buf[pos + 6];\n          f8b[0] = buf[pos + 7];\n          return f64[0];\n        }\n        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\n        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\n      })();\n      else (function() {\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\n          var sign = val < 0 ? 1 : 0;\n          if (sign)\n            val = -val;\n          if (val === 0) {\n            writeUint(0, buf, pos + off0);\n            writeUint(1 / val > 0 ? (\n              /* positive */\n              0\n            ) : (\n              /* negative 0 */\n              2147483648\n            ), buf, pos + off1);\n          } else if (isNaN(val)) {\n            writeUint(0, buf, pos + off0);\n            writeUint(2146959360, buf, pos + off1);\n          } else if (val > 17976931348623157e292) {\n            writeUint(0, buf, pos + off0);\n            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\n          } else {\n            var mantissa;\n            if (val < 22250738585072014e-324) {\n              mantissa = val / 5e-324;\n              writeUint(mantissa >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\n            } else {\n              var exponent = Math.floor(Math.log(val) / Math.LN2);\n              if (exponent === 1024)\n                exponent = 1023;\n              mantissa = val * Math.pow(2, -exponent);\n              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\n              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\n            }\n          }\n        }\n        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\n        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\n          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);\n          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;\n          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\n        }\n        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\n        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\n      })();\n      return exports3;\n    }\n    function writeUintLE(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    function writeUintBE(val, buf, pos) {\n      buf[pos] = val >>> 24;\n      buf[pos + 1] = val >>> 16 & 255;\n      buf[pos + 2] = val >>> 8 & 255;\n      buf[pos + 3] = val & 255;\n    }\n    function readUintLE(buf, pos) {\n      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;\n    }\n    function readUintBE(buf, pos) {\n      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;\n    }\n  }\n});\n\n// node_modules/@protobufjs/inquire/index.js\nvar require_inquire = __commonJS({\n  \"node_modules/@protobufjs/inquire/index.js\"(exports, module) {\n    \"use strict\";\n    module.exports = inquire;\n    function inquire(moduleName) {\n      try {\n        var mod = eval(\"quire\".replace(/^/, \"re\"))(moduleName);\n        if (mod && (mod.length || Object.keys(mod).length))\n          return mod;\n      } catch (e) {\n      }\n      return null;\n    }\n  }\n});\n\n// node_modules/@protobufjs/utf8/index.js\nvar require_utf8 = __commonJS({\n  \"node_modules/@protobufjs/utf8/index.js\"(exports2) {\n    \"use strict\";\n    var utf8 = exports2;\n    utf8.length = function utf8_length(string) {\n      var len = 0, c = 0;\n      for (var i = 0; i < string.length; ++i) {\n        c = string.charCodeAt(i);\n        if (c < 128)\n          len += 1;\n        else if (c < 2048)\n          len += 2;\n        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {\n          ++i;\n          len += 4;\n        } else\n          len += 3;\n      }\n      return len;\n    };\n    utf8.read = function utf8_read(buffer, start, end) {\n      var len = end - start;\n      if (len < 1)\n        return \"\";\n      var parts = null, chunk = [], i = 0, t;\n      while (start < end) {\n        t = buffer[start++];\n        if (t < 128)\n          chunk[i++] = t;\n        else if (t > 191 && t < 224)\n          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n        else if (t > 239 && t < 365) {\n          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;\n          chunk[i++] = 55296 + (t >> 10);\n          chunk[i++] = 56320 + (t & 1023);\n        } else\n          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n        if (i > 8191) {\n          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n          i = 0;\n        }\n      }\n      if (parts) {\n        if (i)\n          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n        return parts.join(\"\");\n      }\n      return String.fromCharCode.apply(String, chunk.slice(0, i));\n    };\n    utf8.write = function utf8_write(string, buffer, offset) {\n      var start = offset, c1, c2;\n      for (var i = 0; i < string.length; ++i) {\n        c1 = string.charCodeAt(i);\n        if (c1 < 128) {\n          buffer[offset++] = c1;\n        } else if (c1 < 2048) {\n          buffer[offset++] = c1 >> 6 | 192;\n          buffer[offset++] = c1 & 63 | 128;\n        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {\n          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);\n          ++i;\n          buffer[offset++] = c1 >> 18 | 240;\n          buffer[offset++] = c1 >> 12 & 63 | 128;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        } else {\n          buffer[offset++] = c1 >> 12 | 224;\n          buffer[offset++] = c1 >> 6 & 63 | 128;\n          buffer[offset++] = c1 & 63 | 128;\n        }\n      }\n      return offset - start;\n    };\n  }\n});\n\n// node_modules/@protobufjs/pool/index.js\nvar require_pool = __commonJS({\n  \"node_modules/@protobufjs/pool/index.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = pool;\n    function pool(alloc, slice, size) {\n      var SIZE = size || 8192;\n      var MAX = SIZE >>> 1;\n      var slab = null;\n      var offset = SIZE;\n      return function pool_alloc(size2) {\n        if (size2 < 1 || size2 > MAX)\n          return alloc(size2);\n        if (offset + size2 > SIZE) {\n          slab = alloc(SIZE);\n          offset = 0;\n        }\n        var buf = slice.call(slab, offset, offset += size2);\n        if (offset & 7)\n          offset = (offset | 7) + 1;\n        return buf;\n      };\n    }\n  }\n});\n\n// node_modules/protobufjs/src/util/longbits.js\nvar require_longbits = __commonJS({\n  \"node_modules/protobufjs/src/util/longbits.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = LongBits;\n    var util = require_minimal();\n    function LongBits(lo, hi) {\n      this.lo = lo >>> 0;\n      this.hi = hi >>> 0;\n    }\n    var zero = LongBits.zero = new LongBits(0, 0);\n    zero.toNumber = function() {\n      return 0;\n    };\n    zero.zzEncode = zero.zzDecode = function() {\n      return this;\n    };\n    zero.length = function() {\n      return 1;\n    };\n    var zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n    LongBits.fromNumber = function fromNumber(value) {\n      if (value === 0)\n        return zero;\n      var sign = value < 0;\n      if (sign)\n        value = -value;\n      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n      if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n          lo = 0;\n          if (++hi > 4294967295)\n            hi = 0;\n        }\n      }\n      return new LongBits(lo, hi);\n    };\n    LongBits.from = function from(value) {\n      if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n      if (util.isString(value)) {\n        if (util.Long)\n          value = util.Long.fromString(value);\n        else\n          return LongBits.fromNumber(parseInt(value, 10));\n      }\n      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n    };\n    LongBits.prototype.toNumber = function toNumber(unsigned) {\n      if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo)\n          hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n      }\n      return this.lo + this.hi * 4294967296;\n    };\n    LongBits.prototype.toLong = function toLong(unsigned) {\n      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n    };\n    var charCodeAt = String.prototype.charCodeAt;\n    LongBits.fromHash = function fromHash(hash) {\n      if (hash === zeroHash)\n        return zero;\n      return new LongBits(\n        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,\n        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0\n      );\n    };\n    LongBits.prototype.toHash = function toHash() {\n      return String.fromCharCode(\n        this.lo & 255,\n        this.lo >>> 8 & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24,\n        this.hi & 255,\n        this.hi >>> 8 & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n      );\n    };\n    LongBits.prototype.zzEncode = function zzEncode() {\n      var mask = this.hi >> 31;\n      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n      this.lo = (this.lo << 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.zzDecode = function zzDecode() {\n      var mask = -(this.lo & 1);\n      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n      this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n      return this;\n    };\n    LongBits.prototype.length = function length() {\n      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/util/minimal.js\nvar require_minimal = __commonJS({\n  \"node_modules/protobufjs/src/util/minimal.js\"(exports2) {\n    \"use strict\";\n    var util = exports2;\n    util.asPromise = require_aspromise();\n    util.base64 = require_base64();\n    util.EventEmitter = require_eventemitter();\n    util.float = require_float();\n    util.inquire = require_inquire();\n    util.utf8 = require_utf8();\n    util.pool = require_pool();\n    util.LongBits = require_longbits();\n    util.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\" && __webpack_require__.g && __webpack_require__.g.process && __webpack_require__.g.process.versions && __webpack_require__.g.process.versions.node);\n    util.global = util.isNode && __webpack_require__.g || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || exports2;\n    util.emptyArray = Object.freeze ? Object.freeze([]) : (\n      /* istanbul ignore next */\n      []\n    );\n    util.emptyObject = Object.freeze ? Object.freeze({}) : (\n      /* istanbul ignore next */\n      {}\n    );\n    util.isInteger = Number.isInteger || /* istanbul ignore next */\n    function isInteger(value) {\n      return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n    };\n    util.isString = function isString(value) {\n      return typeof value === \"string\" || value instanceof String;\n    };\n    util.isObject = function isObject(value) {\n      return value && typeof value === \"object\";\n    };\n    util.isset = /**\n     * Checks if a property on a message is considered to be present.\n     * @param {Object} obj Plain object or message instance\n     * @param {string} prop Property name\n     * @returns {boolean} `true` if considered to be present, otherwise `false`\n     */\n    util.isSet = function isSet(obj, prop) {\n      var value = obj[prop];\n      if (value != null && obj.hasOwnProperty(prop))\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n      return false;\n    };\n    util.Buffer = function() {\n      try {\n        var Buffer2 = util.inquire(\"buffer\").Buffer;\n        return Buffer2.prototype.utf8Write ? Buffer2 : (\n          /* istanbul ignore next */\n          null\n        );\n      } catch (e) {\n        return null;\n      }\n    }();\n    util._Buffer_from = null;\n    util._Buffer_allocUnsafe = null;\n    util.newBuffer = function newBuffer(sizeOrArray) {\n      return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n    };\n    util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    util.Long = /* istanbul ignore next */\n    util.global.dcodeIO && /* istanbul ignore next */\n    util.global.dcodeIO.Long || /* istanbul ignore next */\n    util.global.Long || util.inquire(\"long\");\n    util.key2Re = /^true|false|0|1$/;\n    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n    util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n    util.longToHash = function longToHash(value) {\n      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n    };\n    util.longFromHash = function longFromHash(hash, unsigned) {\n      var bits = util.LongBits.fromHash(hash);\n      if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n      return bits.toNumber(Boolean(unsigned));\n    };\n    function merge(dst, src, ifNotSet) {\n      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === void 0 || !ifNotSet)\n          dst[keys[i]] = src[keys[i]];\n      return dst;\n    }\n    util.merge = merge;\n    util.lcFirst = function lcFirst(str) {\n      return str.charAt(0).toLowerCase() + str.substring(1);\n    };\n    function newError(name) {\n      function CustomError(message, properties) {\n        if (!(this instanceof CustomError))\n          return new CustomError(message, properties);\n        Object.defineProperty(this, \"message\", { get: function() {\n          return message;\n        } });\n        if (Error.captureStackTrace)\n          Error.captureStackTrace(this, CustomError);\n        else\n          Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n        if (properties)\n          merge(this, properties);\n      }\n      CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n          value: CustomError,\n          writable: true,\n          enumerable: false,\n          configurable: true\n        },\n        name: {\n          get: function get() {\n            return name;\n          },\n          set: void 0,\n          enumerable: false,\n          // configurable: false would accurately preserve the behavior of\n          // the original, but I'm guessing that was not intentional.\n          // For an actual error subclass, this property would\n          // be configurable.\n          configurable: true\n        },\n        toString: {\n          value: function value() {\n            return this.name + \": \" + this.message;\n          },\n          writable: true,\n          enumerable: false,\n          configurable: true\n        }\n      });\n      return CustomError;\n    }\n    util.newError = newError;\n    util.ProtocolError = newError(\"ProtocolError\");\n    util.oneOfGetter = function getOneOf(fieldNames) {\n      var fieldMap = {};\n      for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n      return function() {\n        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)\n          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)\n            return keys[i2];\n      };\n    };\n    util.oneOfSetter = function setOneOf(fieldNames) {\n      return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n          if (fieldNames[i] !== name)\n            delete this[fieldNames[i]];\n      };\n    };\n    util.toJSONOptions = {\n      longs: String,\n      enums: String,\n      bytes: String,\n      json: true\n    };\n    util._configure = function() {\n      var Buffer2 = util.Buffer;\n      if (!Buffer2) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n      }\n      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */\n      function Buffer_from(value, encoding) {\n        return new Buffer2(value, encoding);\n      };\n      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */\n      function Buffer_allocUnsafe(size) {\n        return new Buffer2(size);\n      };\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer.js\nvar require_writer = __commonJS({\n  \"node_modules/protobufjs/src/writer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Writer;\n    var util = require_minimal();\n    var BufferWriter;\n    var LongBits = util.LongBits;\n    var base64 = util.base64;\n    var utf8 = util.utf8;\n    function Op(fn, len, val) {\n      this.fn = fn;\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    function noop() {\n    }\n    function State(writer) {\n      this.head = writer.head;\n      this.tail = writer.tail;\n      this.len = writer.len;\n      this.next = writer.states;\n    }\n    function Writer() {\n      this.len = 0;\n      this.head = new Op(noop, 0, 0);\n      this.tail = this.head;\n      this.states = null;\n    }\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n          return new BufferWriter();\n        })();\n      } : function create_array() {\n        return new Writer();\n      };\n    };\n    Writer.create = create();\n    Writer.alloc = function alloc(size) {\n      return new util.Array(size);\n    };\n    if (util.Array !== Array)\n      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n    Writer.prototype._push = function push(fn, len, val) {\n      this.tail = this.tail.next = new Op(fn, len, val);\n      this.len += len;\n      return this;\n    };\n    function writeByte(val, buf, pos) {\n      buf[pos] = val & 255;\n    }\n    function writeVarint32(val, buf, pos) {\n      while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n      }\n      buf[pos] = val;\n    }\n    function VarintOp(len, val) {\n      this.len = len;\n      this.next = void 0;\n      this.val = val;\n    }\n    VarintOp.prototype = Object.create(Op.prototype);\n    VarintOp.prototype.fn = writeVarint32;\n    Writer.prototype.uint32 = function write_uint32(value) {\n      this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,\n        value\n      )).len;\n      return this;\n    };\n    Writer.prototype.int32 = function write_int32(value) {\n      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);\n    };\n    Writer.prototype.sint32 = function write_sint32(value) {\n      return this.uint32((value << 1 ^ value >> 31) >>> 0);\n    };\n    function writeVarint64(val, buf, pos) {\n      while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n      }\n      while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n      }\n      buf[pos++] = val.lo;\n    }\n    Writer.prototype.uint64 = function write_uint64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.int64 = Writer.prototype.uint64;\n    Writer.prototype.sint64 = function write_sint64(value) {\n      var bits = LongBits.from(value).zzEncode();\n      return this._push(writeVarint64, bits.length(), bits);\n    };\n    Writer.prototype.bool = function write_bool(value) {\n      return this._push(writeByte, 1, value ? 1 : 0);\n    };\n    function writeFixed32(val, buf, pos) {\n      buf[pos] = val & 255;\n      buf[pos + 1] = val >>> 8 & 255;\n      buf[pos + 2] = val >>> 16 & 255;\n      buf[pos + 3] = val >>> 24;\n    }\n    Writer.prototype.fixed32 = function write_fixed32(value) {\n      return this._push(writeFixed32, 4, value >>> 0);\n    };\n    Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n    Writer.prototype.fixed64 = function write_fixed64(value) {\n      var bits = LongBits.from(value);\n      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n    };\n    Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n    Writer.prototype.float = function write_float(value) {\n      return this._push(util.float.writeFloatLE, 4, value);\n    };\n    Writer.prototype.double = function write_double(value) {\n      return this._push(util.float.writeDoubleLE, 8, value);\n    };\n    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n      buf.set(val, pos);\n    } : function writeBytes_for(val, buf, pos) {\n      for (var i = 0; i < val.length; ++i)\n        buf[pos + i] = val[i];\n    };\n    Writer.prototype.bytes = function write_bytes(value) {\n      var len = value.length >>> 0;\n      if (!len)\n        return this._push(writeByte, 1, 0);\n      if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n      }\n      return this.uint32(len)._push(writeBytes, len, value);\n    };\n    Writer.prototype.string = function write_string(value) {\n      var len = utf8.length(value);\n      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n    };\n    Writer.prototype.fork = function fork() {\n      this.states = new State(this);\n      this.head = this.tail = new Op(noop, 0, 0);\n      this.len = 0;\n      return this;\n    };\n    Writer.prototype.reset = function reset() {\n      if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n      } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n      }\n      return this;\n    };\n    Writer.prototype.ldelim = function ldelim() {\n      var head = this.head, tail = this.tail, len = this.len;\n      this.reset().uint32(len);\n      if (len) {\n        this.tail.next = head.next;\n        this.tail = tail;\n        this.len += len;\n      }\n      return this;\n    };\n    Writer.prototype.finish = function finish() {\n      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n      while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n      }\n      return buf;\n    };\n    Writer._configure = function(BufferWriter_) {\n      BufferWriter = BufferWriter_;\n      Writer.create = create();\n      BufferWriter._configure();\n    };\n  }\n});\n\n// node_modules/protobufjs/src/writer_buffer.js\nvar require_writer_buffer = __commonJS({\n  \"node_modules/protobufjs/src/writer_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferWriter;\n    var Writer = require_writer();\n    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n    var util = require_minimal();\n    function BufferWriter() {\n      Writer.call(this);\n    }\n    BufferWriter._configure = function() {\n      BufferWriter.alloc = util._Buffer_allocUnsafe;\n      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos);\n      } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy)\n          val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length; )\n          buf[pos++] = val[i++];\n      };\n    };\n    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n      if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n      var len = value.length >>> 0;\n      this.uint32(len);\n      if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n      return this;\n    };\n    function writeStringBuffer(val, buf, pos) {\n      if (val.length < 40)\n        util.utf8.write(val, buf, pos);\n      else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n      else\n        buf.write(val, pos);\n    }\n    BufferWriter.prototype.string = function write_string_buffer(value) {\n      var len = util.Buffer.byteLength(value);\n      this.uint32(len);\n      if (len)\n        this._push(writeStringBuffer, len, value);\n      return this;\n    };\n    BufferWriter._configure();\n  }\n});\n\n// node_modules/protobufjs/src/reader.js\nvar require_reader = __commonJS({\n  \"node_modules/protobufjs/src/reader.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Reader;\n    var util = require_minimal();\n    var BufferReader;\n    var LongBits = util.LongBits;\n    var utf8 = util.utf8;\n    function indexOutOfRange(reader, writeLength) {\n      return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n    }\n    function Reader(buffer) {\n      this.buf = buffer;\n      this.pos = 0;\n      this.len = buffer.length;\n    }\n    var create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n      if (buffer instanceof Uint8Array || Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    } : function create_array2(buffer) {\n      if (Array.isArray(buffer))\n        return new Reader(buffer);\n      throw Error(\"illegal buffer\");\n    };\n    var create = function create2() {\n      return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer2) {\n          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);\n        })(buffer);\n      } : create_array;\n    };\n    Reader.create = create();\n    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */\n    util.Array.prototype.slice;\n    Reader.prototype.uint32 = /* @__PURE__ */ function read_uint32_setup() {\n      var value = 4294967295;\n      return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        if ((this.pos += 5) > this.len) {\n          this.pos = this.len;\n          throw indexOutOfRange(this, 10);\n        }\n        return value;\n      };\n    }();\n    Reader.prototype.int32 = function read_int32() {\n      return this.uint32() | 0;\n    };\n    Reader.prototype.sint32 = function read_sint32() {\n      var value = this.uint32();\n      return value >>> 1 ^ -(value & 1) | 0;\n    };\n    function readLongVarint() {\n      var bits = new LongBits(0, 0);\n      var i = 0;\n      if (this.len - this.pos > 4) {\n        for (; i < 4; ++i) {\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n          return bits;\n        i = 0;\n      } else {\n        for (; i < 3; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n      }\n      if (this.len - this.pos > 4) {\n        for (; i < 5; ++i) {\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      } else {\n        for (; i < 5; ++i) {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n          if (this.buf[this.pos++] < 128)\n            return bits;\n        }\n      }\n      throw Error(\"invalid varint encoding\");\n    }\n    Reader.prototype.bool = function read_bool() {\n      return this.uint32() !== 0;\n    };\n    function readFixed32_end(buf, end) {\n      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n    }\n    Reader.prototype.fixed32 = function read_fixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4);\n    };\n    Reader.prototype.sfixed32 = function read_sfixed32() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      return readFixed32_end(this.buf, this.pos += 4) | 0;\n    };\n    function readFixed64() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n    }\n    Reader.prototype.float = function read_float() {\n      if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readFloatLE(this.buf, this.pos);\n      this.pos += 4;\n      return value;\n    };\n    Reader.prototype.double = function read_double() {\n      if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n      var value = util.float.readDoubleLE(this.buf, this.pos);\n      this.pos += 8;\n      return value;\n    };\n    Reader.prototype.bytes = function read_bytes() {\n      var length = this.uint32(), start = this.pos, end = this.pos + length;\n      if (end > this.len)\n        throw indexOutOfRange(this, length);\n      this.pos += length;\n      if (Array.isArray(this.buf))\n        return this.buf.slice(start, end);\n      if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n      }\n      return this._slice.call(this.buf, start, end);\n    };\n    Reader.prototype.string = function read_string() {\n      var bytes = this.bytes();\n      return utf8.read(bytes, 0, bytes.length);\n    };\n    Reader.prototype.skip = function skip(length) {\n      if (typeof length === \"number\") {\n        if (this.pos + length > this.len)\n          throw indexOutOfRange(this, length);\n        this.pos += length;\n      } else {\n        do {\n          if (this.pos >= this.len)\n            throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n      }\n      return this;\n    };\n    Reader.prototype.skipType = function(wireType) {\n      switch (wireType) {\n        case 0:\n          this.skip();\n          break;\n        case 1:\n          this.skip(8);\n          break;\n        case 2:\n          this.skip(this.uint32());\n          break;\n        case 3:\n          while ((wireType = this.uint32() & 7) !== 4) {\n            this.skipType(wireType);\n          }\n          break;\n        case 5:\n          this.skip(4);\n          break;\n        default:\n          throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n      }\n      return this;\n    };\n    Reader._configure = function(BufferReader_) {\n      BufferReader = BufferReader_;\n      Reader.create = create();\n      BufferReader._configure();\n      var fn = util.Long ? \"toLong\" : (\n        /* istanbul ignore next */\n        \"toNumber\"\n      );\n      util.merge(Reader.prototype, {\n        int64: function read_int64() {\n          return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n          return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n          return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n          return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n          return readFixed64.call(this)[fn](false);\n        }\n      });\n    };\n  }\n});\n\n// node_modules/protobufjs/src/reader_buffer.js\nvar require_reader_buffer = __commonJS({\n  \"node_modules/protobufjs/src/reader_buffer.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = BufferReader;\n    var Reader = require_reader();\n    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n    var util = require_minimal();\n    function BufferReader(buffer) {\n      Reader.call(this, buffer);\n    }\n    BufferReader._configure = function() {\n      if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n    };\n    BufferReader.prototype.string = function read_string_buffer() {\n      var len = this.uint32();\n      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n    };\n    BufferReader._configure();\n  }\n});\n\n// node_modules/protobufjs/src/rpc/service.js\nvar require_service = __commonJS({\n  \"node_modules/protobufjs/src/rpc/service.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = Service;\n    var util = require_minimal();\n    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n    function Service(rpcImpl, requestDelimited, responseDelimited) {\n      if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n      util.EventEmitter.call(this);\n      this.rpcImpl = rpcImpl;\n      this.requestDelimited = Boolean(requestDelimited);\n      this.responseDelimited = Boolean(responseDelimited);\n    }\n    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n      if (!request)\n        throw TypeError(\"request must be specified\");\n      var self2 = this;\n      if (!callback)\n        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);\n      if (!self2.rpcImpl) {\n        setTimeout(function() {\n          callback(Error(\"already ended\"));\n        }, 0);\n        return void 0;\n      }\n      try {\n        return self2.rpcImpl(\n          method,\n          requestCtor[self2.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n          function rpcCallback(err, response) {\n            if (err) {\n              self2.emit(\"error\", err, method);\n              return callback(err);\n            }\n            if (response === null) {\n              self2.end(\n                /* endedByRPC */\n                true\n              );\n              return void 0;\n            }\n            if (!(response instanceof responseCtor)) {\n              try {\n                response = responseCtor[self2.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n              } catch (err2) {\n                self2.emit(\"error\", err2, method);\n                return callback(err2);\n              }\n            }\n            self2.emit(\"data\", response, method);\n            return callback(null, response);\n          }\n        );\n      } catch (err) {\n        self2.emit(\"error\", err, method);\n        setTimeout(function() {\n          callback(err);\n        }, 0);\n        return void 0;\n      }\n    };\n    Service.prototype.end = function end(endedByRPC) {\n      if (this.rpcImpl) {\n        if (!endedByRPC)\n          this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n      }\n      return this;\n    };\n  }\n});\n\n// node_modules/protobufjs/src/rpc.js\nvar require_rpc = __commonJS({\n  \"node_modules/protobufjs/src/rpc.js\"(exports2) {\n    \"use strict\";\n    var rpc = exports2;\n    rpc.Service = require_service();\n  }\n});\n\n// node_modules/protobufjs/src/roots.js\nvar require_roots = __commonJS({\n  \"node_modules/protobufjs/src/roots.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = {};\n  }\n});\n\n// node_modules/protobufjs/src/index-minimal.js\nvar require_index_minimal = __commonJS({\n  \"node_modules/protobufjs/src/index-minimal.js\"(exports2) {\n    \"use strict\";\n    var protobuf = exports2;\n    protobuf.build = \"minimal\";\n    protobuf.Writer = require_writer();\n    protobuf.BufferWriter = require_writer_buffer();\n    protobuf.Reader = require_reader();\n    protobuf.BufferReader = require_reader_buffer();\n    protobuf.util = require_minimal();\n    protobuf.rpc = require_rpc();\n    protobuf.roots = require_roots();\n    protobuf.configure = configure;\n    function configure() {\n      protobuf.util._configure();\n      protobuf.Writer._configure(protobuf.BufferWriter);\n      protobuf.Reader._configure(protobuf.BufferReader);\n    }\n    configure();\n  }\n});\n\n// node_modules/protobufjs/minimal.js\nvar require_minimal2 = __commonJS({\n  \"node_modules/protobufjs/minimal.js\"(exports2, module2) {\n    \"use strict\";\n    module2.exports = require_index_minimal();\n  }\n});\n\n// src/tearsheet.js\nvar require_tearsheet = __commonJS({\n  \"src/tearsheet.js\"(exports2, module2) {\n    var $protobuf = require_minimal2();\n    var $Reader = $protobuf.Reader;\n    var $Writer = $protobuf.Writer;\n    var $util = $protobuf.util;\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    $root.epoch_proto = function() {\n      var epoch_proto = {};\n      epoch_proto.CardDefList = function() {\n        function CardDefList(properties) {\n          this.cards = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        CardDefList.prototype.cards = $util.emptyArray;\n        CardDefList.create = function create(properties) {\n          return new CardDefList(properties);\n        };\n        CardDefList.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.cards != null && message.cards.length)\n            for (var i = 0; i < message.cards.length; ++i)\n              $root.epoch_proto.CardDef.encode(message.cards[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        CardDefList.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        CardDefList.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.CardDefList();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.cards && message.cards.length))\n                  message.cards = [];\n                message.cards.push($root.epoch_proto.CardDef.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        CardDefList.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        CardDefList.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.cards != null && message.hasOwnProperty(\"cards\")) {\n            if (!Array.isArray(message.cards))\n              return \"cards: array expected\";\n            for (var i = 0; i < message.cards.length; ++i) {\n              var error = $root.epoch_proto.CardDef.verify(message.cards[i]);\n              if (error)\n                return \"cards.\" + error;\n            }\n          }\n          return null;\n        };\n        CardDefList.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.CardDefList)\n            return object;\n          var message = new $root.epoch_proto.CardDefList();\n          if (object.cards) {\n            if (!Array.isArray(object.cards))\n              throw TypeError(\".epoch_proto.CardDefList.cards: array expected\");\n            message.cards = [];\n            for (var i = 0; i < object.cards.length; ++i) {\n              if (typeof object.cards[i] !== \"object\")\n                throw TypeError(\".epoch_proto.CardDefList.cards: object expected\");\n              message.cards[i] = $root.epoch_proto.CardDef.fromObject(object.cards[i]);\n            }\n          }\n          return message;\n        };\n        CardDefList.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.cards = [];\n          if (message.cards && message.cards.length) {\n            object.cards = [];\n            for (var j = 0; j < message.cards.length; ++j)\n              object.cards[j] = $root.epoch_proto.CardDef.toObject(message.cards[j], options);\n          }\n          return object;\n        };\n        CardDefList.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        CardDefList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.CardDefList\";\n        };\n        return CardDefList;\n      }();\n      epoch_proto.ChartList = function() {\n        function ChartList(properties) {\n          this.charts = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        ChartList.prototype.charts = $util.emptyArray;\n        ChartList.create = function create(properties) {\n          return new ChartList(properties);\n        };\n        ChartList.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.charts != null && message.charts.length)\n            for (var i = 0; i < message.charts.length; ++i)\n              $root.epoch_proto.Chart.encode(message.charts[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        ChartList.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        ChartList.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.ChartList();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.charts && message.charts.length))\n                  message.charts = [];\n                message.charts.push($root.epoch_proto.Chart.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ChartList.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        ChartList.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.charts != null && message.hasOwnProperty(\"charts\")) {\n            if (!Array.isArray(message.charts))\n              return \"charts: array expected\";\n            for (var i = 0; i < message.charts.length; ++i) {\n              var error = $root.epoch_proto.Chart.verify(message.charts[i]);\n              if (error)\n                return \"charts.\" + error;\n            }\n          }\n          return null;\n        };\n        ChartList.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.ChartList)\n            return object;\n          var message = new $root.epoch_proto.ChartList();\n          if (object.charts) {\n            if (!Array.isArray(object.charts))\n              throw TypeError(\".epoch_proto.ChartList.charts: array expected\");\n            message.charts = [];\n            for (var i = 0; i < object.charts.length; ++i) {\n              if (typeof object.charts[i] !== \"object\")\n                throw TypeError(\".epoch_proto.ChartList.charts: object expected\");\n              message.charts[i] = $root.epoch_proto.Chart.fromObject(object.charts[i]);\n            }\n          }\n          return message;\n        };\n        ChartList.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.charts = [];\n          if (message.charts && message.charts.length) {\n            object.charts = [];\n            for (var j = 0; j < message.charts.length; ++j)\n              object.charts[j] = $root.epoch_proto.Chart.toObject(message.charts[j], options);\n          }\n          return object;\n        };\n        ChartList.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        ChartList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.ChartList\";\n        };\n        return ChartList;\n      }();\n      epoch_proto.TableList = function() {\n        function TableList(properties) {\n          this.tables = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TableList.prototype.tables = $util.emptyArray;\n        TableList.create = function create(properties) {\n          return new TableList(properties);\n        };\n        TableList.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.tables != null && message.tables.length)\n            for (var i = 0; i < message.tables.length; ++i)\n              $root.epoch_proto.Table.encode(message.tables[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        TableList.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TableList.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TableList();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.tables && message.tables.length))\n                  message.tables = [];\n                message.tables.push($root.epoch_proto.Table.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TableList.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TableList.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.tables != null && message.hasOwnProperty(\"tables\")) {\n            if (!Array.isArray(message.tables))\n              return \"tables: array expected\";\n            for (var i = 0; i < message.tables.length; ++i) {\n              var error = $root.epoch_proto.Table.verify(message.tables[i]);\n              if (error)\n                return \"tables.\" + error;\n            }\n          }\n          return null;\n        };\n        TableList.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TableList)\n            return object;\n          var message = new $root.epoch_proto.TableList();\n          if (object.tables) {\n            if (!Array.isArray(object.tables))\n              throw TypeError(\".epoch_proto.TableList.tables: array expected\");\n            message.tables = [];\n            for (var i = 0; i < object.tables.length; ++i) {\n              if (typeof object.tables[i] !== \"object\")\n                throw TypeError(\".epoch_proto.TableList.tables: object expected\");\n              message.tables[i] = $root.epoch_proto.Table.fromObject(object.tables[i]);\n            }\n          }\n          return message;\n        };\n        TableList.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.tables = [];\n          if (message.tables && message.tables.length) {\n            object.tables = [];\n            for (var j = 0; j < message.tables.length; ++j)\n              object.tables[j] = $root.epoch_proto.Table.toObject(message.tables[j], options);\n          }\n          return object;\n        };\n        TableList.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TableList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TableList\";\n        };\n        return TableList;\n      }();\n      epoch_proto.TearSheet = function() {\n        function TearSheet(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TearSheet.prototype.cards = null;\n        TearSheet.prototype.charts = null;\n        TearSheet.prototype.tables = null;\n        TearSheet.create = function create(properties) {\n          return new TearSheet(properties);\n        };\n        TearSheet.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.cards != null && Object.hasOwnProperty.call(message, \"cards\"))\n            $root.epoch_proto.CardDefList.encode(message.cards, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.charts != null && Object.hasOwnProperty.call(message, \"charts\"))\n            $root.epoch_proto.ChartList.encode(message.charts, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.tables != null && Object.hasOwnProperty.call(message, \"tables\"))\n            $root.epoch_proto.TableList.encode(message.tables, writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).fork()).ldelim();\n          return writer;\n        };\n        TearSheet.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TearSheet.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TearSheet();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.cards = $root.epoch_proto.CardDefList.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.charts = $root.epoch_proto.ChartList.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                message.tables = $root.epoch_proto.TableList.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TearSheet.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TearSheet.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.cards != null && message.hasOwnProperty(\"cards\")) {\n            var error = $root.epoch_proto.CardDefList.verify(message.cards);\n            if (error)\n              return \"cards.\" + error;\n          }\n          if (message.charts != null && message.hasOwnProperty(\"charts\")) {\n            var error = $root.epoch_proto.ChartList.verify(message.charts);\n            if (error)\n              return \"charts.\" + error;\n          }\n          if (message.tables != null && message.hasOwnProperty(\"tables\")) {\n            var error = $root.epoch_proto.TableList.verify(message.tables);\n            if (error)\n              return \"tables.\" + error;\n          }\n          return null;\n        };\n        TearSheet.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TearSheet)\n            return object;\n          var message = new $root.epoch_proto.TearSheet();\n          if (object.cards != null) {\n            if (typeof object.cards !== \"object\")\n              throw TypeError(\".epoch_proto.TearSheet.cards: object expected\");\n            message.cards = $root.epoch_proto.CardDefList.fromObject(object.cards);\n          }\n          if (object.charts != null) {\n            if (typeof object.charts !== \"object\")\n              throw TypeError(\".epoch_proto.TearSheet.charts: object expected\");\n            message.charts = $root.epoch_proto.ChartList.fromObject(object.charts);\n          }\n          if (object.tables != null) {\n            if (typeof object.tables !== \"object\")\n              throw TypeError(\".epoch_proto.TearSheet.tables: object expected\");\n            message.tables = $root.epoch_proto.TableList.fromObject(object.tables);\n          }\n          return message;\n        };\n        TearSheet.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.cards = null;\n            object.charts = null;\n            object.tables = null;\n          }\n          if (message.cards != null && message.hasOwnProperty(\"cards\"))\n            object.cards = $root.epoch_proto.CardDefList.toObject(message.cards, options);\n          if (message.charts != null && message.hasOwnProperty(\"charts\"))\n            object.charts = $root.epoch_proto.ChartList.toObject(message.charts, options);\n          if (message.tables != null && message.hasOwnProperty(\"tables\"))\n            object.tables = $root.epoch_proto.TableList.toObject(message.tables, options);\n          return object;\n        };\n        TearSheet.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TearSheet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TearSheet\";\n        };\n        return TearSheet;\n      }();\n      epoch_proto.FullTearSheet = function() {\n        function FullTearSheet(properties) {\n          this.categories = {};\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        FullTearSheet.prototype.categories = $util.emptyObject;\n        FullTearSheet.create = function create(properties) {\n          return new FullTearSheet(properties);\n        };\n        FullTearSheet.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.categories != null && Object.hasOwnProperty.call(message, \"categories\"))\n            for (var keys = Object.keys(message.categories), i = 0; i < keys.length; ++i) {\n              writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork().uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).string(keys[i]);\n              $root.epoch_proto.TearSheet.encode(message.categories[keys[i]], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim().ldelim();\n            }\n          return writer;\n        };\n        FullTearSheet.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        FullTearSheet.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.FullTearSheet(), key, value;\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (message.categories === $util.emptyObject)\n                  message.categories = {};\n                var end2 = reader.uint32() + reader.pos;\n                key = \"\";\n                value = null;\n                while (reader.pos < end2) {\n                  var tag2 = reader.uint32();\n                  switch (tag2 >>> 3) {\n                    case 1:\n                      key = reader.string();\n                      break;\n                    case 2:\n                      value = $root.epoch_proto.TearSheet.decode(reader, reader.uint32());\n                      break;\n                    default:\n                      reader.skipType(tag2 & 7);\n                      break;\n                  }\n                }\n                message.categories[key] = value;\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        FullTearSheet.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        FullTearSheet.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.categories != null && message.hasOwnProperty(\"categories\")) {\n            if (!$util.isObject(message.categories))\n              return \"categories: object expected\";\n            var key = Object.keys(message.categories);\n            for (var i = 0; i < key.length; ++i) {\n              var error = $root.epoch_proto.TearSheet.verify(message.categories[key[i]]);\n              if (error)\n                return \"categories.\" + error;\n            }\n          }\n          return null;\n        };\n        FullTearSheet.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.FullTearSheet)\n            return object;\n          var message = new $root.epoch_proto.FullTearSheet();\n          if (object.categories) {\n            if (typeof object.categories !== \"object\")\n              throw TypeError(\".epoch_proto.FullTearSheet.categories: object expected\");\n            message.categories = {};\n            for (var keys = Object.keys(object.categories), i = 0; i < keys.length; ++i) {\n              if (typeof object.categories[keys[i]] !== \"object\")\n                throw TypeError(\".epoch_proto.FullTearSheet.categories: object expected\");\n              message.categories[keys[i]] = $root.epoch_proto.TearSheet.fromObject(object.categories[keys[i]]);\n            }\n          }\n          return message;\n        };\n        FullTearSheet.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.objects || options.defaults)\n            object.categories = {};\n          var keys2;\n          if (message.categories && (keys2 = Object.keys(message.categories)).length) {\n            object.categories = {};\n            for (var j = 0; j < keys2.length; ++j)\n              object.categories[keys2[j]] = $root.epoch_proto.TearSheet.toObject(message.categories[keys2[j]], options);\n          }\n          return object;\n        };\n        FullTearSheet.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        FullTearSheet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.FullTearSheet\";\n        };\n        return FullTearSheet;\n      }();\n      epoch_proto.EpochFolioDashboardWidget = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"WidgetUnspecified\"] = 0;\n        values[valuesById[1] = \"WidgetCard\"] = 1;\n        values[valuesById[2] = \"WidgetLines\"] = 2;\n        values[valuesById[3] = \"WidgetBar\"] = 3;\n        values[valuesById[4] = \"WidgetDataTable\"] = 4;\n        values[valuesById[5] = \"WidgetXRange\"] = 5;\n        values[valuesById[6] = \"WidgetHistogram\"] = 6;\n        values[valuesById[7] = \"WidgetPie\"] = 7;\n        values[valuesById[8] = \"WidgetHeatMap\"] = 8;\n        values[valuesById[9] = \"WidgetBoxPlot\"] = 9;\n        values[valuesById[10] = \"WidgetArea\"] = 10;\n        values[valuesById[11] = \"WidgetColumn\"] = 11;\n        return values;\n      }();\n      epoch_proto.EpochFolioType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"TypeUnspecified\"] = 0;\n        values[valuesById[1] = \"TypeString\"] = 1;\n        values[valuesById[2] = \"TypeInteger\"] = 2;\n        values[valuesById[3] = \"TypeDecimal\"] = 3;\n        values[valuesById[4] = \"TypePercent\"] = 4;\n        values[valuesById[5] = \"TypeBoolean\"] = 5;\n        values[valuesById[6] = \"TypeDateTime\"] = 6;\n        values[valuesById[7] = \"TypeDate\"] = 7;\n        values[valuesById[8] = \"TypeDayDuration\"] = 8;\n        values[valuesById[9] = \"TypeMonetary\"] = 9;\n        values[valuesById[10] = \"TypeDuration\"] = 10;\n        return values;\n      }();\n      epoch_proto.Scalar = function() {\n        function Scalar(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Scalar.prototype.stringValue = null;\n        Scalar.prototype.integerValue = null;\n        Scalar.prototype.decimalValue = null;\n        Scalar.prototype.percentValue = null;\n        Scalar.prototype.booleanValue = null;\n        Scalar.prototype.timestampMs = null;\n        Scalar.prototype.dateValue = null;\n        Scalar.prototype.dayDuration = null;\n        Scalar.prototype.monetaryValue = null;\n        Scalar.prototype.durationMs = null;\n        Scalar.prototype.nullValue = null;\n        var $oneOfFields;\n        Object.defineProperty(Scalar.prototype, \"value\", {\n          get: $util.oneOfGetter($oneOfFields = [\"stringValue\", \"integerValue\", \"decimalValue\", \"percentValue\", \"booleanValue\", \"timestampMs\", \"dateValue\", \"dayDuration\", \"monetaryValue\", \"durationMs\", \"nullValue\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Scalar.create = function create(properties) {\n          return new Scalar(properties);\n        };\n        Scalar.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.stringValue);\n          if (message.integerValue != null && Object.hasOwnProperty.call(message, \"integerValue\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.integerValue);\n          if (message.decimalValue != null && Object.hasOwnProperty.call(message, \"decimalValue\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.decimalValue);\n          if (message.percentValue != null && Object.hasOwnProperty.call(message, \"percentValue\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.percentValue);\n          if (message.booleanValue != null && Object.hasOwnProperty.call(message, \"booleanValue\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.booleanValue);\n          if (message.timestampMs != null && Object.hasOwnProperty.call(message, \"timestampMs\"))\n            writer.uint32(\n              /* id 6, wireType 0 =*/\n              48\n            ).int64(message.timestampMs);\n          if (message.dateValue != null && Object.hasOwnProperty.call(message, \"dateValue\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).int64(message.dateValue);\n          if (message.dayDuration != null && Object.hasOwnProperty.call(message, \"dayDuration\"))\n            writer.uint32(\n              /* id 8, wireType 0 =*/\n              64\n            ).int32(message.dayDuration);\n          if (message.monetaryValue != null && Object.hasOwnProperty.call(message, \"monetaryValue\"))\n            writer.uint32(\n              /* id 9, wireType 1 =*/\n              73\n            ).double(message.monetaryValue);\n          if (message.durationMs != null && Object.hasOwnProperty.call(message, \"durationMs\"))\n            writer.uint32(\n              /* id 10, wireType 0 =*/\n              80\n            ).int64(message.durationMs);\n          if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n            writer.uint32(\n              /* id 11, wireType 0 =*/\n              88\n            ).int32(message.nullValue);\n          return writer;\n        };\n        Scalar.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Scalar.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Scalar();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.stringValue = reader.string();\n                break;\n              }\n              case 2: {\n                message.integerValue = reader.int64();\n                break;\n              }\n              case 3: {\n                message.decimalValue = reader.double();\n                break;\n              }\n              case 4: {\n                message.percentValue = reader.double();\n                break;\n              }\n              case 5: {\n                message.booleanValue = reader.bool();\n                break;\n              }\n              case 6: {\n                message.timestampMs = reader.int64();\n                break;\n              }\n              case 7: {\n                message.dateValue = reader.int64();\n                break;\n              }\n              case 8: {\n                message.dayDuration = reader.int32();\n                break;\n              }\n              case 9: {\n                message.monetaryValue = reader.double();\n                break;\n              }\n              case 10: {\n                message.durationMs = reader.int64();\n                break;\n              }\n              case 11: {\n                message.nullValue = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Scalar.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Scalar.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            properties.value = 1;\n            if (!$util.isString(message.stringValue))\n              return \"stringValue: string expected\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.integerValue) && !(message.integerValue && $util.isInteger(message.integerValue.low) && $util.isInteger(message.integerValue.high)))\n              return \"integerValue: integer|Long expected\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.decimalValue !== \"number\")\n              return \"decimalValue: number expected\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.percentValue !== \"number\")\n              return \"percentValue: number expected\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.booleanValue !== \"boolean\")\n              return \"booleanValue: boolean expected\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))\n              return \"timestampMs: integer|Long expected\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dateValue) && !(message.dateValue && $util.isInteger(message.dateValue.low) && $util.isInteger(message.dateValue.high)))\n              return \"dateValue: integer|Long expected\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.dayDuration))\n              return \"dayDuration: integer expected\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (typeof message.monetaryValue !== \"number\")\n              return \"monetaryValue: number expected\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            if (!$util.isInteger(message.durationMs) && !(message.durationMs && $util.isInteger(message.durationMs.low) && $util.isInteger(message.durationMs.high)))\n              return \"durationMs: integer|Long expected\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            if (properties.value === 1)\n              return \"value: multiple values\";\n            properties.value = 1;\n            switch (message.nullValue) {\n              default:\n                return \"nullValue: enum value expected\";\n              case 0:\n                break;\n            }\n          }\n          return null;\n        };\n        Scalar.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Scalar)\n            return object;\n          var message = new $root.epoch_proto.Scalar();\n          if (object.stringValue != null)\n            message.stringValue = String(object.stringValue);\n          if (object.integerValue != null) {\n            if ($util.Long)\n              (message.integerValue = $util.Long.fromValue(object.integerValue)).unsigned = false;\n            else if (typeof object.integerValue === \"string\")\n              message.integerValue = parseInt(object.integerValue, 10);\n            else if (typeof object.integerValue === \"number\")\n              message.integerValue = object.integerValue;\n            else if (typeof object.integerValue === \"object\")\n              message.integerValue = new $util.LongBits(object.integerValue.low >>> 0, object.integerValue.high >>> 0).toNumber();\n          }\n          if (object.decimalValue != null)\n            message.decimalValue = Number(object.decimalValue);\n          if (object.percentValue != null)\n            message.percentValue = Number(object.percentValue);\n          if (object.booleanValue != null)\n            message.booleanValue = Boolean(object.booleanValue);\n          if (object.timestampMs != null) {\n            if ($util.Long)\n              (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;\n            else if (typeof object.timestampMs === \"string\")\n              message.timestampMs = parseInt(object.timestampMs, 10);\n            else if (typeof object.timestampMs === \"number\")\n              message.timestampMs = object.timestampMs;\n            else if (typeof object.timestampMs === \"object\")\n              message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();\n          }\n          if (object.dateValue != null) {\n            if ($util.Long)\n              (message.dateValue = $util.Long.fromValue(object.dateValue)).unsigned = false;\n            else if (typeof object.dateValue === \"string\")\n              message.dateValue = parseInt(object.dateValue, 10);\n            else if (typeof object.dateValue === \"number\")\n              message.dateValue = object.dateValue;\n            else if (typeof object.dateValue === \"object\")\n              message.dateValue = new $util.LongBits(object.dateValue.low >>> 0, object.dateValue.high >>> 0).toNumber();\n          }\n          if (object.dayDuration != null)\n            message.dayDuration = object.dayDuration | 0;\n          if (object.monetaryValue != null)\n            message.monetaryValue = Number(object.monetaryValue);\n          if (object.durationMs != null) {\n            if ($util.Long)\n              (message.durationMs = $util.Long.fromValue(object.durationMs)).unsigned = false;\n            else if (typeof object.durationMs === \"string\")\n              message.durationMs = parseInt(object.durationMs, 10);\n            else if (typeof object.durationMs === \"number\")\n              message.durationMs = object.durationMs;\n            else if (typeof object.durationMs === \"object\")\n              message.durationMs = new $util.LongBits(object.durationMs.low >>> 0, object.durationMs.high >>> 0).toNumber();\n          }\n          switch (object.nullValue) {\n            default:\n              if (typeof object.nullValue === \"number\") {\n                message.nullValue = object.nullValue;\n                break;\n              }\n              break;\n            case \"NULL_VALUE\":\n            case 0:\n              message.nullValue = 0;\n              break;\n          }\n          return message;\n        };\n        Scalar.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n            object.stringValue = message.stringValue;\n            if (options.oneofs)\n              object.value = \"stringValue\";\n          }\n          if (message.integerValue != null && message.hasOwnProperty(\"integerValue\")) {\n            if (typeof message.integerValue === \"number\")\n              object.integerValue = options.longs === String ? String(message.integerValue) : message.integerValue;\n            else\n              object.integerValue = options.longs === String ? $util.Long.prototype.toString.call(message.integerValue) : options.longs === Number ? new $util.LongBits(message.integerValue.low >>> 0, message.integerValue.high >>> 0).toNumber() : message.integerValue;\n            if (options.oneofs)\n              object.value = \"integerValue\";\n          }\n          if (message.decimalValue != null && message.hasOwnProperty(\"decimalValue\")) {\n            object.decimalValue = options.json && !isFinite(message.decimalValue) ? String(message.decimalValue) : message.decimalValue;\n            if (options.oneofs)\n              object.value = \"decimalValue\";\n          }\n          if (message.percentValue != null && message.hasOwnProperty(\"percentValue\")) {\n            object.percentValue = options.json && !isFinite(message.percentValue) ? String(message.percentValue) : message.percentValue;\n            if (options.oneofs)\n              object.value = \"percentValue\";\n          }\n          if (message.booleanValue != null && message.hasOwnProperty(\"booleanValue\")) {\n            object.booleanValue = message.booleanValue;\n            if (options.oneofs)\n              object.value = \"booleanValue\";\n          }\n          if (message.timestampMs != null && message.hasOwnProperty(\"timestampMs\")) {\n            if (typeof message.timestampMs === \"number\")\n              object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;\n            else\n              object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;\n            if (options.oneofs)\n              object.value = \"timestampMs\";\n          }\n          if (message.dateValue != null && message.hasOwnProperty(\"dateValue\")) {\n            if (typeof message.dateValue === \"number\")\n              object.dateValue = options.longs === String ? String(message.dateValue) : message.dateValue;\n            else\n              object.dateValue = options.longs === String ? $util.Long.prototype.toString.call(message.dateValue) : options.longs === Number ? new $util.LongBits(message.dateValue.low >>> 0, message.dateValue.high >>> 0).toNumber() : message.dateValue;\n            if (options.oneofs)\n              object.value = \"dateValue\";\n          }\n          if (message.dayDuration != null && message.hasOwnProperty(\"dayDuration\")) {\n            object.dayDuration = message.dayDuration;\n            if (options.oneofs)\n              object.value = \"dayDuration\";\n          }\n          if (message.monetaryValue != null && message.hasOwnProperty(\"monetaryValue\")) {\n            object.monetaryValue = options.json && !isFinite(message.monetaryValue) ? String(message.monetaryValue) : message.monetaryValue;\n            if (options.oneofs)\n              object.value = \"monetaryValue\";\n          }\n          if (message.durationMs != null && message.hasOwnProperty(\"durationMs\")) {\n            if (typeof message.durationMs === \"number\")\n              object.durationMs = options.longs === String ? String(message.durationMs) : message.durationMs;\n            else\n              object.durationMs = options.longs === String ? $util.Long.prototype.toString.call(message.durationMs) : options.longs === Number ? new $util.LongBits(message.durationMs.low >>> 0, message.durationMs.high >>> 0).toNumber() : message.durationMs;\n            if (options.oneofs)\n              object.value = \"durationMs\";\n          }\n          if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n            object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n            if (options.oneofs)\n              object.value = \"nullValue\";\n          }\n          return object;\n        };\n        Scalar.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Scalar.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Scalar\";\n        };\n        return Scalar;\n      }();\n      epoch_proto.Array = function() {\n        function Array2(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Array2.prototype.values = $util.emptyArray;\n        Array2.create = function create(properties) {\n          return new Array2(properties);\n        };\n        Array2.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        Array2.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Array2.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Array();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Array2.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Array2.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array2.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        Array2.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Array)\n            return object;\n          var message = new $root.epoch_proto.Array();\n          if (object.values) {\n            if (!Array2.isArray(object.values))\n              throw TypeError(\".epoch_proto.Array.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Array.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        Array2.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        Array2.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Array2.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Array\";\n        };\n        return Array2;\n      }();\n      epoch_proto.AxisType = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"AxisUnspecified\"] = 0;\n        values[valuesById[1] = \"AxisLinear\"] = 1;\n        values[valuesById[2] = \"AxisLogarithmic\"] = 2;\n        values[valuesById[3] = \"AxisDateTime\"] = 3;\n        values[valuesById[4] = \"AxisCategory\"] = 4;\n        return values;\n      }();\n      epoch_proto.DashStyle = function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"DashStyleUnspecified\"] = 0;\n        values[valuesById[1] = \"Solid\"] = 1;\n        values[valuesById[2] = \"ShortDash\"] = 2;\n        values[valuesById[3] = \"ShortDot\"] = 3;\n        values[valuesById[4] = \"ShortDashDot\"] = 4;\n        values[valuesById[5] = \"ShortDashDotDot\"] = 5;\n        values[valuesById[6] = \"Dot\"] = 6;\n        values[valuesById[7] = \"Dash\"] = 7;\n        values[valuesById[8] = \"LongDash\"] = 8;\n        values[valuesById[9] = \"DashDot\"] = 9;\n        values[valuesById[10] = \"LongDashDot\"] = 10;\n        values[valuesById[11] = \"LongDashDotDot\"] = 11;\n        return values;\n      }();\n      epoch_proto.ColumnDef = function() {\n        function ColumnDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        ColumnDef.prototype.id = \"\";\n        ColumnDef.prototype.name = \"\";\n        ColumnDef.prototype.type = 0;\n        ColumnDef.create = function create(properties) {\n          return new ColumnDef(properties);\n        };\n        ColumnDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.id);\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.name);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          return writer;\n        };\n        ColumnDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        ColumnDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.ColumnDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.id = reader.string();\n                break;\n              }\n              case 2: {\n                message.name = reader.string();\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ColumnDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        ColumnDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.id != null && message.hasOwnProperty(\"id\")) {\n            if (!$util.isString(message.id))\n              return \"id: string expected\";\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n                break;\n            }\n          return null;\n        };\n        ColumnDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.ColumnDef)\n            return object;\n          var message = new $root.epoch_proto.ColumnDef();\n          if (object.id != null)\n            message.id = String(object.id);\n          if (object.name != null)\n            message.name = String(object.name);\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"TypeUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"TypeString\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"TypeInteger\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"TypeDecimal\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"TypePercent\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"TypeBoolean\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"TypeDateTime\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"TypeDate\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"TypeDayDuration\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"TypeMonetary\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"TypeDuration\":\n            case 10:\n              message.type = 10;\n              break;\n          }\n          return message;\n        };\n        ColumnDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.id = \"\";\n            object.name = \"\";\n            object.type = options.enums === String ? \"TypeUnspecified\" : 0;\n          }\n          if (message.id != null && message.hasOwnProperty(\"id\"))\n            object.id = message.id;\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioType[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioType[message.type] : message.type;\n          return object;\n        };\n        ColumnDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        ColumnDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.ColumnDef\";\n        };\n        return ColumnDef;\n      }();\n      epoch_proto.TableRow = function() {\n        function TableRow(properties) {\n          this.values = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TableRow.prototype.values = $util.emptyArray;\n        TableRow.create = function create(properties) {\n          return new TableRow(properties);\n        };\n        TableRow.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.values != null && message.values.length)\n            for (var i = 0; i < message.values.length; ++i)\n              $root.epoch_proto.Scalar.encode(message.values[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        TableRow.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TableRow.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TableRow();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.values && message.values.length))\n                  message.values = [];\n                message.values.push($root.epoch_proto.Scalar.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TableRow.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TableRow.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.values != null && message.hasOwnProperty(\"values\")) {\n            if (!Array.isArray(message.values))\n              return \"values: array expected\";\n            for (var i = 0; i < message.values.length; ++i) {\n              var error = $root.epoch_proto.Scalar.verify(message.values[i]);\n              if (error)\n                return \"values.\" + error;\n            }\n          }\n          return null;\n        };\n        TableRow.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TableRow)\n            return object;\n          var message = new $root.epoch_proto.TableRow();\n          if (object.values) {\n            if (!Array.isArray(object.values))\n              throw TypeError(\".epoch_proto.TableRow.values: array expected\");\n            message.values = [];\n            for (var i = 0; i < object.values.length; ++i) {\n              if (typeof object.values[i] !== \"object\")\n                throw TypeError(\".epoch_proto.TableRow.values: object expected\");\n              message.values[i] = $root.epoch_proto.Scalar.fromObject(object.values[i]);\n            }\n          }\n          return message;\n        };\n        TableRow.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.values = [];\n          if (message.values && message.values.length) {\n            object.values = [];\n            for (var j = 0; j < message.values.length; ++j)\n              object.values[j] = $root.epoch_proto.Scalar.toObject(message.values[j], options);\n          }\n          return object;\n        };\n        TableRow.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TableRow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TableRow\";\n        };\n        return TableRow;\n      }();\n      epoch_proto.TableData = function() {\n        function TableData(properties) {\n          this.rows = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        TableData.prototype.rows = $util.emptyArray;\n        TableData.create = function create(properties) {\n          return new TableData(properties);\n        };\n        TableData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.rows != null && message.rows.length)\n            for (var i = 0; i < message.rows.length; ++i)\n              $root.epoch_proto.TableRow.encode(message.rows[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          return writer;\n        };\n        TableData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        TableData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.TableData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.rows && message.rows.length))\n                  message.rows = [];\n                message.rows.push($root.epoch_proto.TableRow.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        TableData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        TableData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.rows != null && message.hasOwnProperty(\"rows\")) {\n            if (!Array.isArray(message.rows))\n              return \"rows: array expected\";\n            for (var i = 0; i < message.rows.length; ++i) {\n              var error = $root.epoch_proto.TableRow.verify(message.rows[i]);\n              if (error)\n                return \"rows.\" + error;\n            }\n          }\n          return null;\n        };\n        TableData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.TableData)\n            return object;\n          var message = new $root.epoch_proto.TableData();\n          if (object.rows) {\n            if (!Array.isArray(object.rows))\n              throw TypeError(\".epoch_proto.TableData.rows: array expected\");\n            message.rows = [];\n            for (var i = 0; i < object.rows.length; ++i) {\n              if (typeof object.rows[i] !== \"object\")\n                throw TypeError(\".epoch_proto.TableData.rows: object expected\");\n              message.rows[i] = $root.epoch_proto.TableRow.fromObject(object.rows[i]);\n            }\n          }\n          return message;\n        };\n        TableData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.rows = [];\n          if (message.rows && message.rows.length) {\n            object.rows = [];\n            for (var j = 0; j < message.rows.length; ++j)\n              object.rows[j] = $root.epoch_proto.TableRow.toObject(message.rows[j], options);\n          }\n          return object;\n        };\n        TableData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        TableData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.TableData\";\n        };\n        return TableData;\n      }();\n      epoch_proto.Table = function() {\n        function Table(properties) {\n          this.columns = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Table.prototype.type = 0;\n        Table.prototype.category = \"\";\n        Table.prototype.title = \"\";\n        Table.prototype.columns = $util.emptyArray;\n        Table.prototype.data = null;\n        Table.create = function create(properties) {\n          return new Table(properties);\n        };\n        Table.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.category);\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).string(message.title);\n          if (message.columns != null && message.columns.length)\n            for (var i = 0; i < message.columns.length; ++i)\n              $root.epoch_proto.ColumnDef.encode(message.columns[i], writer.uint32(\n                /* id 4, wireType 2 =*/\n                34\n              ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.TableData.encode(message.data, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          return writer;\n        };\n        Table.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Table.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Table();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.category = reader.string();\n                break;\n              }\n              case 3: {\n                message.title = reader.string();\n                break;\n              }\n              case 4: {\n                if (!(message.columns && message.columns.length))\n                  message.columns = [];\n                message.columns.push($root.epoch_proto.ColumnDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 5: {\n                message.data = $root.epoch_proto.TableData.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Table.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Table.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.columns != null && message.hasOwnProperty(\"columns\")) {\n            if (!Array.isArray(message.columns))\n              return \"columns: array expected\";\n            for (var i = 0; i < message.columns.length; ++i) {\n              var error = $root.epoch_proto.ColumnDef.verify(message.columns[i]);\n              if (error)\n                return \"columns.\" + error;\n            }\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.TableData.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          return null;\n        };\n        Table.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Table)\n            return object;\n          var message = new $root.epoch_proto.Table();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.columns) {\n            if (!Array.isArray(object.columns))\n              throw TypeError(\".epoch_proto.Table.columns: array expected\");\n            message.columns = [];\n            for (var i = 0; i < object.columns.length; ++i) {\n              if (typeof object.columns[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Table.columns: object expected\");\n              message.columns[i] = $root.epoch_proto.ColumnDef.fromObject(object.columns[i]);\n            }\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.Table.data: object expected\");\n            message.data = $root.epoch_proto.TableData.fromObject(object.data);\n          }\n          return message;\n        };\n        Table.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.columns = [];\n          if (options.defaults) {\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n            object.title = \"\";\n            object.data = null;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.columns && message.columns.length) {\n            object.columns = [];\n            for (var j = 0; j < message.columns.length; ++j)\n              object.columns[j] = $root.epoch_proto.ColumnDef.toObject(message.columns[j], options);\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.TableData.toObject(message.data, options);\n          return object;\n        };\n        Table.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Table.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Table\";\n        };\n        return Table;\n      }();\n      epoch_proto.CardData = function() {\n        function CardData(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        CardData.prototype.title = \"\";\n        CardData.prototype.value = null;\n        CardData.prototype.type = 0;\n        CardData.prototype.group = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        CardData.create = function create(properties) {\n          return new CardData(properties);\n        };\n        CardData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.title);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            $root.epoch_proto.Scalar.encode(message.value, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          if (message.group != null && Object.hasOwnProperty.call(message, \"group\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint64(message.group);\n          return writer;\n        };\n        CardData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        CardData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.CardData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.title = reader.string();\n                break;\n              }\n              case 2: {\n                message.value = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              case 4: {\n                message.group = reader.uint64();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        CardData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        CardData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.value);\n            if (error)\n              return \"value.\" + error;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n                break;\n            }\n          if (message.group != null && message.hasOwnProperty(\"group\")) {\n            if (!$util.isInteger(message.group) && !(message.group && $util.isInteger(message.group.low) && $util.isInteger(message.group.high)))\n              return \"group: integer|Long expected\";\n          }\n          return null;\n        };\n        CardData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.CardData)\n            return object;\n          var message = new $root.epoch_proto.CardData();\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.value != null) {\n            if (typeof object.value !== \"object\")\n              throw TypeError(\".epoch_proto.CardData.value: object expected\");\n            message.value = $root.epoch_proto.Scalar.fromObject(object.value);\n          }\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"TypeUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"TypeString\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"TypeInteger\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"TypeDecimal\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"TypePercent\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"TypeBoolean\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"TypeDateTime\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"TypeDate\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"TypeDayDuration\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"TypeMonetary\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"TypeDuration\":\n            case 10:\n              message.type = 10;\n              break;\n          }\n          if (object.group != null) {\n            if ($util.Long)\n              (message.group = $util.Long.fromValue(object.group)).unsigned = true;\n            else if (typeof object.group === \"string\")\n              message.group = parseInt(object.group, 10);\n            else if (typeof object.group === \"number\")\n              message.group = object.group;\n            else if (typeof object.group === \"object\")\n              message.group = new $util.LongBits(object.group.low >>> 0, object.group.high >>> 0).toNumber(true);\n          }\n          return message;\n        };\n        CardData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.title = \"\";\n            object.value = null;\n            object.type = options.enums === String ? \"TypeUnspecified\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.group = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.group = options.longs === String ? \"0\" : 0;\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = $root.epoch_proto.Scalar.toObject(message.value, options);\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioType[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioType[message.type] : message.type;\n          if (message.group != null && message.hasOwnProperty(\"group\"))\n            if (typeof message.group === \"number\")\n              object.group = options.longs === String ? String(message.group) : message.group;\n            else\n              object.group = options.longs === String ? $util.Long.prototype.toString.call(message.group) : options.longs === Number ? new $util.LongBits(message.group.low >>> 0, message.group.high >>> 0).toNumber(true) : message.group;\n          return object;\n        };\n        CardData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        CardData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.CardData\";\n        };\n        return CardData;\n      }();\n      epoch_proto.CardDef = function() {\n        function CardDef(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        CardDef.prototype.type = 0;\n        CardDef.prototype.category = \"\";\n        CardDef.prototype.data = $util.emptyArray;\n        CardDef.prototype.groupSize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        CardDef.create = function create(properties) {\n          return new CardDef(properties);\n        };\n        CardDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.category);\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.CardData.encode(message.data[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.groupSize != null && Object.hasOwnProperty.call(message, \"groupSize\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint64(message.groupSize);\n          return writer;\n        };\n        CardDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        CardDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.CardDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.category = reader.string();\n                break;\n              }\n              case 3: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.CardData.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.groupSize = reader.uint64();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        CardDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        CardDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.CardData.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          if (message.groupSize != null && message.hasOwnProperty(\"groupSize\")) {\n            if (!$util.isInteger(message.groupSize) && !(message.groupSize && $util.isInteger(message.groupSize.low) && $util.isInteger(message.groupSize.high)))\n              return \"groupSize: integer|Long expected\";\n          }\n          return null;\n        };\n        CardDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.CardDef)\n            return object;\n          var message = new $root.epoch_proto.CardDef();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.CardDef.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.CardDef.data: object expected\");\n              message.data[i] = $root.epoch_proto.CardData.fromObject(object.data[i]);\n            }\n          }\n          if (object.groupSize != null) {\n            if ($util.Long)\n              (message.groupSize = $util.Long.fromValue(object.groupSize)).unsigned = true;\n            else if (typeof object.groupSize === \"string\")\n              message.groupSize = parseInt(object.groupSize, 10);\n            else if (typeof object.groupSize === \"number\")\n              message.groupSize = object.groupSize;\n            else if (typeof object.groupSize === \"object\")\n              message.groupSize = new $util.LongBits(object.groupSize.low >>> 0, object.groupSize.high >>> 0).toNumber(true);\n          }\n          return message;\n        };\n        CardDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults) {\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.groupSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.groupSize = options.longs === String ? \"0\" : 0;\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.CardData.toObject(message.data[j], options);\n          }\n          if (message.groupSize != null && message.hasOwnProperty(\"groupSize\"))\n            if (typeof message.groupSize === \"number\")\n              object.groupSize = options.longs === String ? String(message.groupSize) : message.groupSize;\n            else\n              object.groupSize = options.longs === String ? $util.Long.prototype.toString.call(message.groupSize) : options.longs === Number ? new $util.LongBits(message.groupSize.low >>> 0, message.groupSize.high >>> 0).toNumber(true) : message.groupSize;\n          return object;\n        };\n        CardDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        CardDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.CardDef\";\n        };\n        return CardDef;\n      }();\n      epoch_proto.AxisDef = function() {\n        function AxisDef(properties) {\n          this.categories = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        AxisDef.prototype.type = null;\n        AxisDef.prototype.label = null;\n        AxisDef.prototype.categories = $util.emptyArray;\n        var $oneOfFields;\n        Object.defineProperty(AxisDef.prototype, \"_type\", {\n          get: $util.oneOfGetter($oneOfFields = [\"type\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(AxisDef.prototype, \"_label\", {\n          get: $util.oneOfGetter($oneOfFields = [\"label\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        AxisDef.create = function create(properties) {\n          return new AxisDef(properties);\n        };\n        AxisDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int32(message.type);\n          if (message.label != null && Object.hasOwnProperty.call(message, \"label\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.label);\n          if (message.categories != null && message.categories.length)\n            for (var i = 0; i < message.categories.length; ++i)\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.categories[i]);\n          return writer;\n        };\n        AxisDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        AxisDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.AxisDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.type = reader.int32();\n                break;\n              }\n              case 2: {\n                message.label = reader.string();\n                break;\n              }\n              case 3: {\n                if (!(message.categories && message.categories.length))\n                  message.categories = [];\n                message.categories.push(reader.string());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        AxisDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        AxisDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.type != null && message.hasOwnProperty(\"type\")) {\n            properties._type = 1;\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n                break;\n            }\n          }\n          if (message.label != null && message.hasOwnProperty(\"label\")) {\n            properties._label = 1;\n            if (!$util.isString(message.label))\n              return \"label: string expected\";\n          }\n          if (message.categories != null && message.hasOwnProperty(\"categories\")) {\n            if (!Array.isArray(message.categories))\n              return \"categories: array expected\";\n            for (var i = 0; i < message.categories.length; ++i)\n              if (!$util.isString(message.categories[i]))\n                return \"categories: string[] expected\";\n          }\n          return null;\n        };\n        AxisDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.AxisDef)\n            return object;\n          var message = new $root.epoch_proto.AxisDef();\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"AxisUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"AxisLinear\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"AxisLogarithmic\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"AxisDateTime\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"AxisCategory\":\n            case 4:\n              message.type = 4;\n              break;\n          }\n          if (object.label != null)\n            message.label = String(object.label);\n          if (object.categories) {\n            if (!Array.isArray(object.categories))\n              throw TypeError(\".epoch_proto.AxisDef.categories: array expected\");\n            message.categories = [];\n            for (var i = 0; i < object.categories.length; ++i)\n              message.categories[i] = String(object.categories[i]);\n          }\n          return message;\n        };\n        AxisDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.categories = [];\n          if (message.type != null && message.hasOwnProperty(\"type\")) {\n            object.type = options.enums === String ? $root.epoch_proto.AxisType[message.type] === void 0 ? message.type : $root.epoch_proto.AxisType[message.type] : message.type;\n            if (options.oneofs)\n              object._type = \"type\";\n          }\n          if (message.label != null && message.hasOwnProperty(\"label\")) {\n            object.label = message.label;\n            if (options.oneofs)\n              object._label = \"label\";\n          }\n          if (message.categories && message.categories.length) {\n            object.categories = [];\n            for (var j = 0; j < message.categories.length; ++j)\n              object.categories[j] = message.categories[j];\n          }\n          return object;\n        };\n        AxisDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        AxisDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.AxisDef\";\n        };\n        return AxisDef;\n      }();\n      epoch_proto.ChartDef = function() {\n        function ChartDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        ChartDef.prototype.id = \"\";\n        ChartDef.prototype.title = \"\";\n        ChartDef.prototype.type = 0;\n        ChartDef.prototype.category = \"\";\n        ChartDef.prototype.yAxis = null;\n        ChartDef.prototype.xAxis = null;\n        var $oneOfFields;\n        Object.defineProperty(ChartDef.prototype, \"_yAxis\", {\n          get: $util.oneOfGetter($oneOfFields = [\"yAxis\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(ChartDef.prototype, \"_xAxis\", {\n          get: $util.oneOfGetter($oneOfFields = [\"xAxis\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        ChartDef.create = function create(properties) {\n          return new ChartDef(properties);\n        };\n        ChartDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.id);\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.title);\n          if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.type);\n          if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n            writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).string(message.category);\n          if (message.yAxis != null && Object.hasOwnProperty.call(message, \"yAxis\"))\n            $root.epoch_proto.AxisDef.encode(message.yAxis, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          if (message.xAxis != null && Object.hasOwnProperty.call(message, \"xAxis\"))\n            $root.epoch_proto.AxisDef.encode(message.xAxis, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          return writer;\n        };\n        ChartDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        ChartDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.ChartDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.id = reader.string();\n                break;\n              }\n              case 2: {\n                message.title = reader.string();\n                break;\n              }\n              case 3: {\n                message.type = reader.int32();\n                break;\n              }\n              case 4: {\n                message.category = reader.string();\n                break;\n              }\n              case 5: {\n                message.yAxis = $root.epoch_proto.AxisDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 6: {\n                message.xAxis = $root.epoch_proto.AxisDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        ChartDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        ChartDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.id != null && message.hasOwnProperty(\"id\")) {\n            if (!$util.isString(message.id))\n              return \"id: string expected\";\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            switch (message.type) {\n              default:\n                return \"type: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          if (message.category != null && message.hasOwnProperty(\"category\")) {\n            if (!$util.isString(message.category))\n              return \"category: string expected\";\n          }\n          if (message.yAxis != null && message.hasOwnProperty(\"yAxis\")) {\n            properties._yAxis = 1;\n            {\n              var error = $root.epoch_proto.AxisDef.verify(message.yAxis);\n              if (error)\n                return \"yAxis.\" + error;\n            }\n          }\n          if (message.xAxis != null && message.hasOwnProperty(\"xAxis\")) {\n            properties._xAxis = 1;\n            {\n              var error = $root.epoch_proto.AxisDef.verify(message.xAxis);\n              if (error)\n                return \"xAxis.\" + error;\n            }\n          }\n          return null;\n        };\n        ChartDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.ChartDef)\n            return object;\n          var message = new $root.epoch_proto.ChartDef();\n          if (object.id != null)\n            message.id = String(object.id);\n          if (object.title != null)\n            message.title = String(object.title);\n          switch (object.type) {\n            default:\n              if (typeof object.type === \"number\") {\n                message.type = object.type;\n                break;\n              }\n              break;\n            case \"WidgetUnspecified\":\n            case 0:\n              message.type = 0;\n              break;\n            case \"WidgetCard\":\n            case 1:\n              message.type = 1;\n              break;\n            case \"WidgetLines\":\n            case 2:\n              message.type = 2;\n              break;\n            case \"WidgetBar\":\n            case 3:\n              message.type = 3;\n              break;\n            case \"WidgetDataTable\":\n            case 4:\n              message.type = 4;\n              break;\n            case \"WidgetXRange\":\n            case 5:\n              message.type = 5;\n              break;\n            case \"WidgetHistogram\":\n            case 6:\n              message.type = 6;\n              break;\n            case \"WidgetPie\":\n            case 7:\n              message.type = 7;\n              break;\n            case \"WidgetHeatMap\":\n            case 8:\n              message.type = 8;\n              break;\n            case \"WidgetBoxPlot\":\n            case 9:\n              message.type = 9;\n              break;\n            case \"WidgetArea\":\n            case 10:\n              message.type = 10;\n              break;\n            case \"WidgetColumn\":\n            case 11:\n              message.type = 11;\n              break;\n          }\n          if (object.category != null)\n            message.category = String(object.category);\n          if (object.yAxis != null) {\n            if (typeof object.yAxis !== \"object\")\n              throw TypeError(\".epoch_proto.ChartDef.yAxis: object expected\");\n            message.yAxis = $root.epoch_proto.AxisDef.fromObject(object.yAxis);\n          }\n          if (object.xAxis != null) {\n            if (typeof object.xAxis !== \"object\")\n              throw TypeError(\".epoch_proto.ChartDef.xAxis: object expected\");\n            message.xAxis = $root.epoch_proto.AxisDef.fromObject(object.xAxis);\n          }\n          return message;\n        };\n        ChartDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.id = \"\";\n            object.title = \"\";\n            object.type = options.enums === String ? \"WidgetUnspecified\" : 0;\n            object.category = \"\";\n          }\n          if (message.id != null && message.hasOwnProperty(\"id\"))\n            object.id = message.id;\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.type != null && message.hasOwnProperty(\"type\"))\n            object.type = options.enums === String ? $root.epoch_proto.EpochFolioDashboardWidget[message.type] === void 0 ? message.type : $root.epoch_proto.EpochFolioDashboardWidget[message.type] : message.type;\n          if (message.category != null && message.hasOwnProperty(\"category\"))\n            object.category = message.category;\n          if (message.yAxis != null && message.hasOwnProperty(\"yAxis\")) {\n            object.yAxis = $root.epoch_proto.AxisDef.toObject(message.yAxis, options);\n            if (options.oneofs)\n              object._yAxis = \"yAxis\";\n          }\n          if (message.xAxis != null && message.hasOwnProperty(\"xAxis\")) {\n            object.xAxis = $root.epoch_proto.AxisDef.toObject(message.xAxis, options);\n            if (options.oneofs)\n              object._xAxis = \"xAxis\";\n          }\n          return object;\n        };\n        ChartDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        ChartDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.ChartDef\";\n        };\n        return ChartDef;\n      }();\n      epoch_proto.StraightLineDef = function() {\n        function StraightLineDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        StraightLineDef.prototype.title = \"\";\n        StraightLineDef.prototype.value = 0;\n        StraightLineDef.prototype.vertical = false;\n        StraightLineDef.create = function create(properties) {\n          return new StraightLineDef(properties);\n        };\n        StraightLineDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.title != null && Object.hasOwnProperty.call(message, \"title\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.title);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.value);\n          if (message.vertical != null && Object.hasOwnProperty.call(message, \"vertical\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).bool(message.vertical);\n          return writer;\n        };\n        StraightLineDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        StraightLineDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.StraightLineDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.title = reader.string();\n                break;\n              }\n              case 2: {\n                message.value = reader.double();\n                break;\n              }\n              case 3: {\n                message.vertical = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        StraightLineDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        StraightLineDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.title != null && message.hasOwnProperty(\"title\")) {\n            if (!$util.isString(message.title))\n              return \"title: string expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\")) {\n            if (typeof message.vertical !== \"boolean\")\n              return \"vertical: boolean expected\";\n          }\n          return null;\n        };\n        StraightLineDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.StraightLineDef)\n            return object;\n          var message = new $root.epoch_proto.StraightLineDef();\n          if (object.title != null)\n            message.title = String(object.title);\n          if (object.value != null)\n            message.value = Number(object.value);\n          if (object.vertical != null)\n            message.vertical = Boolean(object.vertical);\n          return message;\n        };\n        StraightLineDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.title = \"\";\n            object.value = 0;\n            object.vertical = false;\n          }\n          if (message.title != null && message.hasOwnProperty(\"title\"))\n            object.title = message.title;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\"))\n            object.vertical = message.vertical;\n          return object;\n        };\n        StraightLineDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        StraightLineDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.StraightLineDef\";\n        };\n        return StraightLineDef;\n      }();\n      epoch_proto.Band = function() {\n        function Band(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Band.prototype.from = null;\n        Band.prototype.to = null;\n        Band.create = function create(properties) {\n          return new Band(properties);\n        };\n        Band.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.from != null && Object.hasOwnProperty.call(message, \"from\"))\n            $root.epoch_proto.Scalar.encode(message.from, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.to != null && Object.hasOwnProperty.call(message, \"to\"))\n            $root.epoch_proto.Scalar.encode(message.to, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          return writer;\n        };\n        Band.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Band.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Band();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.from = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.to = $root.epoch_proto.Scalar.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Band.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Band.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.from != null && message.hasOwnProperty(\"from\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.from);\n            if (error)\n              return \"from.\" + error;\n          }\n          if (message.to != null && message.hasOwnProperty(\"to\")) {\n            var error = $root.epoch_proto.Scalar.verify(message.to);\n            if (error)\n              return \"to.\" + error;\n          }\n          return null;\n        };\n        Band.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Band)\n            return object;\n          var message = new $root.epoch_proto.Band();\n          if (object.from != null) {\n            if (typeof object.from !== \"object\")\n              throw TypeError(\".epoch_proto.Band.from: object expected\");\n            message.from = $root.epoch_proto.Scalar.fromObject(object.from);\n          }\n          if (object.to != null) {\n            if (typeof object.to !== \"object\")\n              throw TypeError(\".epoch_proto.Band.to: object expected\");\n            message.to = $root.epoch_proto.Scalar.fromObject(object.to);\n          }\n          return message;\n        };\n        Band.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.from = null;\n            object.to = null;\n          }\n          if (message.from != null && message.hasOwnProperty(\"from\"))\n            object.from = $root.epoch_proto.Scalar.toObject(message.from, options);\n          if (message.to != null && message.hasOwnProperty(\"to\"))\n            object.to = $root.epoch_proto.Scalar.toObject(message.to, options);\n          return object;\n        };\n        Band.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Band.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Band\";\n        };\n        return Band;\n      }();\n      epoch_proto.Point = function() {\n        function Point(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Point.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        Point.prototype.y = 0;\n        Point.create = function create(properties) {\n          return new Point(properties);\n        };\n        Point.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int64(message.x);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.y);\n          return writer;\n        };\n        Point.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Point.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Point();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.int64();\n                break;\n              }\n              case 2: {\n                message.y = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Point.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Point.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (typeof message.y !== \"number\")\n              return \"y: number expected\";\n          }\n          return null;\n        };\n        Point.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Point)\n            return object;\n          var message = new $root.epoch_proto.Point();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = false;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber();\n          }\n          if (object.y != null)\n            message.y = Number(object.y);\n          return message;\n        };\n        Point.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            object.y = 0;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber() : message.x;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;\n          return object;\n        };\n        Point.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Point\";\n        };\n        return Point;\n      }();\n      epoch_proto.Line = function() {\n        function Line(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Line.prototype.data = $util.emptyArray;\n        Line.prototype.name = \"\";\n        Line.prototype.dashStyle = null;\n        Line.prototype.lineWidth = null;\n        var $oneOfFields;\n        Object.defineProperty(Line.prototype, \"_dashStyle\", {\n          get: $util.oneOfGetter($oneOfFields = [\"dashStyle\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Object.defineProperty(Line.prototype, \"_lineWidth\", {\n          get: $util.oneOfGetter($oneOfFields = [\"lineWidth\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Line.create = function create(properties) {\n          return new Line(properties);\n        };\n        Line.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.Point.encode(message.data[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).string(message.name);\n          if (message.dashStyle != null && Object.hasOwnProperty.call(message, \"dashStyle\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).int32(message.dashStyle);\n          if (message.lineWidth != null && Object.hasOwnProperty.call(message, \"lineWidth\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.lineWidth);\n          return writer;\n        };\n        Line.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Line.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Line();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.Point.decode(reader, reader.uint32()));\n                break;\n              }\n              case 2: {\n                message.name = reader.string();\n                break;\n              }\n              case 3: {\n                message.dashStyle = reader.int32();\n                break;\n              }\n              case 4: {\n                message.lineWidth = reader.uint32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Line.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Line.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.Point.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.dashStyle != null && message.hasOwnProperty(\"dashStyle\")) {\n            properties._dashStyle = 1;\n            switch (message.dashStyle) {\n              default:\n                return \"dashStyle: enum value expected\";\n              case 0:\n              case 1:\n              case 2:\n              case 3:\n              case 4:\n              case 5:\n              case 6:\n              case 7:\n              case 8:\n              case 9:\n              case 10:\n              case 11:\n                break;\n            }\n          }\n          if (message.lineWidth != null && message.hasOwnProperty(\"lineWidth\")) {\n            properties._lineWidth = 1;\n            if (!$util.isInteger(message.lineWidth))\n              return \"lineWidth: integer expected\";\n          }\n          return null;\n        };\n        Line.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Line)\n            return object;\n          var message = new $root.epoch_proto.Line();\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.Line.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.Line.data: object expected\");\n              message.data[i] = $root.epoch_proto.Point.fromObject(object.data[i]);\n            }\n          }\n          if (object.name != null)\n            message.name = String(object.name);\n          switch (object.dashStyle) {\n            default:\n              if (typeof object.dashStyle === \"number\") {\n                message.dashStyle = object.dashStyle;\n                break;\n              }\n              break;\n            case \"DashStyleUnspecified\":\n            case 0:\n              message.dashStyle = 0;\n              break;\n            case \"Solid\":\n            case 1:\n              message.dashStyle = 1;\n              break;\n            case \"ShortDash\":\n            case 2:\n              message.dashStyle = 2;\n              break;\n            case \"ShortDot\":\n            case 3:\n              message.dashStyle = 3;\n              break;\n            case \"ShortDashDot\":\n            case 4:\n              message.dashStyle = 4;\n              break;\n            case \"ShortDashDotDot\":\n            case 5:\n              message.dashStyle = 5;\n              break;\n            case \"Dot\":\n            case 6:\n              message.dashStyle = 6;\n              break;\n            case \"Dash\":\n            case 7:\n              message.dashStyle = 7;\n              break;\n            case \"LongDash\":\n            case 8:\n              message.dashStyle = 8;\n              break;\n            case \"DashDot\":\n            case 9:\n              message.dashStyle = 9;\n              break;\n            case \"LongDashDot\":\n            case 10:\n              message.dashStyle = 10;\n              break;\n            case \"LongDashDotDot\":\n            case 11:\n              message.dashStyle = 11;\n              break;\n          }\n          if (object.lineWidth != null)\n            message.lineWidth = object.lineWidth >>> 0;\n          return message;\n        };\n        Line.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults)\n            object.name = \"\";\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.Point.toObject(message.data[j], options);\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.dashStyle != null && message.hasOwnProperty(\"dashStyle\")) {\n            object.dashStyle = options.enums === String ? $root.epoch_proto.DashStyle[message.dashStyle] === void 0 ? message.dashStyle : $root.epoch_proto.DashStyle[message.dashStyle] : message.dashStyle;\n            if (options.oneofs)\n              object._dashStyle = \"dashStyle\";\n          }\n          if (message.lineWidth != null && message.hasOwnProperty(\"lineWidth\")) {\n            object.lineWidth = message.lineWidth;\n            if (options.oneofs)\n              object._lineWidth = \"lineWidth\";\n          }\n          return object;\n        };\n        Line.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Line.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Line\";\n        };\n        return Line;\n      }();\n      epoch_proto.LinesDef = function() {\n        function LinesDef(properties) {\n          this.lines = [];\n          this.straightLines = [];\n          this.yPlotBands = [];\n          this.xPlotBands = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        LinesDef.prototype.chartDef = null;\n        LinesDef.prototype.lines = $util.emptyArray;\n        LinesDef.prototype.straightLines = $util.emptyArray;\n        LinesDef.prototype.yPlotBands = $util.emptyArray;\n        LinesDef.prototype.xPlotBands = $util.emptyArray;\n        LinesDef.prototype.overlay = null;\n        LinesDef.prototype.stacked = false;\n        var $oneOfFields;\n        Object.defineProperty(LinesDef.prototype, \"_overlay\", {\n          get: $util.oneOfGetter($oneOfFields = [\"overlay\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        LinesDef.create = function create(properties) {\n          return new LinesDef(properties);\n        };\n        LinesDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.lines != null && message.lines.length)\n            for (var i = 0; i < message.lines.length; ++i)\n              $root.epoch_proto.Line.encode(message.lines[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.yPlotBands != null && message.yPlotBands.length)\n            for (var i = 0; i < message.yPlotBands.length; ++i)\n              $root.epoch_proto.Band.encode(message.yPlotBands[i], writer.uint32(\n                /* id 4, wireType 2 =*/\n                34\n              ).fork()).ldelim();\n          if (message.xPlotBands != null && message.xPlotBands.length)\n            for (var i = 0; i < message.xPlotBands.length; ++i)\n              $root.epoch_proto.Band.encode(message.xPlotBands[i], writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n          if (message.overlay != null && Object.hasOwnProperty.call(message, \"overlay\"))\n            $root.epoch_proto.Line.encode(message.overlay, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          if (message.stacked != null && Object.hasOwnProperty.call(message, \"stacked\"))\n            writer.uint32(\n              /* id 7, wireType 0 =*/\n              56\n            ).bool(message.stacked);\n          return writer;\n        };\n        LinesDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        LinesDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.LinesDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.lines && message.lines.length))\n                  message.lines = [];\n                message.lines.push($root.epoch_proto.Line.decode(reader, reader.uint32()));\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                if (!(message.yPlotBands && message.yPlotBands.length))\n                  message.yPlotBands = [];\n                message.yPlotBands.push($root.epoch_proto.Band.decode(reader, reader.uint32()));\n                break;\n              }\n              case 5: {\n                if (!(message.xPlotBands && message.xPlotBands.length))\n                  message.xPlotBands = [];\n                message.xPlotBands.push($root.epoch_proto.Band.decode(reader, reader.uint32()));\n                break;\n              }\n              case 6: {\n                message.overlay = $root.epoch_proto.Line.decode(reader, reader.uint32());\n                break;\n              }\n              case 7: {\n                message.stacked = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        LinesDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        LinesDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.lines != null && message.hasOwnProperty(\"lines\")) {\n            if (!Array.isArray(message.lines))\n              return \"lines: array expected\";\n            for (var i = 0; i < message.lines.length; ++i) {\n              var error = $root.epoch_proto.Line.verify(message.lines[i]);\n              if (error)\n                return \"lines.\" + error;\n            }\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.yPlotBands != null && message.hasOwnProperty(\"yPlotBands\")) {\n            if (!Array.isArray(message.yPlotBands))\n              return \"yPlotBands: array expected\";\n            for (var i = 0; i < message.yPlotBands.length; ++i) {\n              var error = $root.epoch_proto.Band.verify(message.yPlotBands[i]);\n              if (error)\n                return \"yPlotBands.\" + error;\n            }\n          }\n          if (message.xPlotBands != null && message.hasOwnProperty(\"xPlotBands\")) {\n            if (!Array.isArray(message.xPlotBands))\n              return \"xPlotBands: array expected\";\n            for (var i = 0; i < message.xPlotBands.length; ++i) {\n              var error = $root.epoch_proto.Band.verify(message.xPlotBands[i]);\n              if (error)\n                return \"xPlotBands.\" + error;\n            }\n          }\n          if (message.overlay != null && message.hasOwnProperty(\"overlay\")) {\n            properties._overlay = 1;\n            {\n              var error = $root.epoch_proto.Line.verify(message.overlay);\n              if (error)\n                return \"overlay.\" + error;\n            }\n          }\n          if (message.stacked != null && message.hasOwnProperty(\"stacked\")) {\n            if (typeof message.stacked !== \"boolean\")\n              return \"stacked: boolean expected\";\n          }\n          return null;\n        };\n        LinesDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.LinesDef)\n            return object;\n          var message = new $root.epoch_proto.LinesDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.LinesDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.lines) {\n            if (!Array.isArray(object.lines))\n              throw TypeError(\".epoch_proto.LinesDef.lines: array expected\");\n            message.lines = [];\n            for (var i = 0; i < object.lines.length; ++i) {\n              if (typeof object.lines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.lines: object expected\");\n              message.lines[i] = $root.epoch_proto.Line.fromObject(object.lines[i]);\n            }\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.LinesDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.yPlotBands) {\n            if (!Array.isArray(object.yPlotBands))\n              throw TypeError(\".epoch_proto.LinesDef.yPlotBands: array expected\");\n            message.yPlotBands = [];\n            for (var i = 0; i < object.yPlotBands.length; ++i) {\n              if (typeof object.yPlotBands[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.yPlotBands: object expected\");\n              message.yPlotBands[i] = $root.epoch_proto.Band.fromObject(object.yPlotBands[i]);\n            }\n          }\n          if (object.xPlotBands) {\n            if (!Array.isArray(object.xPlotBands))\n              throw TypeError(\".epoch_proto.LinesDef.xPlotBands: array expected\");\n            message.xPlotBands = [];\n            for (var i = 0; i < object.xPlotBands.length; ++i) {\n              if (typeof object.xPlotBands[i] !== \"object\")\n                throw TypeError(\".epoch_proto.LinesDef.xPlotBands: object expected\");\n              message.xPlotBands[i] = $root.epoch_proto.Band.fromObject(object.xPlotBands[i]);\n            }\n          }\n          if (object.overlay != null) {\n            if (typeof object.overlay !== \"object\")\n              throw TypeError(\".epoch_proto.LinesDef.overlay: object expected\");\n            message.overlay = $root.epoch_proto.Line.fromObject(object.overlay);\n          }\n          if (object.stacked != null)\n            message.stacked = Boolean(object.stacked);\n          return message;\n        };\n        LinesDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.lines = [];\n            object.straightLines = [];\n            object.yPlotBands = [];\n            object.xPlotBands = [];\n          }\n          if (options.defaults) {\n            object.chartDef = null;\n            object.stacked = false;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.lines && message.lines.length) {\n            object.lines = [];\n            for (var j = 0; j < message.lines.length; ++j)\n              object.lines[j] = $root.epoch_proto.Line.toObject(message.lines[j], options);\n          }\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.yPlotBands && message.yPlotBands.length) {\n            object.yPlotBands = [];\n            for (var j = 0; j < message.yPlotBands.length; ++j)\n              object.yPlotBands[j] = $root.epoch_proto.Band.toObject(message.yPlotBands[j], options);\n          }\n          if (message.xPlotBands && message.xPlotBands.length) {\n            object.xPlotBands = [];\n            for (var j = 0; j < message.xPlotBands.length; ++j)\n              object.xPlotBands[j] = $root.epoch_proto.Band.toObject(message.xPlotBands[j], options);\n          }\n          if (message.overlay != null && message.hasOwnProperty(\"overlay\")) {\n            object.overlay = $root.epoch_proto.Line.toObject(message.overlay, options);\n            if (options.oneofs)\n              object._overlay = \"overlay\";\n          }\n          if (message.stacked != null && message.hasOwnProperty(\"stacked\"))\n            object.stacked = message.stacked;\n          return object;\n        };\n        LinesDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        LinesDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.LinesDef\";\n        };\n        return LinesDef;\n      }();\n      epoch_proto.HeatMapPoint = function() {\n        function HeatMapPoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HeatMapPoint.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        HeatMapPoint.prototype.y = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        HeatMapPoint.prototype.value = 0;\n        HeatMapPoint.create = function create(properties) {\n          return new HeatMapPoint(properties);\n        };\n        HeatMapPoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).uint64(message.x);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).uint64(message.y);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.value);\n          return writer;\n        };\n        HeatMapPoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HeatMapPoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HeatMapPoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.uint64();\n                break;\n              }\n              case 2: {\n                message.y = reader.uint64();\n                break;\n              }\n              case 3: {\n                message.value = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HeatMapPoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HeatMapPoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (!$util.isInteger(message.y) && !(message.y && $util.isInteger(message.y.low) && $util.isInteger(message.y.high)))\n              return \"y: integer|Long expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          return null;\n        };\n        HeatMapPoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HeatMapPoint)\n            return object;\n          var message = new $root.epoch_proto.HeatMapPoint();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = true;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber(true);\n          }\n          if (object.y != null) {\n            if ($util.Long)\n              (message.y = $util.Long.fromValue(object.y)).unsigned = true;\n            else if (typeof object.y === \"string\")\n              message.y = parseInt(object.y, 10);\n            else if (typeof object.y === \"number\")\n              message.y = object.y;\n            else if (typeof object.y === \"object\")\n              message.y = new $util.LongBits(object.y.low >>> 0, object.y.high >>> 0).toNumber(true);\n          }\n          if (object.value != null)\n            message.value = Number(object.value);\n          return message;\n        };\n        HeatMapPoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.y = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.y = options.longs === String ? \"0\" : 0;\n            object.value = 0;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber(true) : message.x;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            if (typeof message.y === \"number\")\n              object.y = options.longs === String ? String(message.y) : message.y;\n            else\n              object.y = options.longs === String ? $util.Long.prototype.toString.call(message.y) : options.longs === Number ? new $util.LongBits(message.y.low >>> 0, message.y.high >>> 0).toNumber(true) : message.y;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          return object;\n        };\n        HeatMapPoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HeatMapPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HeatMapPoint\";\n        };\n        return HeatMapPoint;\n      }();\n      epoch_proto.HeatMapDef = function() {\n        function HeatMapDef(properties) {\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HeatMapDef.prototype.chartDef = null;\n        HeatMapDef.prototype.points = $util.emptyArray;\n        HeatMapDef.create = function create(properties) {\n          return new HeatMapDef(properties);\n        };\n        HeatMapDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.HeatMapPoint.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        HeatMapDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HeatMapDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HeatMapDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.HeatMapPoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HeatMapDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HeatMapDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.HeatMapPoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        HeatMapDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HeatMapDef)\n            return object;\n          var message = new $root.epoch_proto.HeatMapDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.HeatMapDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.HeatMapDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.HeatMapDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.HeatMapPoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        HeatMapDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.points = [];\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.HeatMapPoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        HeatMapDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HeatMapDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HeatMapDef\";\n        };\n        return HeatMapDef;\n      }();\n      epoch_proto.BarDef = function() {\n        function BarDef(properties) {\n          this.straightLines = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BarDef.prototype.chartDef = null;\n        BarDef.prototype.data = null;\n        BarDef.prototype.straightLines = $util.emptyArray;\n        BarDef.prototype.barWidth = null;\n        BarDef.prototype.vertical = false;\n        var $oneOfFields;\n        Object.defineProperty(BarDef.prototype, \"_barWidth\", {\n          get: $util.oneOfGetter($oneOfFields = [\"barWidth\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        BarDef.create = function create(properties) {\n          return new BarDef(properties);\n        };\n        BarDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.Array.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.barWidth != null && Object.hasOwnProperty.call(message, \"barWidth\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.barWidth);\n          if (message.vertical != null && Object.hasOwnProperty.call(message, \"vertical\"))\n            writer.uint32(\n              /* id 5, wireType 0 =*/\n              40\n            ).bool(message.vertical);\n          return writer;\n        };\n        BarDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BarDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BarDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.Array.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.barWidth = reader.uint32();\n                break;\n              }\n              case 5: {\n                message.vertical = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BarDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BarDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.Array.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.barWidth != null && message.hasOwnProperty(\"barWidth\")) {\n            properties._barWidth = 1;\n            if (!$util.isInteger(message.barWidth))\n              return \"barWidth: integer expected\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\")) {\n            if (typeof message.vertical !== \"boolean\")\n              return \"vertical: boolean expected\";\n          }\n          return null;\n        };\n        BarDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BarDef)\n            return object;\n          var message = new $root.epoch_proto.BarDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.BarDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.BarDef.data: object expected\");\n            message.data = $root.epoch_proto.Array.fromObject(object.data);\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.BarDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BarDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.barWidth != null)\n            message.barWidth = object.barWidth >>> 0;\n          if (object.vertical != null)\n            message.vertical = Boolean(object.vertical);\n          return message;\n        };\n        BarDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.straightLines = [];\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n            object.vertical = false;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.Array.toObject(message.data, options);\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.barWidth != null && message.hasOwnProperty(\"barWidth\")) {\n            object.barWidth = message.barWidth;\n            if (options.oneofs)\n              object._barWidth = \"barWidth\";\n          }\n          if (message.vertical != null && message.hasOwnProperty(\"vertical\"))\n            object.vertical = message.vertical;\n          return object;\n        };\n        BarDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BarDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BarDef\";\n        };\n        return BarDef;\n      }();\n      epoch_proto.HistogramDef = function() {\n        function HistogramDef(properties) {\n          this.straightLines = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        HistogramDef.prototype.chartDef = null;\n        HistogramDef.prototype.data = null;\n        HistogramDef.prototype.straightLines = $util.emptyArray;\n        HistogramDef.prototype.binsCount = null;\n        var $oneOfFields;\n        Object.defineProperty(HistogramDef.prototype, \"_binsCount\", {\n          get: $util.oneOfGetter($oneOfFields = [\"binsCount\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        HistogramDef.create = function create(properties) {\n          return new HistogramDef(properties);\n        };\n        HistogramDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.Array.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.straightLines != null && message.straightLines.length)\n            for (var i = 0; i < message.straightLines.length; ++i)\n              $root.epoch_proto.StraightLineDef.encode(message.straightLines[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          if (message.binsCount != null && Object.hasOwnProperty.call(message, \"binsCount\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).uint32(message.binsCount);\n          return writer;\n        };\n        HistogramDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        HistogramDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.HistogramDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.Array.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                if (!(message.straightLines && message.straightLines.length))\n                  message.straightLines = [];\n                message.straightLines.push($root.epoch_proto.StraightLineDef.decode(reader, reader.uint32()));\n                break;\n              }\n              case 4: {\n                message.binsCount = reader.uint32();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        HistogramDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        HistogramDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.Array.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          if (message.straightLines != null && message.hasOwnProperty(\"straightLines\")) {\n            if (!Array.isArray(message.straightLines))\n              return \"straightLines: array expected\";\n            for (var i = 0; i < message.straightLines.length; ++i) {\n              var error = $root.epoch_proto.StraightLineDef.verify(message.straightLines[i]);\n              if (error)\n                return \"straightLines.\" + error;\n            }\n          }\n          if (message.binsCount != null && message.hasOwnProperty(\"binsCount\")) {\n            properties._binsCount = 1;\n            if (!$util.isInteger(message.binsCount))\n              return \"binsCount: integer expected\";\n          }\n          return null;\n        };\n        HistogramDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.HistogramDef)\n            return object;\n          var message = new $root.epoch_proto.HistogramDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.HistogramDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.HistogramDef.data: object expected\");\n            message.data = $root.epoch_proto.Array.fromObject(object.data);\n          }\n          if (object.straightLines) {\n            if (!Array.isArray(object.straightLines))\n              throw TypeError(\".epoch_proto.HistogramDef.straightLines: array expected\");\n            message.straightLines = [];\n            for (var i = 0; i < object.straightLines.length; ++i) {\n              if (typeof object.straightLines[i] !== \"object\")\n                throw TypeError(\".epoch_proto.HistogramDef.straightLines: object expected\");\n              message.straightLines[i] = $root.epoch_proto.StraightLineDef.fromObject(object.straightLines[i]);\n            }\n          }\n          if (object.binsCount != null)\n            message.binsCount = object.binsCount >>> 0;\n          return message;\n        };\n        HistogramDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.straightLines = [];\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.Array.toObject(message.data, options);\n          if (message.straightLines && message.straightLines.length) {\n            object.straightLines = [];\n            for (var j = 0; j < message.straightLines.length; ++j)\n              object.straightLines[j] = $root.epoch_proto.StraightLineDef.toObject(message.straightLines[j], options);\n          }\n          if (message.binsCount != null && message.hasOwnProperty(\"binsCount\")) {\n            object.binsCount = message.binsCount;\n            if (options.oneofs)\n              object._binsCount = \"binsCount\";\n          }\n          return object;\n        };\n        HistogramDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        HistogramDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.HistogramDef\";\n        };\n        return HistogramDef;\n      }();\n      epoch_proto.BoxPlotDataPoint = function() {\n        function BoxPlotDataPoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDataPoint.prototype.low = 0;\n        BoxPlotDataPoint.prototype.q1 = 0;\n        BoxPlotDataPoint.prototype.median = 0;\n        BoxPlotDataPoint.prototype.q3 = 0;\n        BoxPlotDataPoint.prototype.high = 0;\n        BoxPlotDataPoint.create = function create(properties) {\n          return new BoxPlotDataPoint(properties);\n        };\n        BoxPlotDataPoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.low != null && Object.hasOwnProperty.call(message, \"low\"))\n            writer.uint32(\n              /* id 1, wireType 1 =*/\n              9\n            ).double(message.low);\n          if (message.q1 != null && Object.hasOwnProperty.call(message, \"q1\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.q1);\n          if (message.median != null && Object.hasOwnProperty.call(message, \"median\"))\n            writer.uint32(\n              /* id 3, wireType 1 =*/\n              25\n            ).double(message.median);\n          if (message.q3 != null && Object.hasOwnProperty.call(message, \"q3\"))\n            writer.uint32(\n              /* id 4, wireType 1 =*/\n              33\n            ).double(message.q3);\n          if (message.high != null && Object.hasOwnProperty.call(message, \"high\"))\n            writer.uint32(\n              /* id 5, wireType 1 =*/\n              41\n            ).double(message.high);\n          return writer;\n        };\n        BoxPlotDataPoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDataPoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDataPoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.low = reader.double();\n                break;\n              }\n              case 2: {\n                message.q1 = reader.double();\n                break;\n              }\n              case 3: {\n                message.median = reader.double();\n                break;\n              }\n              case 4: {\n                message.q3 = reader.double();\n                break;\n              }\n              case 5: {\n                message.high = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDataPoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.low != null && message.hasOwnProperty(\"low\")) {\n            if (typeof message.low !== \"number\")\n              return \"low: number expected\";\n          }\n          if (message.q1 != null && message.hasOwnProperty(\"q1\")) {\n            if (typeof message.q1 !== \"number\")\n              return \"q1: number expected\";\n          }\n          if (message.median != null && message.hasOwnProperty(\"median\")) {\n            if (typeof message.median !== \"number\")\n              return \"median: number expected\";\n          }\n          if (message.q3 != null && message.hasOwnProperty(\"q3\")) {\n            if (typeof message.q3 !== \"number\")\n              return \"q3: number expected\";\n          }\n          if (message.high != null && message.hasOwnProperty(\"high\")) {\n            if (typeof message.high !== \"number\")\n              return \"high: number expected\";\n          }\n          return null;\n        };\n        BoxPlotDataPoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDataPoint)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDataPoint();\n          if (object.low != null)\n            message.low = Number(object.low);\n          if (object.q1 != null)\n            message.q1 = Number(object.q1);\n          if (object.median != null)\n            message.median = Number(object.median);\n          if (object.q3 != null)\n            message.q3 = Number(object.q3);\n          if (object.high != null)\n            message.high = Number(object.high);\n          return message;\n        };\n        BoxPlotDataPoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.low = 0;\n            object.q1 = 0;\n            object.median = 0;\n            object.q3 = 0;\n            object.high = 0;\n          }\n          if (message.low != null && message.hasOwnProperty(\"low\"))\n            object.low = options.json && !isFinite(message.low) ? String(message.low) : message.low;\n          if (message.q1 != null && message.hasOwnProperty(\"q1\"))\n            object.q1 = options.json && !isFinite(message.q1) ? String(message.q1) : message.q1;\n          if (message.median != null && message.hasOwnProperty(\"median\"))\n            object.median = options.json && !isFinite(message.median) ? String(message.median) : message.median;\n          if (message.q3 != null && message.hasOwnProperty(\"q3\"))\n            object.q3 = options.json && !isFinite(message.q3) ? String(message.q3) : message.q3;\n          if (message.high != null && message.hasOwnProperty(\"high\"))\n            object.high = options.json && !isFinite(message.high) ? String(message.high) : message.high;\n          return object;\n        };\n        BoxPlotDataPoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDataPoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDataPoint\";\n        };\n        return BoxPlotDataPoint;\n      }();\n      epoch_proto.BoxPlotOutlier = function() {\n        function BoxPlotOutlier(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotOutlier.prototype.categoryIndex = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        BoxPlotOutlier.prototype.value = 0;\n        BoxPlotOutlier.create = function create(properties) {\n          return new BoxPlotOutlier(properties);\n        };\n        BoxPlotOutlier.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.categoryIndex != null && Object.hasOwnProperty.call(message, \"categoryIndex\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).uint64(message.categoryIndex);\n          if (message.value != null && Object.hasOwnProperty.call(message, \"value\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.value);\n          return writer;\n        };\n        BoxPlotOutlier.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotOutlier.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotOutlier();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.categoryIndex = reader.uint64();\n                break;\n              }\n              case 2: {\n                message.value = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotOutlier.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotOutlier.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.categoryIndex != null && message.hasOwnProperty(\"categoryIndex\")) {\n            if (!$util.isInteger(message.categoryIndex) && !(message.categoryIndex && $util.isInteger(message.categoryIndex.low) && $util.isInteger(message.categoryIndex.high)))\n              return \"categoryIndex: integer|Long expected\";\n          }\n          if (message.value != null && message.hasOwnProperty(\"value\")) {\n            if (typeof message.value !== \"number\")\n              return \"value: number expected\";\n          }\n          return null;\n        };\n        BoxPlotOutlier.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotOutlier)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotOutlier();\n          if (object.categoryIndex != null) {\n            if ($util.Long)\n              (message.categoryIndex = $util.Long.fromValue(object.categoryIndex)).unsigned = true;\n            else if (typeof object.categoryIndex === \"string\")\n              message.categoryIndex = parseInt(object.categoryIndex, 10);\n            else if (typeof object.categoryIndex === \"number\")\n              message.categoryIndex = object.categoryIndex;\n            else if (typeof object.categoryIndex === \"object\")\n              message.categoryIndex = new $util.LongBits(object.categoryIndex.low >>> 0, object.categoryIndex.high >>> 0).toNumber(true);\n          }\n          if (object.value != null)\n            message.value = Number(object.value);\n          return message;\n        };\n        BoxPlotOutlier.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.categoryIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.categoryIndex = options.longs === String ? \"0\" : 0;\n            object.value = 0;\n          }\n          if (message.categoryIndex != null && message.hasOwnProperty(\"categoryIndex\"))\n            if (typeof message.categoryIndex === \"number\")\n              object.categoryIndex = options.longs === String ? String(message.categoryIndex) : message.categoryIndex;\n            else\n              object.categoryIndex = options.longs === String ? $util.Long.prototype.toString.call(message.categoryIndex) : options.longs === Number ? new $util.LongBits(message.categoryIndex.low >>> 0, message.categoryIndex.high >>> 0).toNumber(true) : message.categoryIndex;\n          if (message.value != null && message.hasOwnProperty(\"value\"))\n            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;\n          return object;\n        };\n        BoxPlotOutlier.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotOutlier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotOutlier\";\n        };\n        return BoxPlotOutlier;\n      }();\n      epoch_proto.BoxPlotDataPointDef = function() {\n        function BoxPlotDataPointDef(properties) {\n          this.outliers = [];\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDataPointDef.prototype.outliers = $util.emptyArray;\n        BoxPlotDataPointDef.prototype.points = $util.emptyArray;\n        BoxPlotDataPointDef.create = function create(properties) {\n          return new BoxPlotDataPointDef(properties);\n        };\n        BoxPlotDataPointDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.outliers != null && message.outliers.length)\n            for (var i = 0; i < message.outliers.length; ++i)\n              $root.epoch_proto.BoxPlotOutlier.encode(message.outliers[i], writer.uint32(\n                /* id 1, wireType 2 =*/\n                10\n              ).fork()).ldelim();\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.BoxPlotDataPoint.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        BoxPlotDataPointDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDataPointDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDataPointDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                if (!(message.outliers && message.outliers.length))\n                  message.outliers = [];\n                message.outliers.push($root.epoch_proto.BoxPlotOutlier.decode(reader, reader.uint32()));\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.BoxPlotDataPoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPointDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDataPointDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.outliers != null && message.hasOwnProperty(\"outliers\")) {\n            if (!Array.isArray(message.outliers))\n              return \"outliers: array expected\";\n            for (var i = 0; i < message.outliers.length; ++i) {\n              var error = $root.epoch_proto.BoxPlotOutlier.verify(message.outliers[i]);\n              if (error)\n                return \"outliers.\" + error;\n            }\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.BoxPlotDataPoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        BoxPlotDataPointDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDataPointDef)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDataPointDef();\n          if (object.outliers) {\n            if (!Array.isArray(object.outliers))\n              throw TypeError(\".epoch_proto.BoxPlotDataPointDef.outliers: array expected\");\n            message.outliers = [];\n            for (var i = 0; i < object.outliers.length; ++i) {\n              if (typeof object.outliers[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BoxPlotDataPointDef.outliers: object expected\");\n              message.outliers[i] = $root.epoch_proto.BoxPlotOutlier.fromObject(object.outliers[i]);\n            }\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.BoxPlotDataPointDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.BoxPlotDataPointDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.BoxPlotDataPoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        BoxPlotDataPointDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.outliers = [];\n            object.points = [];\n          }\n          if (message.outliers && message.outliers.length) {\n            object.outliers = [];\n            for (var j = 0; j < message.outliers.length; ++j)\n              object.outliers[j] = $root.epoch_proto.BoxPlotOutlier.toObject(message.outliers[j], options);\n          }\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.BoxPlotDataPoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        BoxPlotDataPointDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDataPointDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDataPointDef\";\n        };\n        return BoxPlotDataPointDef;\n      }();\n      epoch_proto.BoxPlotDef = function() {\n        function BoxPlotDef(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        BoxPlotDef.prototype.chartDef = null;\n        BoxPlotDef.prototype.data = null;\n        BoxPlotDef.create = function create(properties) {\n          return new BoxPlotDef(properties);\n        };\n        BoxPlotDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n            $root.epoch_proto.BoxPlotDataPointDef.encode(message.data, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          return writer;\n        };\n        BoxPlotDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        BoxPlotDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.BoxPlotDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.data = $root.epoch_proto.BoxPlotDataPointDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        BoxPlotDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        BoxPlotDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            var error = $root.epoch_proto.BoxPlotDataPointDef.verify(message.data);\n            if (error)\n              return \"data.\" + error;\n          }\n          return null;\n        };\n        BoxPlotDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.BoxPlotDef)\n            return object;\n          var message = new $root.epoch_proto.BoxPlotDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.BoxPlotDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data != null) {\n            if (typeof object.data !== \"object\")\n              throw TypeError(\".epoch_proto.BoxPlotDef.data: object expected\");\n            message.data = $root.epoch_proto.BoxPlotDataPointDef.fromObject(object.data);\n          }\n          return message;\n        };\n        BoxPlotDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.chartDef = null;\n            object.data = null;\n          }\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data != null && message.hasOwnProperty(\"data\"))\n            object.data = $root.epoch_proto.BoxPlotDataPointDef.toObject(message.data, options);\n          return object;\n        };\n        BoxPlotDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        BoxPlotDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.BoxPlotDef\";\n        };\n        return BoxPlotDef;\n      }();\n      epoch_proto.XRangePoint = function() {\n        function XRangePoint(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        XRangePoint.prototype.x = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        XRangePoint.prototype.x2 = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n        XRangePoint.prototype.y = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n        XRangePoint.prototype.isLong = false;\n        XRangePoint.create = function create(properties) {\n          return new XRangePoint(properties);\n        };\n        XRangePoint.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.x != null && Object.hasOwnProperty.call(message, \"x\"))\n            writer.uint32(\n              /* id 1, wireType 0 =*/\n              8\n            ).int64(message.x);\n          if (message.x2 != null && Object.hasOwnProperty.call(message, \"x2\"))\n            writer.uint32(\n              /* id 2, wireType 0 =*/\n              16\n            ).int64(message.x2);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 3, wireType 0 =*/\n              24\n            ).uint64(message.y);\n          if (message.isLong != null && Object.hasOwnProperty.call(message, \"isLong\"))\n            writer.uint32(\n              /* id 4, wireType 0 =*/\n              32\n            ).bool(message.isLong);\n          return writer;\n        };\n        XRangePoint.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        XRangePoint.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.XRangePoint();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.x = reader.int64();\n                break;\n              }\n              case 2: {\n                message.x2 = reader.int64();\n                break;\n              }\n              case 3: {\n                message.y = reader.uint64();\n                break;\n              }\n              case 4: {\n                message.isLong = reader.bool();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        XRangePoint.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        XRangePoint.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.x != null && message.hasOwnProperty(\"x\")) {\n            if (!$util.isInteger(message.x) && !(message.x && $util.isInteger(message.x.low) && $util.isInteger(message.x.high)))\n              return \"x: integer|Long expected\";\n          }\n          if (message.x2 != null && message.hasOwnProperty(\"x2\")) {\n            if (!$util.isInteger(message.x2) && !(message.x2 && $util.isInteger(message.x2.low) && $util.isInteger(message.x2.high)))\n              return \"x2: integer|Long expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (!$util.isInteger(message.y) && !(message.y && $util.isInteger(message.y.low) && $util.isInteger(message.y.high)))\n              return \"y: integer|Long expected\";\n          }\n          if (message.isLong != null && message.hasOwnProperty(\"isLong\")) {\n            if (typeof message.isLong !== \"boolean\")\n              return \"isLong: boolean expected\";\n          }\n          return null;\n        };\n        XRangePoint.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.XRangePoint)\n            return object;\n          var message = new $root.epoch_proto.XRangePoint();\n          if (object.x != null) {\n            if ($util.Long)\n              (message.x = $util.Long.fromValue(object.x)).unsigned = false;\n            else if (typeof object.x === \"string\")\n              message.x = parseInt(object.x, 10);\n            else if (typeof object.x === \"number\")\n              message.x = object.x;\n            else if (typeof object.x === \"object\")\n              message.x = new $util.LongBits(object.x.low >>> 0, object.x.high >>> 0).toNumber();\n          }\n          if (object.x2 != null) {\n            if ($util.Long)\n              (message.x2 = $util.Long.fromValue(object.x2)).unsigned = false;\n            else if (typeof object.x2 === \"string\")\n              message.x2 = parseInt(object.x2, 10);\n            else if (typeof object.x2 === \"number\")\n              message.x2 = object.x2;\n            else if (typeof object.x2 === \"object\")\n              message.x2 = new $util.LongBits(object.x2.low >>> 0, object.x2.high >>> 0).toNumber();\n          }\n          if (object.y != null) {\n            if ($util.Long)\n              (message.y = $util.Long.fromValue(object.y)).unsigned = true;\n            else if (typeof object.y === \"string\")\n              message.y = parseInt(object.y, 10);\n            else if (typeof object.y === \"number\")\n              message.y = object.y;\n            else if (typeof object.y === \"object\")\n              message.y = new $util.LongBits(object.y.low >>> 0, object.y.high >>> 0).toNumber(true);\n          }\n          if (object.isLong != null)\n            message.isLong = Boolean(object.isLong);\n          return message;\n        };\n        XRangePoint.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, false);\n              object.x2 = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.x2 = options.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n              var long = new $util.Long(0, 0, true);\n              object.y = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;\n            } else\n              object.y = options.longs === String ? \"0\" : 0;\n            object.isLong = false;\n          }\n          if (message.x != null && message.hasOwnProperty(\"x\"))\n            if (typeof message.x === \"number\")\n              object.x = options.longs === String ? String(message.x) : message.x;\n            else\n              object.x = options.longs === String ? $util.Long.prototype.toString.call(message.x) : options.longs === Number ? new $util.LongBits(message.x.low >>> 0, message.x.high >>> 0).toNumber() : message.x;\n          if (message.x2 != null && message.hasOwnProperty(\"x2\"))\n            if (typeof message.x2 === \"number\")\n              object.x2 = options.longs === String ? String(message.x2) : message.x2;\n            else\n              object.x2 = options.longs === String ? $util.Long.prototype.toString.call(message.x2) : options.longs === Number ? new $util.LongBits(message.x2.low >>> 0, message.x2.high >>> 0).toNumber() : message.x2;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            if (typeof message.y === \"number\")\n              object.y = options.longs === String ? String(message.y) : message.y;\n            else\n              object.y = options.longs === String ? $util.Long.prototype.toString.call(message.y) : options.longs === Number ? new $util.LongBits(message.y.low >>> 0, message.y.high >>> 0).toNumber(true) : message.y;\n          if (message.isLong != null && message.hasOwnProperty(\"isLong\"))\n            object.isLong = message.isLong;\n          return object;\n        };\n        XRangePoint.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        XRangePoint.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.XRangePoint\";\n        };\n        return XRangePoint;\n      }();\n      epoch_proto.XRangeDef = function() {\n        function XRangeDef(properties) {\n          this.categories = [];\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        XRangeDef.prototype.chartDef = null;\n        XRangeDef.prototype.categories = $util.emptyArray;\n        XRangeDef.prototype.points = $util.emptyArray;\n        XRangeDef.create = function create(properties) {\n          return new XRangeDef(properties);\n        };\n        XRangeDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.categories != null && message.categories.length)\n            for (var i = 0; i < message.categories.length; ++i)\n              writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).string(message.categories[i]);\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.XRangePoint.encode(message.points[i], writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).fork()).ldelim();\n          return writer;\n        };\n        XRangeDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        XRangeDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.XRangeDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.categories && message.categories.length))\n                  message.categories = [];\n                message.categories.push(reader.string());\n                break;\n              }\n              case 3: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.XRangePoint.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        XRangeDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        XRangeDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.categories != null && message.hasOwnProperty(\"categories\")) {\n            if (!Array.isArray(message.categories))\n              return \"categories: array expected\";\n            for (var i = 0; i < message.categories.length; ++i)\n              if (!$util.isString(message.categories[i]))\n                return \"categories: string[] expected\";\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.XRangePoint.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          return null;\n        };\n        XRangeDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.XRangeDef)\n            return object;\n          var message = new $root.epoch_proto.XRangeDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.XRangeDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.categories) {\n            if (!Array.isArray(object.categories))\n              throw TypeError(\".epoch_proto.XRangeDef.categories: array expected\");\n            message.categories = [];\n            for (var i = 0; i < object.categories.length; ++i)\n              message.categories[i] = String(object.categories[i]);\n          }\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.XRangeDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.XRangeDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.XRangePoint.fromObject(object.points[i]);\n            }\n          }\n          return message;\n        };\n        XRangeDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults) {\n            object.categories = [];\n            object.points = [];\n          }\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.categories && message.categories.length) {\n            object.categories = [];\n            for (var j = 0; j < message.categories.length; ++j)\n              object.categories[j] = message.categories[j];\n          }\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.XRangePoint.toObject(message.points[j], options);\n          }\n          return object;\n        };\n        XRangeDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        XRangeDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.XRangeDef\";\n        };\n        return XRangeDef;\n      }();\n      epoch_proto.PieData = function() {\n        function PieData(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieData.prototype.name = \"\";\n        PieData.prototype.y = 0;\n        PieData.create = function create(properties) {\n          return new PieData(properties);\n        };\n        PieData.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.name);\n          if (message.y != null && Object.hasOwnProperty.call(message, \"y\"))\n            writer.uint32(\n              /* id 2, wireType 1 =*/\n              17\n            ).double(message.y);\n          return writer;\n        };\n        PieData.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieData.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieData();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.name = reader.string();\n                break;\n              }\n              case 2: {\n                message.y = reader.double();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieData.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieData.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.y != null && message.hasOwnProperty(\"y\")) {\n            if (typeof message.y !== \"number\")\n              return \"y: number expected\";\n          }\n          return null;\n        };\n        PieData.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieData)\n            return object;\n          var message = new $root.epoch_proto.PieData();\n          if (object.name != null)\n            message.name = String(object.name);\n          if (object.y != null)\n            message.y = Number(object.y);\n          return message;\n        };\n        PieData.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.defaults) {\n            object.name = \"\";\n            object.y = 0;\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.y != null && message.hasOwnProperty(\"y\"))\n            object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;\n          return object;\n        };\n        PieData.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieData\";\n        };\n        return PieData;\n      }();\n      epoch_proto.PieDataDef = function() {\n        function PieDataDef(properties) {\n          this.points = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieDataDef.prototype.name = \"\";\n        PieDataDef.prototype.points = $util.emptyArray;\n        PieDataDef.prototype.size = \"\";\n        PieDataDef.prototype.innerSize = null;\n        var $oneOfFields;\n        Object.defineProperty(PieDataDef.prototype, \"_innerSize\", {\n          get: $util.oneOfGetter($oneOfFields = [\"innerSize\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        PieDataDef.create = function create(properties) {\n          return new PieDataDef(properties);\n        };\n        PieDataDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n            writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).string(message.name);\n          if (message.points != null && message.points.length)\n            for (var i = 0; i < message.points.length; ++i)\n              $root.epoch_proto.PieData.encode(message.points[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n            writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).string(message.size);\n          if (message.innerSize != null && Object.hasOwnProperty.call(message, \"innerSize\"))\n            writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).string(message.innerSize);\n          return writer;\n        };\n        PieDataDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieDataDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieDataDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.name = reader.string();\n                break;\n              }\n              case 2: {\n                if (!(message.points && message.points.length))\n                  message.points = [];\n                message.points.push($root.epoch_proto.PieData.decode(reader, reader.uint32()));\n                break;\n              }\n              case 3: {\n                message.size = reader.string();\n                break;\n              }\n              case 4: {\n                message.innerSize = reader.string();\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieDataDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieDataDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.name != null && message.hasOwnProperty(\"name\")) {\n            if (!$util.isString(message.name))\n              return \"name: string expected\";\n          }\n          if (message.points != null && message.hasOwnProperty(\"points\")) {\n            if (!Array.isArray(message.points))\n              return \"points: array expected\";\n            for (var i = 0; i < message.points.length; ++i) {\n              var error = $root.epoch_proto.PieData.verify(message.points[i]);\n              if (error)\n                return \"points.\" + error;\n            }\n          }\n          if (message.size != null && message.hasOwnProperty(\"size\")) {\n            if (!$util.isString(message.size))\n              return \"size: string expected\";\n          }\n          if (message.innerSize != null && message.hasOwnProperty(\"innerSize\")) {\n            properties._innerSize = 1;\n            if (!$util.isString(message.innerSize))\n              return \"innerSize: string expected\";\n          }\n          return null;\n        };\n        PieDataDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieDataDef)\n            return object;\n          var message = new $root.epoch_proto.PieDataDef();\n          if (object.name != null)\n            message.name = String(object.name);\n          if (object.points) {\n            if (!Array.isArray(object.points))\n              throw TypeError(\".epoch_proto.PieDataDef.points: array expected\");\n            message.points = [];\n            for (var i = 0; i < object.points.length; ++i) {\n              if (typeof object.points[i] !== \"object\")\n                throw TypeError(\".epoch_proto.PieDataDef.points: object expected\");\n              message.points[i] = $root.epoch_proto.PieData.fromObject(object.points[i]);\n            }\n          }\n          if (object.size != null)\n            message.size = String(object.size);\n          if (object.innerSize != null)\n            message.innerSize = String(object.innerSize);\n          return message;\n        };\n        PieDataDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.points = [];\n          if (options.defaults) {\n            object.name = \"\";\n            object.size = \"\";\n          }\n          if (message.name != null && message.hasOwnProperty(\"name\"))\n            object.name = message.name;\n          if (message.points && message.points.length) {\n            object.points = [];\n            for (var j = 0; j < message.points.length; ++j)\n              object.points[j] = $root.epoch_proto.PieData.toObject(message.points[j], options);\n          }\n          if (message.size != null && message.hasOwnProperty(\"size\"))\n            object.size = message.size;\n          if (message.innerSize != null && message.hasOwnProperty(\"innerSize\")) {\n            object.innerSize = message.innerSize;\n            if (options.oneofs)\n              object._innerSize = \"innerSize\";\n          }\n          return object;\n        };\n        PieDataDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieDataDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieDataDef\";\n        };\n        return PieDataDef;\n      }();\n      epoch_proto.PieDef = function() {\n        function PieDef(properties) {\n          this.data = [];\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        PieDef.prototype.chartDef = null;\n        PieDef.prototype.data = $util.emptyArray;\n        PieDef.create = function create(properties) {\n          return new PieDef(properties);\n        };\n        PieDef.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.chartDef != null && Object.hasOwnProperty.call(message, \"chartDef\"))\n            $root.epoch_proto.ChartDef.encode(message.chartDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.data != null && message.data.length)\n            for (var i = 0; i < message.data.length; ++i)\n              $root.epoch_proto.PieDataDef.encode(message.data[i], writer.uint32(\n                /* id 2, wireType 2 =*/\n                18\n              ).fork()).ldelim();\n          return writer;\n        };\n        PieDef.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        PieDef.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.PieDef();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.chartDef = $root.epoch_proto.ChartDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                if (!(message.data && message.data.length))\n                  message.data = [];\n                message.data.push($root.epoch_proto.PieDataDef.decode(reader, reader.uint32()));\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        PieDef.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        PieDef.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\")) {\n            var error = $root.epoch_proto.ChartDef.verify(message.chartDef);\n            if (error)\n              return \"chartDef.\" + error;\n          }\n          if (message.data != null && message.hasOwnProperty(\"data\")) {\n            if (!Array.isArray(message.data))\n              return \"data: array expected\";\n            for (var i = 0; i < message.data.length; ++i) {\n              var error = $root.epoch_proto.PieDataDef.verify(message.data[i]);\n              if (error)\n                return \"data.\" + error;\n            }\n          }\n          return null;\n        };\n        PieDef.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.PieDef)\n            return object;\n          var message = new $root.epoch_proto.PieDef();\n          if (object.chartDef != null) {\n            if (typeof object.chartDef !== \"object\")\n              throw TypeError(\".epoch_proto.PieDef.chartDef: object expected\");\n            message.chartDef = $root.epoch_proto.ChartDef.fromObject(object.chartDef);\n          }\n          if (object.data) {\n            if (!Array.isArray(object.data))\n              throw TypeError(\".epoch_proto.PieDef.data: array expected\");\n            message.data = [];\n            for (var i = 0; i < object.data.length; ++i) {\n              if (typeof object.data[i] !== \"object\")\n                throw TypeError(\".epoch_proto.PieDef.data: object expected\");\n              message.data[i] = $root.epoch_proto.PieDataDef.fromObject(object.data[i]);\n            }\n          }\n          return message;\n        };\n        PieDef.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (options.arrays || options.defaults)\n            object.data = [];\n          if (options.defaults)\n            object.chartDef = null;\n          if (message.chartDef != null && message.hasOwnProperty(\"chartDef\"))\n            object.chartDef = $root.epoch_proto.ChartDef.toObject(message.chartDef, options);\n          if (message.data && message.data.length) {\n            object.data = [];\n            for (var j = 0; j < message.data.length; ++j)\n              object.data[j] = $root.epoch_proto.PieDataDef.toObject(message.data[j], options);\n          }\n          return object;\n        };\n        PieDef.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        PieDef.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.PieDef\";\n        };\n        return PieDef;\n      }();\n      epoch_proto.Chart = function() {\n        function Chart(properties) {\n          if (properties) {\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n              if (properties[keys[i]] != null)\n                this[keys[i]] = properties[keys[i]];\n          }\n        }\n        Chart.prototype.linesDef = null;\n        Chart.prototype.heatMapDef = null;\n        Chart.prototype.barDef = null;\n        Chart.prototype.histogramDef = null;\n        Chart.prototype.boxPlotDef = null;\n        Chart.prototype.xRangeDef = null;\n        Chart.prototype.pieDef = null;\n        var $oneOfFields;\n        Object.defineProperty(Chart.prototype, \"chartType\", {\n          get: $util.oneOfGetter($oneOfFields = [\"linesDef\", \"heatMapDef\", \"barDef\", \"histogramDef\", \"boxPlotDef\", \"xRangeDef\", \"pieDef\"]),\n          set: $util.oneOfSetter($oneOfFields)\n        });\n        Chart.create = function create(properties) {\n          return new Chart(properties);\n        };\n        Chart.encode = function encode(message, writer) {\n          if (!writer)\n            writer = $Writer.create();\n          if (message.linesDef != null && Object.hasOwnProperty.call(message, \"linesDef\"))\n            $root.epoch_proto.LinesDef.encode(message.linesDef, writer.uint32(\n              /* id 1, wireType 2 =*/\n              10\n            ).fork()).ldelim();\n          if (message.heatMapDef != null && Object.hasOwnProperty.call(message, \"heatMapDef\"))\n            $root.epoch_proto.HeatMapDef.encode(message.heatMapDef, writer.uint32(\n              /* id 2, wireType 2 =*/\n              18\n            ).fork()).ldelim();\n          if (message.barDef != null && Object.hasOwnProperty.call(message, \"barDef\"))\n            $root.epoch_proto.BarDef.encode(message.barDef, writer.uint32(\n              /* id 3, wireType 2 =*/\n              26\n            ).fork()).ldelim();\n          if (message.histogramDef != null && Object.hasOwnProperty.call(message, \"histogramDef\"))\n            $root.epoch_proto.HistogramDef.encode(message.histogramDef, writer.uint32(\n              /* id 4, wireType 2 =*/\n              34\n            ).fork()).ldelim();\n          if (message.boxPlotDef != null && Object.hasOwnProperty.call(message, \"boxPlotDef\"))\n            $root.epoch_proto.BoxPlotDef.encode(message.boxPlotDef, writer.uint32(\n              /* id 5, wireType 2 =*/\n              42\n            ).fork()).ldelim();\n          if (message.xRangeDef != null && Object.hasOwnProperty.call(message, \"xRangeDef\"))\n            $root.epoch_proto.XRangeDef.encode(message.xRangeDef, writer.uint32(\n              /* id 6, wireType 2 =*/\n              50\n            ).fork()).ldelim();\n          if (message.pieDef != null && Object.hasOwnProperty.call(message, \"pieDef\"))\n            $root.epoch_proto.PieDef.encode(message.pieDef, writer.uint32(\n              /* id 7, wireType 2 =*/\n              58\n            ).fork()).ldelim();\n          return writer;\n        };\n        Chart.encodeDelimited = function encodeDelimited(message, writer) {\n          return this.encode(message, writer).ldelim();\n        };\n        Chart.decode = function decode(reader, length, error) {\n          if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n          var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.epoch_proto.Chart();\n          while (reader.pos < end) {\n            var tag = reader.uint32();\n            if (tag === error)\n              break;\n            switch (tag >>> 3) {\n              case 1: {\n                message.linesDef = $root.epoch_proto.LinesDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 2: {\n                message.heatMapDef = $root.epoch_proto.HeatMapDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 3: {\n                message.barDef = $root.epoch_proto.BarDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 4: {\n                message.histogramDef = $root.epoch_proto.HistogramDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 5: {\n                message.boxPlotDef = $root.epoch_proto.BoxPlotDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 6: {\n                message.xRangeDef = $root.epoch_proto.XRangeDef.decode(reader, reader.uint32());\n                break;\n              }\n              case 7: {\n                message.pieDef = $root.epoch_proto.PieDef.decode(reader, reader.uint32());\n                break;\n              }\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n          return message;\n        };\n        Chart.decodeDelimited = function decodeDelimited(reader) {\n          if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n          return this.decode(reader, reader.uint32());\n        };\n        Chart.verify = function verify(message) {\n          if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n          var properties = {};\n          if (message.linesDef != null && message.hasOwnProperty(\"linesDef\")) {\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.LinesDef.verify(message.linesDef);\n              if (error)\n                return \"linesDef.\" + error;\n            }\n          }\n          if (message.heatMapDef != null && message.hasOwnProperty(\"heatMapDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.HeatMapDef.verify(message.heatMapDef);\n              if (error)\n                return \"heatMapDef.\" + error;\n            }\n          }\n          if (message.barDef != null && message.hasOwnProperty(\"barDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.BarDef.verify(message.barDef);\n              if (error)\n                return \"barDef.\" + error;\n            }\n          }\n          if (message.histogramDef != null && message.hasOwnProperty(\"histogramDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.HistogramDef.verify(message.histogramDef);\n              if (error)\n                return \"histogramDef.\" + error;\n            }\n          }\n          if (message.boxPlotDef != null && message.hasOwnProperty(\"boxPlotDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.BoxPlotDef.verify(message.boxPlotDef);\n              if (error)\n                return \"boxPlotDef.\" + error;\n            }\n          }\n          if (message.xRangeDef != null && message.hasOwnProperty(\"xRangeDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.XRangeDef.verify(message.xRangeDef);\n              if (error)\n                return \"xRangeDef.\" + error;\n            }\n          }\n          if (message.pieDef != null && message.hasOwnProperty(\"pieDef\")) {\n            if (properties.chartType === 1)\n              return \"chartType: multiple values\";\n            properties.chartType = 1;\n            {\n              var error = $root.epoch_proto.PieDef.verify(message.pieDef);\n              if (error)\n                return \"pieDef.\" + error;\n            }\n          }\n          return null;\n        };\n        Chart.fromObject = function fromObject(object) {\n          if (object instanceof $root.epoch_proto.Chart)\n            return object;\n          var message = new $root.epoch_proto.Chart();\n          if (object.linesDef != null) {\n            if (typeof object.linesDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.linesDef: object expected\");\n            message.linesDef = $root.epoch_proto.LinesDef.fromObject(object.linesDef);\n          }\n          if (object.heatMapDef != null) {\n            if (typeof object.heatMapDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.heatMapDef: object expected\");\n            message.heatMapDef = $root.epoch_proto.HeatMapDef.fromObject(object.heatMapDef);\n          }\n          if (object.barDef != null) {\n            if (typeof object.barDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.barDef: object expected\");\n            message.barDef = $root.epoch_proto.BarDef.fromObject(object.barDef);\n          }\n          if (object.histogramDef != null) {\n            if (typeof object.histogramDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.histogramDef: object expected\");\n            message.histogramDef = $root.epoch_proto.HistogramDef.fromObject(object.histogramDef);\n          }\n          if (object.boxPlotDef != null) {\n            if (typeof object.boxPlotDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.boxPlotDef: object expected\");\n            message.boxPlotDef = $root.epoch_proto.BoxPlotDef.fromObject(object.boxPlotDef);\n          }\n          if (object.xRangeDef != null) {\n            if (typeof object.xRangeDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.xRangeDef: object expected\");\n            message.xRangeDef = $root.epoch_proto.XRangeDef.fromObject(object.xRangeDef);\n          }\n          if (object.pieDef != null) {\n            if (typeof object.pieDef !== \"object\")\n              throw TypeError(\".epoch_proto.Chart.pieDef: object expected\");\n            message.pieDef = $root.epoch_proto.PieDef.fromObject(object.pieDef);\n          }\n          return message;\n        };\n        Chart.toObject = function toObject(message, options) {\n          if (!options)\n            options = {};\n          var object = {};\n          if (message.linesDef != null && message.hasOwnProperty(\"linesDef\")) {\n            object.linesDef = $root.epoch_proto.LinesDef.toObject(message.linesDef, options);\n            if (options.oneofs)\n              object.chartType = \"linesDef\";\n          }\n          if (message.heatMapDef != null && message.hasOwnProperty(\"heatMapDef\")) {\n            object.heatMapDef = $root.epoch_proto.HeatMapDef.toObject(message.heatMapDef, options);\n            if (options.oneofs)\n              object.chartType = \"heatMapDef\";\n          }\n          if (message.barDef != null && message.hasOwnProperty(\"barDef\")) {\n            object.barDef = $root.epoch_proto.BarDef.toObject(message.barDef, options);\n            if (options.oneofs)\n              object.chartType = \"barDef\";\n          }\n          if (message.histogramDef != null && message.hasOwnProperty(\"histogramDef\")) {\n            object.histogramDef = $root.epoch_proto.HistogramDef.toObject(message.histogramDef, options);\n            if (options.oneofs)\n              object.chartType = \"histogramDef\";\n          }\n          if (message.boxPlotDef != null && message.hasOwnProperty(\"boxPlotDef\")) {\n            object.boxPlotDef = $root.epoch_proto.BoxPlotDef.toObject(message.boxPlotDef, options);\n            if (options.oneofs)\n              object.chartType = \"boxPlotDef\";\n          }\n          if (message.xRangeDef != null && message.hasOwnProperty(\"xRangeDef\")) {\n            object.xRangeDef = $root.epoch_proto.XRangeDef.toObject(message.xRangeDef, options);\n            if (options.oneofs)\n              object.chartType = \"xRangeDef\";\n          }\n          if (message.pieDef != null && message.hasOwnProperty(\"pieDef\")) {\n            object.pieDef = $root.epoch_proto.PieDef.toObject(message.pieDef, options);\n            if (options.oneofs)\n              object.chartType = \"pieDef\";\n          }\n          return object;\n        };\n        Chart.prototype.toJSON = function toJSON() {\n          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n        Chart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n          if (typeUrlPrefix === void 0) {\n            typeUrlPrefix = \"type.googleapis.com\";\n          }\n          return typeUrlPrefix + \"/epoch_proto.Chart\";\n        };\n        return Chart;\n      }();\n      return epoch_proto;\n    }();\n    $root.google = function() {\n      var google = {};\n      google.protobuf = function() {\n        var protobuf = {};\n        protobuf.Struct = function() {\n          function Struct(properties) {\n            this.fields = {};\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Struct.prototype.fields = $util.emptyObject;\n          Struct.create = function create(properties) {\n            return new Struct(properties);\n          };\n          Struct.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.fields != null && Object.hasOwnProperty.call(message, \"fields\"))\n              for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {\n                writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork().uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).string(keys[i]);\n                $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(\n                  /* id 2, wireType 2 =*/\n                  18\n                ).fork()).ldelim().ldelim();\n              }\n            return writer;\n          };\n          Struct.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Struct.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key, value;\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (message.fields === $util.emptyObject)\n                    message.fields = {};\n                  var end2 = reader.uint32() + reader.pos;\n                  key = \"\";\n                  value = null;\n                  while (reader.pos < end2) {\n                    var tag2 = reader.uint32();\n                    switch (tag2 >>> 3) {\n                      case 1:\n                        key = reader.string();\n                        break;\n                      case 2:\n                        value = $root.google.protobuf.Value.decode(reader, reader.uint32());\n                        break;\n                      default:\n                        reader.skipType(tag2 & 7);\n                        break;\n                    }\n                  }\n                  message.fields[key] = value;\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Struct.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Struct.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.fields != null && message.hasOwnProperty(\"fields\")) {\n              if (!$util.isObject(message.fields))\n                return \"fields: object expected\";\n              var key = Object.keys(message.fields);\n              for (var i = 0; i < key.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);\n                if (error)\n                  return \"fields.\" + error;\n              }\n            }\n            return null;\n          };\n          Struct.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Struct)\n              return object;\n            var message = new $root.google.protobuf.Struct();\n            if (object.fields) {\n              if (typeof object.fields !== \"object\")\n                throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n              message.fields = {};\n              for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {\n                if (typeof object.fields[keys[i]] !== \"object\")\n                  throw TypeError(\".google.protobuf.Struct.fields: object expected\");\n                message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);\n              }\n            }\n            return message;\n          };\n          Struct.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.objects || options.defaults)\n              object.fields = {};\n            var keys2;\n            if (message.fields && (keys2 = Object.keys(message.fields)).length) {\n              object.fields = {};\n              for (var j = 0; j < keys2.length; ++j)\n                object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);\n            }\n            return object;\n          };\n          Struct.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Struct.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Struct\";\n          };\n          return Struct;\n        }();\n        protobuf.Value = function() {\n          function Value(properties) {\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          Value.prototype.nullValue = null;\n          Value.prototype.numberValue = null;\n          Value.prototype.stringValue = null;\n          Value.prototype.boolValue = null;\n          Value.prototype.structValue = null;\n          Value.prototype.listValue = null;\n          var $oneOfFields;\n          Object.defineProperty(Value.prototype, \"kind\", {\n            get: $util.oneOfGetter($oneOfFields = [\"nullValue\", \"numberValue\", \"stringValue\", \"boolValue\", \"structValue\", \"listValue\"]),\n            set: $util.oneOfSetter($oneOfFields)\n          });\n          Value.create = function create(properties) {\n            return new Value(properties);\n          };\n          Value.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.nullValue != null && Object.hasOwnProperty.call(message, \"nullValue\"))\n              writer.uint32(\n                /* id 1, wireType 0 =*/\n                8\n              ).int32(message.nullValue);\n            if (message.numberValue != null && Object.hasOwnProperty.call(message, \"numberValue\"))\n              writer.uint32(\n                /* id 2, wireType 1 =*/\n                17\n              ).double(message.numberValue);\n            if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n              writer.uint32(\n                /* id 3, wireType 2 =*/\n                26\n              ).string(message.stringValue);\n            if (message.boolValue != null && Object.hasOwnProperty.call(message, \"boolValue\"))\n              writer.uint32(\n                /* id 4, wireType 0 =*/\n                32\n              ).bool(message.boolValue);\n            if (message.structValue != null && Object.hasOwnProperty.call(message, \"structValue\"))\n              $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(\n                /* id 5, wireType 2 =*/\n                42\n              ).fork()).ldelim();\n            if (message.listValue != null && Object.hasOwnProperty.call(message, \"listValue\"))\n              $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(\n                /* id 6, wireType 2 =*/\n                50\n              ).fork()).ldelim();\n            return writer;\n          };\n          Value.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          Value.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  message.nullValue = reader.int32();\n                  break;\n                }\n                case 2: {\n                  message.numberValue = reader.double();\n                  break;\n                }\n                case 3: {\n                  message.stringValue = reader.string();\n                  break;\n                }\n                case 4: {\n                  message.boolValue = reader.bool();\n                  break;\n                }\n                case 5: {\n                  message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());\n                  break;\n                }\n                case 6: {\n                  message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          Value.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          Value.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            var properties = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              properties.kind = 1;\n              switch (message.nullValue) {\n                default:\n                  return \"nullValue: enum value expected\";\n                case 0:\n                  break;\n              }\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.numberValue !== \"number\")\n                return \"numberValue: number expected\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (!$util.isString(message.stringValue))\n                return \"stringValue: string expected\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              if (typeof message.boolValue !== \"boolean\")\n                return \"boolValue: boolean expected\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.Struct.verify(message.structValue);\n                if (error)\n                  return \"structValue.\" + error;\n              }\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              if (properties.kind === 1)\n                return \"kind: multiple values\";\n              properties.kind = 1;\n              {\n                var error = $root.google.protobuf.ListValue.verify(message.listValue);\n                if (error)\n                  return \"listValue.\" + error;\n              }\n            }\n            return null;\n          };\n          Value.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.Value)\n              return object;\n            var message = new $root.google.protobuf.Value();\n            switch (object.nullValue) {\n              default:\n                if (typeof object.nullValue === \"number\") {\n                  message.nullValue = object.nullValue;\n                  break;\n                }\n                break;\n              case \"NULL_VALUE\":\n              case 0:\n                message.nullValue = 0;\n                break;\n            }\n            if (object.numberValue != null)\n              message.numberValue = Number(object.numberValue);\n            if (object.stringValue != null)\n              message.stringValue = String(object.stringValue);\n            if (object.boolValue != null)\n              message.boolValue = Boolean(object.boolValue);\n            if (object.structValue != null) {\n              if (typeof object.structValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.structValue: object expected\");\n              message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);\n            }\n            if (object.listValue != null) {\n              if (typeof object.listValue !== \"object\")\n                throw TypeError(\".google.protobuf.Value.listValue: object expected\");\n              message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);\n            }\n            return message;\n          };\n          Value.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (message.nullValue != null && message.hasOwnProperty(\"nullValue\")) {\n              object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] === void 0 ? message.nullValue : $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;\n              if (options.oneofs)\n                object.kind = \"nullValue\";\n            }\n            if (message.numberValue != null && message.hasOwnProperty(\"numberValue\")) {\n              object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;\n              if (options.oneofs)\n                object.kind = \"numberValue\";\n            }\n            if (message.stringValue != null && message.hasOwnProperty(\"stringValue\")) {\n              object.stringValue = message.stringValue;\n              if (options.oneofs)\n                object.kind = \"stringValue\";\n            }\n            if (message.boolValue != null && message.hasOwnProperty(\"boolValue\")) {\n              object.boolValue = message.boolValue;\n              if (options.oneofs)\n                object.kind = \"boolValue\";\n            }\n            if (message.structValue != null && message.hasOwnProperty(\"structValue\")) {\n              object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);\n              if (options.oneofs)\n                object.kind = \"structValue\";\n            }\n            if (message.listValue != null && message.hasOwnProperty(\"listValue\")) {\n              object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);\n              if (options.oneofs)\n                object.kind = \"listValue\";\n            }\n            return object;\n          };\n          Value.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          Value.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.Value\";\n          };\n          return Value;\n        }();\n        protobuf.NullValue = function() {\n          var valuesById = {}, values = Object.create(valuesById);\n          values[valuesById[0] = \"NULL_VALUE\"] = 0;\n          return values;\n        }();\n        protobuf.ListValue = function() {\n          function ListValue(properties) {\n            this.values = [];\n            if (properties) {\n              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                  this[keys[i]] = properties[keys[i]];\n            }\n          }\n          ListValue.prototype.values = $util.emptyArray;\n          ListValue.create = function create(properties) {\n            return new ListValue(properties);\n          };\n          ListValue.encode = function encode(message, writer) {\n            if (!writer)\n              writer = $Writer.create();\n            if (message.values != null && message.values.length)\n              for (var i = 0; i < message.values.length; ++i)\n                $root.google.protobuf.Value.encode(message.values[i], writer.uint32(\n                  /* id 1, wireType 2 =*/\n                  10\n                ).fork()).ldelim();\n            return writer;\n          };\n          ListValue.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n          };\n          ListValue.decode = function decode(reader, length, error) {\n            if (!(reader instanceof $Reader))\n              reader = $Reader.create(reader);\n            var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();\n            while (reader.pos < end) {\n              var tag = reader.uint32();\n              if (tag === error)\n                break;\n              switch (tag >>> 3) {\n                case 1: {\n                  if (!(message.values && message.values.length))\n                    message.values = [];\n                  message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));\n                  break;\n                }\n                default:\n                  reader.skipType(tag & 7);\n                  break;\n              }\n            }\n            return message;\n          };\n          ListValue.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n              reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n          };\n          ListValue.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n              return \"object expected\";\n            if (message.values != null && message.hasOwnProperty(\"values\")) {\n              if (!Array.isArray(message.values))\n                return \"values: array expected\";\n              for (var i = 0; i < message.values.length; ++i) {\n                var error = $root.google.protobuf.Value.verify(message.values[i]);\n                if (error)\n                  return \"values.\" + error;\n              }\n            }\n            return null;\n          };\n          ListValue.fromObject = function fromObject(object) {\n            if (object instanceof $root.google.protobuf.ListValue)\n              return object;\n            var message = new $root.google.protobuf.ListValue();\n            if (object.values) {\n              if (!Array.isArray(object.values))\n                throw TypeError(\".google.protobuf.ListValue.values: array expected\");\n              message.values = [];\n              for (var i = 0; i < object.values.length; ++i) {\n                if (typeof object.values[i] !== \"object\")\n                  throw TypeError(\".google.protobuf.ListValue.values: object expected\");\n                message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);\n              }\n            }\n            return message;\n          };\n          ListValue.toObject = function toObject(message, options) {\n            if (!options)\n              options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n              object.values = [];\n            if (message.values && message.values.length) {\n              object.values = [];\n              for (var j = 0; j < message.values.length; ++j)\n                object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);\n            }\n            return object;\n          };\n          ListValue.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n          };\n          ListValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {\n            if (typeUrlPrefix === void 0) {\n              typeUrlPrefix = \"type.googleapis.com\";\n            }\n            return typeUrlPrefix + \"/google.protobuf.ListValue\";\n          };\n          return ListValue;\n        }();\n        return protobuf;\n      }();\n      return google;\n    }();\n    module2.exports = $root;\n  }\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (require_tearsheet());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2Rpc3QvdGVhcnNoZWV0LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRTtBQUMxRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxQkFBTSxvQkFBb0IscUJBQU0sSUFBSSxxQkFBTSxZQUFZLHFCQUFNLHFCQUFxQixxQkFBTTtBQUN4SCxpQ0FBaUMscUJBQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0NBQWdDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGlCQUFpQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsaUJBQWlCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtDQUFrQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpQkFBaUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGlCQUFpQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxpQkFBaUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWUsbUJBQW1CLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2FkZXNvbGEvRXBvY2hMYWIvRXBvY2hEYXNoYm9hcmQvanMvbm9kZV9tb2R1bGVzL0BlcG9jaGxhYi9lcG9jaC1wcm90b3MvZGlzdC90ZWFyc2hlZXQuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZDIpID0+IGZ1bmN0aW9uIF9fcmVxdWlyZSgpIHtcbiAgcmV0dXJuIG1vZDIgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QyID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QyKSwgbW9kMi5leHBvcnRzO1xufTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qc1xudmFyIHJlcXVpcmVfYXNwcm9taXNlID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gYXNQcm9taXNlO1xuICAgIGZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4KSB7XG4gICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSwgb2Zmc2V0ID0gMCwgaW5kZXggPSAyLCBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbXMyID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSwgb2Zmc2V0MiA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQyIDwgcGFyYW1zMi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcGFyYW1zMltvZmZzZXQyKytdID0gYXJndW1lbnRzW29mZnNldDJdO1xuICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtczIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qc1xudmFyIHJlcXVpcmVfYmFzZTY0ID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Jhc2U2NC9pbmRleC5qc1wiKGV4cG9ydHMyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGJhc2U2NCA9IGV4cG9ydHMyO1xuICAgIGJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XG4gICAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoIXApXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxuICAgICAgICArK247XG4gICAgICByZXR1cm4gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggKiAzKSAvIDQgLSBuO1xuICAgIH07XG4gICAgdmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XG4gICAgdmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgKVxuICAgICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xuICAgIHZhciBpO1xuICAgIGJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcGFydHMgPSBudWxsLCBjaHVuayA9IFtdO1xuICAgICAgdmFyIGkyID0gMCwgaiA9IDAsIHQ7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgdmFyIGIgPSBidWZmZXJbc3RhcnQrK107XG4gICAgICAgIHN3aXRjaCAoaikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNodW5rW2kyKytdID0gYjY0W2IgPj4gMl07XG4gICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgICAgaiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFt0IHwgYiA+PiA0XTtcbiAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xuICAgICAgICAgICAgaiA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjaHVua1tpMisrXSA9IGI2NFt0IHwgYiA+PiA2XTtcbiAgICAgICAgICAgIGNodW5rW2kyKytdID0gYjY0W2IgJiA2M107XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMiA+IDgxOTEpIHtcbiAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xuICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGopIHtcbiAgICAgICAgY2h1bmtbaTIrK10gPSBiNjRbdF07XG4gICAgICAgIGNodW5rW2kyKytdID0gNjE7XG4gICAgICAgIGlmIChqID09PSAxKVxuICAgICAgICAgIGNodW5rW2kyKytdID0gNjE7XG4gICAgICB9XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgaWYgKGkyKVxuICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkyKSkpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaTIpKTtcbiAgICB9O1xuICAgIHZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcbiAgICBiYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzdGFydCA9IG9mZnNldDtcbiAgICAgIHZhciBqID0gMCwgdDtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzdHJpbmcubGVuZ3RoOyApIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpMisrKTtcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB2b2lkIDApXG4gICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcbiAgICAgICAgc3dpdGNoIChqKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdCA9IGM7XG4gICAgICAgICAgICBqID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xuICAgICAgICAgICAgdCA9IGM7XG4gICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcbiAgICAgICAgICAgIHQgPSBjO1xuICAgICAgICAgICAgaiA9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChqID09PSAxKVxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xuICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xuICAgIH07XG4gICAgYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xuICAgICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanNcbnZhciByZXF1aXJlX2V2ZW50ZW1pdHRlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xuICAgICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XG4gICAgICAgIGZuLFxuICAgICAgICBjdHg6IGN0eCB8fCB0aGlzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xuICAgICAgaWYgKGV2dCA9PT0gdm9pZCAwKVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZm4gPT09IHZvaWQgMClcbiAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyApXG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcbiAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XG4gICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10sIGkgPSAxO1xuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IClcbiAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKVxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9mbG9hdC9pbmRleC5qc1xudmFyIHJlcXVpcmVfZmxvYXQgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XG4gICAgZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzMykge1xuICAgICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWy0wXSksIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLCBsZSA9IGY4YlszXSA9PT0gMTI4O1xuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGYzMlswXSA9IHZhbDtcbiAgICAgICAgICBidWZbcG9zXSA9IGY4YlswXTtcbiAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XG4gICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGYzMlswXSA9IHZhbDtcbiAgICAgICAgICBidWZbcG9zXSA9IGY4YlszXTtcbiAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XG4gICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcbiAgICAgICAgZXhwb3J0czMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjhiWzBdID0gYnVmW3Bvc107XG4gICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xuICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcbiAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XG4gICAgICAgICAgcmV0dXJuIGYzMlswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xuICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3NdO1xuICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XG4gICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xuICAgICAgICAgIHJldHVybiBmMzJbMF07XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0czMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XG4gICAgICAgIGV4cG9ydHMzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xuICAgICAgfSkoKTtcbiAgICAgIGVsc2UgKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XG4gICAgICAgICAgaWYgKHNpZ24pXG4gICAgICAgICAgICB2YWwgPSAtdmFsO1xuICAgICAgICAgIGlmICh2YWwgPT09IDApXG4gICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAoXG4gICAgICAgICAgICAgIC8qIHBvc2l0aXZlICovXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIC8qIG5lZ2F0aXZlIDAgKi9cbiAgICAgICAgICAgICAgMjE0NzQ4MzY0OFxuICAgICAgICAgICAgKSwgYnVmLCBwb3MpO1xuICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXG4gICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xuICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDM0MDI4MjM0NjYzODUyODg2ZTIyKVxuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxMTc1NDk0MzUwODIyMjg3NWUtNTQpXG4gICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDE0MDEyOTg0NjQzMjQ4MTdlLTYwKSkgPj4+IDAsIGJ1ZiwgcG9zKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSwgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XG4gICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSwgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSwgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcbiAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NSA/IG1hbnRpc3NhID8gTmFOIDogc2lnbiAqIEluZmluaXR5IDogZXhwb25lbnQgPT09IDAgPyBzaWduICogMTQwMTI5ODQ2NDMyNDgxN2UtNjAgKiBtYW50aXNzYSA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XG4gICAgICAgIGV4cG9ydHMzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcbiAgICAgIH0pKCk7XG4gICAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSwgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksIGxlID0gZjhiWzddID09PSAxMjg7XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGY2NFswXSA9IHZhbDtcbiAgICAgICAgICBidWZbcG9zXSA9IGY4YlswXTtcbiAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XG4gICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xuICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcbiAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XG4gICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcbiAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgZjY0WzBdID0gdmFsO1xuICAgICAgICAgIGJ1Zltwb3NdID0gZjhiWzddO1xuICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcbiAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XG4gICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcbiAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XG4gICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xuICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzMy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcbiAgICAgICAgZXhwb3J0czMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3NdO1xuICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XG4gICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xuICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcbiAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XG4gICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xuICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcbiAgICAgICAgICByZXR1cm4gZjY0WzBdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xuICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3NdO1xuICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcbiAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XG4gICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xuICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcbiAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XG4gICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xuICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcbiAgICAgICAgICByZXR1cm4gZjY0WzBdO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcbiAgICAgIH0pKCk7XG4gICAgICBlbHNlIChmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcbiAgICAgICAgICBpZiAoc2lnbilcbiAgICAgICAgICAgIHZhbCA9IC12YWw7XG4gICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAoXG4gICAgICAgICAgICAgIC8qIHBvc2l0aXZlICovXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgIC8qIG5lZ2F0aXZlIDAgKi9cbiAgICAgICAgICAgICAgMjE0NzQ4MzY0OFxuICAgICAgICAgICAgKSwgYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxNzk3NjkzMTM0ODYyMzE1N2UyOTIpIHtcbiAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xuICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYW50aXNzYTtcbiAgICAgICAgICAgIGlmICh2YWwgPCAyMjI1MDczODU4NTA3MjAxNGUtMzI0KSB7XG4gICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xuICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XG4gICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XG4gICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XG4gICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcbiAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcbiAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xuICAgICAgICBleHBvcnRzMy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xuICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcbiAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSwgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LCBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xuICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0NyA/IG1hbnRpc3NhID8gTmFOIDogc2lnbiAqIEluZmluaXR5IDogZXhwb25lbnQgPT09IDAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2EgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xuICAgICAgICBleHBvcnRzMy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcbiAgICAgIH0pKCk7XG4gICAgICByZXR1cm4gZXhwb3J0czM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDFdID0gdmFsID4+PiA4ICYgMjU1O1xuICAgICAgYnVmW3BvcyArIDJdID0gdmFsID4+PiAxNiAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAzXSA9IHZhbCA+Pj4gMjQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGJ1Zltwb3NdID0gdmFsID4+PiAyNDtcbiAgICAgIGJ1Zltwb3MgKyAxXSA9IHZhbCA+Pj4gMTYgJiAyNTU7XG4gICAgICBidWZbcG9zICsgMl0gPSB2YWwgPj4+IDggJiAyNTU7XG4gICAgICBidWZbcG9zICsgM10gPSB2YWwgJiAyNTU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcbiAgICAgIHJldHVybiAoYnVmW3Bvc10gfCBidWZbcG9zICsgMV0gPDwgOCB8IGJ1Zltwb3MgKyAyXSA8PCAxNiB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcbiAgICAgIHJldHVybiAoYnVmW3Bvc10gPDwgMjQgfCBidWZbcG9zICsgMV0gPDwgMTYgfCBidWZbcG9zICsgMl0gPDwgOCB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XG4gICAgfVxuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanNcbnZhciByZXF1aXJlX2lucXVpcmUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvQHByb3RvYnVmanMvaW5xdWlyZS9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcbiAgICBmdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLywgXCJyZVwiKSkobW9kdWxlTmFtZSk7XG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxuICAgICAgICAgIHJldHVybiBtb2Q7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvdXRmOC9pbmRleC5qc1xudmFyIHJlcXVpcmVfdXRmOCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdXRmOCA9IGV4cG9ydHMyO1xuICAgIHV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XG4gICAgICB2YXIgbGVuID0gMCwgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KVxuICAgICAgICAgIGxlbiArPSAxO1xuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcbiAgICAgICAgICBsZW4gKz0gMjtcbiAgICAgICAgZWxzZSBpZiAoKGMgJiA2NDUxMikgPT09IDU1Mjk2ICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiA2NDUxMikgPT09IDU2MzIwKSB7XG4gICAgICAgICAgKytpO1xuICAgICAgICAgIGxlbiArPSA0O1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBsZW4gKz0gMztcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZW47XG4gICAgfTtcbiAgICB1dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gICAgICBpZiAobGVuIDwgMSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB2YXIgcGFydHMgPSBudWxsLCBjaHVuayA9IFtdLCBpID0gMCwgdDtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xuICAgICAgICBpZiAodCA8IDEyOClcbiAgICAgICAgICBjaHVua1tpKytdID0gdDtcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxuICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xuICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSA2NTUzNjtcbiAgICAgICAgICBjaHVua1tpKytdID0gNTUyOTYgKyAodCA+PiAxMCk7XG4gICAgICAgICAgY2h1bmtbaSsrXSA9IDU2MzIwICsgKHQgJiAxMDIzKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XG4gICAgICAgIGlmIChpID4gODE5MSkge1xuICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xuICAgIH07XG4gICAgdXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xuICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LCBjMSwgYzI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgfCAxOTI7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICYgNjMgfCAxMjg7XG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgNjQ1MTIpID09PSA1NTI5NiAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDY0NTEyKSA9PT0gNTYzMjApIHtcbiAgICAgICAgICBjMSA9IDY1NTM2ICsgKChjMSAmIDEwMjMpIDw8IDEwKSArIChjMiAmIDEwMjMpO1xuICAgICAgICAgICsraTtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggfCAyNDA7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgJiA2MyB8IDEyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgfCAyMjQ7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgJiA2MyB8IDEyODtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgJiA2MyB8IDEyODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvQHByb3RvYnVmanMvcG9vbC9pbmRleC5qc1xudmFyIHJlcXVpcmVfcG9vbCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBwb29sO1xuICAgIGZ1bmN0aW9uIHBvb2woYWxsb2MsIHNsaWNlLCBzaXplKSB7XG4gICAgICB2YXIgU0laRSA9IHNpemUgfHwgODE5MjtcbiAgICAgIHZhciBNQVggPSBTSVpFID4+PiAxO1xuICAgICAgdmFyIHNsYWIgPSBudWxsO1xuICAgICAgdmFyIG9mZnNldCA9IFNJWkU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplMikge1xuICAgICAgICBpZiAoc2l6ZTIgPCAxIHx8IHNpemUyID4gTUFYKVxuICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplMik7XG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplMiA+IFNJWkUpIHtcbiAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XG4gICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplMik7XG4gICAgICAgIGlmIChvZmZzZXQgJiA3KVxuICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzXG52YXIgcmVxdWlyZV9sb25nYml0cyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBMb25nQml0cztcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIGZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuICAgICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuICAgICAgdGhpcy5oaSA9IGhpID4+PiAwO1xuICAgIH1cbiAgICB2YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICB6ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICB6ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbiAgICB2YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG4gICAgTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLCBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbiAgICB9O1xuICAgIExvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLCBoaSA9IH50aGlzLmhpID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgICAgcmV0dXJuIHV0aWwuTG9uZyA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSkgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbiAgICB9O1xuICAgIHZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuICAgIExvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgIChjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMCkgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOCB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNiB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDAsXG4gICAgICAgIChjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNCkgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOCB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNiB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICAgICk7XG4gICAgfTtcbiAgICBMb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCxcbiAgICAgICAgdGhpcy5oaSAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgICApO1xuICAgIH07XG4gICAgTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgICB2YXIgbWFzayA9IHRoaXMuaGkgPj4gMzE7XG4gICAgICB0aGlzLmhpID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICAgIHRoaXMubG8gPSAodGhpcy5sbyA8PCAxIF4gbWFzaykgPj4+IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICAgIHRoaXMubG8gPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgICAgdGhpcy5oaSA9ICh0aGlzLmhpID4+PiAxIF4gbWFzaykgPj4+IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICB2YXIgcGFydDAgPSB0aGlzLmxvLCBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsIHBhcnQyID0gdGhpcy5oaSA+Pj4gMjQ7XG4gICAgICByZXR1cm4gcGFydDIgPT09IDAgPyBwYXJ0MSA9PT0gMCA/IHBhcnQwIDwgMTYzODQgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDQgOiBwYXJ0MSA8IDE2Mzg0ID8gcGFydDEgPCAxMjggPyA1IDogNiA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4IDogcGFydDIgPCAxMjggPyA5IDogMTA7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanNcbnZhciByZXF1aXJlX21pbmltYWwgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdXRpbCA9IGV4cG9ydHMyO1xuICAgIHV0aWwuYXNQcm9taXNlID0gcmVxdWlyZV9hc3Byb21pc2UoKTtcbiAgICB1dGlsLmJhc2U2NCA9IHJlcXVpcmVfYmFzZTY0KCk7XG4gICAgdXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlX2V2ZW50ZW1pdHRlcigpO1xuICAgIHV0aWwuZmxvYXQgPSByZXF1aXJlX2Zsb2F0KCk7XG4gICAgdXRpbC5pbnF1aXJlID0gcmVxdWlyZV9pbnF1aXJlKCk7XG4gICAgdXRpbC51dGY4ID0gcmVxdWlyZV91dGY4KCk7XG4gICAgdXRpbC5wb29sID0gcmVxdWlyZV9wb29sKCk7XG4gICAgdXRpbC5Mb25nQml0cyA9IHJlcXVpcmVfbG9uZ2JpdHMoKTtcbiAgICB1dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwgJiYgZ2xvYmFsLnByb2Nlc3MgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG4gICAgdXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWwgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZiB8fCBleHBvcnRzMjtcbiAgICB1dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAoXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgW11cbiAgICApO1xuICAgIHV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAoXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAge31cbiAgICApO1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xuICAgIH07XG4gICAgdXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH07XG4gICAgdXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xuICAgIH07XG4gICAgdXRpbC5pc3NldCA9IC8qKlxuICAgICAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICAgKi9cbiAgICB1dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdXRpbC5CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlcjIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlcjIgOiAoXG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBudWxsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0oKTtcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICB1dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIiA/IHV0aWwuQnVmZmVyID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KSA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KSA6IHV0aWwuQnVmZmVyID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCIgPyBzaXplT3JBcnJheSA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbiAgICB9O1xuICAgIHV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgOiBBcnJheTtcbiAgICB1dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmcgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1dGlsLmdsb2JhbC5Mb25nIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG4gICAgdXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG4gICAgdXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG4gICAgdXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuICAgIHV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKCkgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xuICAgIH07XG4gICAgdXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7XG4gICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB2b2lkIDAgfHwgIWlmTm90U2V0KVxuICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICAgIHV0aWwubWVyZ2UgPSBtZXJnZTtcbiAgICB1dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG4gICAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH0gfSk7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlcbiAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICAgIH1cbiAgICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IEN1c3RvbUVycm9yLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogdm9pZCAwLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogZmFsc2Ugd291bGQgYWNjdXJhdGVseSBwcmVzZXJ2ZSB0aGUgYmVoYXZpb3Igb2ZcbiAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGJ1dCBJJ20gZ3Vlc3NpbmcgdGhhdCB3YXMgbm90IGludGVudGlvbmFsLlxuICAgICAgICAgIC8vIEZvciBhbiBhY3R1YWwgZXJyb3Igc3ViY2xhc3MsIHRoaXMgcHJvcGVydHkgd291bGRcbiAgICAgICAgICAvLyBiZSBjb25maWd1cmFibGUuXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHRvU3RyaW5nOiB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBDdXN0b21FcnJvcjtcbiAgICB9XG4gICAgdXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuICAgIHV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcbiAgICB1dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpMiA9IGtleXMubGVuZ3RoIC0gMTsgaTIgPiAtMTsgLS1pMilcbiAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpMl1dID09PSAxICYmIHRoaXNba2V5c1tpMl1dICE9PSB2b2lkIDAgJiYgdGhpc1trZXlzW2kyXV0gIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4ga2V5c1tpMl07XG4gICAgICB9O1xuICAgIH07XG4gICAgdXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgICAgfTtcbiAgICB9O1xuICAgIHV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgICBlbnVtczogU3RyaW5nLFxuICAgICAgYnl0ZXM6IFN0cmluZyxcbiAgICAgIGpzb246IHRydWVcbiAgICB9O1xuICAgIHV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEJ1ZmZlcjIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAgIGlmICghQnVmZmVyMikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyMi5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyMi5mcm9tIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICB9O1xuICAgICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyMi5hbGxvY1Vuc2FmZSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIyKHNpemUpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qc1xudmFyIHJlcXVpcmVfd3JpdGVyID0gX19jb21tb25KUyh7XG4gIFwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlci5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gV3JpdGVyO1xuICAgIHZhciB1dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgdmFyIEJ1ZmZlcldyaXRlcjtcbiAgICB2YXIgTG9uZ0JpdHMgPSB1dGlsLkxvbmdCaXRzO1xuICAgIHZhciBiYXNlNjQgPSB1dGlsLmJhc2U2NDtcbiAgICB2YXIgdXRmOCA9IHV0aWwudXRmODtcbiAgICBmdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcbiAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgIHRoaXMubGVuID0gbGVuO1xuICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuICAgICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG4gICAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcbiAgICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcbiAgICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRlcigpIHtcbiAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcbiAgICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZTIoKSB7XG4gICAgICByZXR1cm4gdXRpbC5CdWZmZXIgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgfTtcbiAgICB9O1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBXcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG4gICAgfTtcbiAgICBpZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG4gICAgV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgICAgfVxuICAgICAgYnVmW3Bvc10gPSB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICBWYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG4gICAgVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcbiAgICBXcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMCkgPCAxMjggPyAxIDogdmFsdWUgPCAxNjM4NCA/IDIgOiB2YWx1ZSA8IDIwOTcxNTIgPyAzIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0IDogNSxcbiAgICAgICAgdmFsdWVcbiAgICAgICkpLmxlbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPCAwID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIDogdGhpcy51aW50MzIodmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgICB9XG4gICAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICAgIH1cbiAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG4gICAgfVxuICAgIFdyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG4gICAgfTtcbiAgICBXcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAxXSA9IHZhbCA+Pj4gOCAmIDI1NTtcbiAgICAgIGJ1Zltwb3MgKyAyXSA9IHZhbCA+Pj4gMTYgJiAyNTU7XG4gICAgICBidWZbcG9zICsgM10gPSB2YWwgPj4+IDI0O1xuICAgIH1cbiAgICBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG4gICAgV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG4gICAgV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xuICAgIH07XG4gICAgdmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXQgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICBidWYuc2V0KHZhbCwgcG9zKTtcbiAgICB9IDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgICByZXR1cm4gbGVuID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKSA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCwgdGFpbCA9IHRoaXMudGFpbCwgbGVuID0gdGhpcy5sZW47XG4gICAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0O1xuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFdyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgYnVmID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksIHBvcyA9IDA7XG4gICAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWY7XG4gICAgfTtcbiAgICBXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qc1xudmFyIHJlcXVpcmVfd3JpdGVyX2J1ZmZlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG4gICAgdmFyIFdyaXRlciA9IHJlcXVpcmVfd3JpdGVyKCk7XG4gICAgKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICAgIFdyaXRlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuICAgICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIiA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7XG4gICAgICB9IDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgaWYgKHZhbC5jb3B5KVxuICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IClcbiAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICB9O1xuICAgIH07XG4gICAgQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgIGlmICh2YWwubGVuZ3RoIDwgNDApXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xuICAgIH1cbiAgICBCdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanNcbnZhciByZXF1aXJlX3JlYWRlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXIuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IFJlYWRlcjtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIHZhciBCdWZmZXJSZWFkZXI7XG4gICAgdmFyIExvbmdCaXRzID0gdXRpbC5Mb25nQml0cztcbiAgICB2YXIgdXRmOCA9IHV0aWwudXRmODtcbiAgICBmdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcbiAgICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH0gOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkyKGJ1ZmZlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcbiAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlMigpIHtcbiAgICAgIHJldHVybiB1dGlsLkJ1ZmZlciA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyMikge1xuICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIyKSA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyMikgOiBjcmVhdGVfYXJyYXkoYnVmZmVyMik7XG4gICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICB9IDogY3JlYXRlX2FycmF5O1xuICAgIH07XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIFJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDcpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDE1KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7XG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbiAgICB9XG4gICAgUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHtcbiAgICAgIHJldHVybiAoYnVmW2VuZCAtIDRdIHwgYnVmW2VuZCAtIDNdIDw8IDggfCBidWZbZW5kIC0gMl0gPDwgMTYgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xuICAgIH1cbiAgICBSZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlYWRGaXhlZDY0KCkge1xuICAgICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG4gICAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xuICAgIH1cbiAgICBSZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcbiAgICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuICAgICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG4gICAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcbiAgICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgICB0aGlzLnBvcyArPSA4O1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSwgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5wb3MgKyBsZW5ndGg7XG4gICAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICB2YXIgbmF0aXZlQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgICAgIHJldHVybiBuYXRpdmVCdWZmZXIgPyBuYXRpdmVCdWZmZXIuYWxsb2MoMCkgOiBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbiAgICB9O1xuICAgIFJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBSZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiAgICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAoXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIFwidG9OdW1iZXJcIlxuICAgICAgKTtcbiAgICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qc1xudmFyIHJlcXVpcmVfcmVhZGVyX2J1ZmZlciA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzXCIoZXhwb3J0czIsIG1vZHVsZTIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBtb2R1bGUyLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG4gICAgdmFyIFJlYWRlciA9IHJlcXVpcmVfcmVhZGVyKCk7XG4gICAgKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG4gICAgfVxuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xuICAgIH07XG4gICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2UgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSkgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xuICAgIH07XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qc1xudmFyIHJlcXVpcmVfc2VydmljZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gU2VydmljZTtcbiAgICB2YXIgdXRpbCA9IHJlcXVpcmVfbWluaW1hbCgpO1xuICAgIChTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuICAgIGZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuICAgICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcbiAgICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbiAgICB9XG4gICAgU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmMiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcbiAgICAgIGlmICghc2VsZjIucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYyLnJwY0ltcGwoXG4gICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYyLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBzZWxmMi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzZWxmMi5lbmQoXG4gICAgICAgICAgICAgICAgLyogZW5kZWRCeVJQQyAqL1xuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYyLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICAgIHNlbGYyLmVtaXQoXCJlcnJvclwiLCBlcnIyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZjIuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmMi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKVxuICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanNcbnZhciByZXF1aXJlX3JwYyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanNcIihleHBvcnRzMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBycGMgPSBleHBvcnRzMjtcbiAgICBycGMuU2VydmljZSA9IHJlcXVpcmVfc2VydmljZSgpO1xuICB9XG59KTtcblxuLy8gbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3RzLmpzXG52YXIgcmVxdWlyZV9yb290cyA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgbW9kdWxlMi5leHBvcnRzID0ge307XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qc1xudmFyIHJlcXVpcmVfaW5kZXhfbWluaW1hbCA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzXCIoZXhwb3J0czIpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcHJvdG9idWYgPSBleHBvcnRzMjtcbiAgICBwcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuICAgIHByb3RvYnVmLldyaXRlciA9IHJlcXVpcmVfd3JpdGVyKCk7XG4gICAgcHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZV93cml0ZXJfYnVmZmVyKCk7XG4gICAgcHJvdG9idWYuUmVhZGVyID0gcmVxdWlyZV9yZWFkZXIoKTtcbiAgICBwcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlX3JlYWRlcl9idWZmZXIoKTtcbiAgICBwcm90b2J1Zi51dGlsID0gcmVxdWlyZV9taW5pbWFsKCk7XG4gICAgcHJvdG9idWYucnBjID0gcmVxdWlyZV9ycGMoKTtcbiAgICBwcm90b2J1Zi5yb290cyA9IHJlcXVpcmVfcm9vdHMoKTtcbiAgICBwcm90b2J1Zi5jb25maWd1cmUgPSBjb25maWd1cmU7XG4gICAgZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xuICAgICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbiAgICB9XG4gICAgY29uZmlndXJlKCk7XG4gIH1cbn0pO1xuXG4vLyBub2RlX21vZHVsZXMvcHJvdG9idWZqcy9taW5pbWFsLmpzXG52YXIgcmVxdWlyZV9taW5pbWFsMiA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanNcIihleHBvcnRzMiwgbW9kdWxlMikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIG1vZHVsZTIuZXhwb3J0cyA9IHJlcXVpcmVfaW5kZXhfbWluaW1hbCgpO1xuICB9XG59KTtcblxuLy8gc3JjL3RlYXJzaGVldC5qc1xudmFyIHJlcXVpcmVfdGVhcnNoZWV0ID0gX19jb21tb25KUyh7XG4gIFwic3JjL3RlYXJzaGVldC5qc1wiKGV4cG9ydHMyLCBtb2R1bGUyKSB7XG4gICAgdmFyICRwcm90b2J1ZiA9IHJlcXVpcmVfbWluaW1hbDIoKTtcbiAgICB2YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXI7XG4gICAgdmFyICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyO1xuICAgIHZhciAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuICAgIHZhciAkcm9vdCA9ICRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gfHwgKCRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gPSB7fSk7XG4gICAgJHJvb3QuZXBvY2hfcHJvdG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlcG9jaF9wcm90byA9IHt9O1xuICAgICAgZXBvY2hfcHJvdG8uQ2FyZERlZkxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2FyZERlZkxpc3QocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuY2FyZHMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENhcmREZWZMaXN0LnByb3RvdHlwZS5jYXJkcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIENhcmREZWZMaXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBDYXJkRGVmTGlzdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZkxpc3QuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXJkcyAhPSBudWxsICYmIG1lc3NhZ2UuY2FyZHMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNhcmRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmLmVuY29kZShtZXNzYWdlLmNhcmRzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWZMaXN0LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZkxpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmTGlzdCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jYXJkcyAmJiBtZXNzYWdlLmNhcmRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhcmRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jYXJkcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkNhcmREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmTGlzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWZMaXN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXJkcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXJkc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY2FyZHMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXJkczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jYXJkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmLnZlcmlmeShtZXNzYWdlLmNhcmRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNhcmRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmTGlzdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERlZkxpc3QpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWZMaXN0KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXJkcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5jYXJkcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DYXJkRGVmTGlzdC5jYXJkczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNhcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5jYXJkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYXJkc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2FyZERlZkxpc3QuY2FyZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXJkc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWYuZnJvbU9iamVjdChvYmplY3QuY2FyZHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZkxpc3QudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5jYXJkcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhcmRzICYmIG1lc3NhZ2UuY2FyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuY2FyZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5jYXJkcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmNhcmRzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERlZi50b09iamVjdChtZXNzYWdlLmNhcmRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZkxpc3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZkxpc3QuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5DYXJkRGVmTGlzdFwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2FyZERlZkxpc3Q7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5DaGFydExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhcnRMaXN0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmNoYXJ0cyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ2hhcnRMaXN0LnByb3RvdHlwZS5jaGFydHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBDaGFydExpc3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENoYXJ0TGlzdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnRMaXN0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnRzICE9IG51bGwgJiYgbWVzc2FnZS5jaGFydHMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNoYXJ0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnQuZW5jb2RlKG1lc3NhZ2UuY2hhcnRzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0TGlzdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0TGlzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0TGlzdCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jaGFydHMgJiYgbWVzc2FnZS5jaGFydHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydHMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5DaGFydC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0TGlzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0TGlzdC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY2hhcnRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNoYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydC52ZXJpZnkobWVzc2FnZS5jaGFydHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydExpc3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0TGlzdClcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnRMaXN0KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuY2hhcnRzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0TGlzdC5jaGFydHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0TGlzdC5jaGFydHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydHNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydC5mcm9tT2JqZWN0KG9iamVjdC5jaGFydHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnRMaXN0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnRzID0gW107XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnRzICYmIG1lc3NhZ2UuY2hhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmNoYXJ0cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmNoYXJ0c1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0LnRvT2JqZWN0KG1lc3NhZ2UuY2hhcnRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnRMaXN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0TGlzdC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkNoYXJ0TGlzdFwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2hhcnRMaXN0O1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uVGFibGVMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRhYmxlTGlzdChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy50YWJsZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRhYmxlTGlzdC5wcm90b3R5cGUudGFibGVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgVGFibGVMaXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBUYWJsZUxpc3QocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlTGlzdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRhYmxlcyAhPSBudWxsICYmIG1lc3NhZ2UudGFibGVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50YWJsZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlRhYmxlLmVuY29kZShtZXNzYWdlLnRhYmxlc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZUxpc3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZUxpc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudGFibGVzICYmIG1lc3NhZ2UudGFibGVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnRhYmxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGFibGVzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uVGFibGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZUxpc3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZUxpc3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRhYmxlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0YWJsZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnRhYmxlcykpXG4gICAgICAgICAgICAgIHJldHVybiBcInRhYmxlczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS50YWJsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGUudmVyaWZ5KG1lc3NhZ2UudGFibGVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInRhYmxlcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVMaXN0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlTGlzdCgpO1xuICAgICAgICAgIGlmIChvYmplY3QudGFibGVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnRhYmxlcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZUxpc3QudGFibGVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UudGFibGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC50YWJsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGFibGVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZUxpc3QudGFibGVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UudGFibGVzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGUuZnJvbU9iamVjdChvYmplY3QudGFibGVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlTGlzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LnRhYmxlcyA9IFtdO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRhYmxlcyAmJiBtZXNzYWdlLnRhYmxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC50YWJsZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS50YWJsZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC50YWJsZXNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZS50b09iamVjdChtZXNzYWdlLnRhYmxlc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlTGlzdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZUxpc3QuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5UYWJsZUxpc3RcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRhYmxlTGlzdDtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlRlYXJTaGVldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUZWFyU2hlZXQocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGVhclNoZWV0LnByb3RvdHlwZS5jYXJkcyA9IG51bGw7XG4gICAgICAgIFRlYXJTaGVldC5wcm90b3R5cGUuY2hhcnRzID0gbnVsbDtcbiAgICAgICAgVGVhclNoZWV0LnByb3RvdHlwZS50YWJsZXMgPSBudWxsO1xuICAgICAgICBUZWFyU2hlZXQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRlYXJTaGVldChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVhclNoZWV0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2FyZHMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNhcmRzXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERlZkxpc3QuZW5jb2RlKG1lc3NhZ2UuY2FyZHMsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnRzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydHNcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DaGFydExpc3QuZW5jb2RlKG1lc3NhZ2UuY2hhcnRzLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRhYmxlcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGFibGVzXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVMaXN0LmVuY29kZShtZXNzYWdlLnRhYmxlcywgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBUZWFyU2hlZXQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBUZWFyU2hlZXQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UZWFyU2hlZXQoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2FyZHMgPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmTGlzdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnRzID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnRMaXN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50YWJsZXMgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRlYXJTaGVldC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFRlYXJTaGVldC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2FyZHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2FyZHNcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWZMaXN0LnZlcmlmeShtZXNzYWdlLmNhcmRzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2FyZHMuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0c1wiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnRMaXN0LnZlcmlmeShtZXNzYWdlLmNoYXJ0cyk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0cy5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50YWJsZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGFibGVzXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QudmVyaWZ5KG1lc3NhZ2UudGFibGVzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGFibGVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBUZWFyU2hlZXQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlRlYXJTaGVldClcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uVGVhclNoZWV0KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXJkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYXJkcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRlYXJTaGVldC5jYXJkczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jYXJkcyA9ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWZMaXN0LmZyb21PYmplY3Qob2JqZWN0LmNhcmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuY2hhcnRzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uVGVhclNoZWV0LmNoYXJ0czogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydHMgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydExpc3QuZnJvbU9iamVjdChvYmplY3QuY2hhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC50YWJsZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudGFibGVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uVGVhclNoZWV0LnRhYmxlczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS50YWJsZXMgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QuZnJvbU9iamVjdChvYmplY3QudGFibGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFRlYXJTaGVldC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuY2FyZHMgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0cyA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QudGFibGVzID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2FyZHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2FyZHNcIikpXG4gICAgICAgICAgICBvYmplY3QuY2FyZHMgPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmTGlzdC50b09iamVjdChtZXNzYWdlLmNhcmRzLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnRzXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0cyA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0TGlzdC50b09iamVjdChtZXNzYWdlLmNoYXJ0cywgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGFibGVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRhYmxlc1wiKSlcbiAgICAgICAgICAgIG9iamVjdC50YWJsZXMgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZUxpc3QudG9PYmplY3QobWVzc2FnZS50YWJsZXMsIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFRlYXJTaGVldC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBUZWFyU2hlZXQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5UZWFyU2hlZXRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRlYXJTaGVldDtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkZ1bGxUZWFyU2hlZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gRnVsbFRlYXJTaGVldChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5jYXRlZ29yaWVzID0ge307XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBGdWxsVGVhclNoZWV0LnByb3RvdHlwZS5jYXRlZ29yaWVzID0gJHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgICAgIEZ1bGxUZWFyU2hlZXQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZWFyU2hlZXQocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEZ1bGxUZWFyU2hlZXQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yaWVzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjYXRlZ29yaWVzXCIpKVxuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKG1lc3NhZ2UuY2F0ZWdvcmllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5zdHJpbmcoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlRlYXJTaGVldC5lbmNvZGUobWVzc2FnZS5jYXRlZ29yaWVzW2tleXNbaV1dLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEZ1bGxUZWFyU2hlZXQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBGdWxsVGVhclNoZWV0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uRnVsbFRlYXJTaGVldCgpLCBrZXksIHZhbHVlO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcmllcyA9PT0gJHV0aWwuZW1wdHlPYmplY3QpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFnMiA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnMiA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAga2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAkcm9vdC5lcG9jaF9wcm90by5UZWFyU2hlZXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnMiAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgRnVsbFRlYXJTaGVldC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEZ1bGxUZWFyU2hlZXQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcmllc1wiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc09iamVjdChtZXNzYWdlLmNhdGVnb3JpZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yaWVzOiBvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhtZXNzYWdlLmNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uVGVhclNoZWV0LnZlcmlmeShtZXNzYWdlLmNhdGVnb3JpZXNba2V5W2ldXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yaWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBGdWxsVGVhclNoZWV0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5GdWxsVGVhclNoZWV0KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5GdWxsVGVhclNoZWV0KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYXRlZ29yaWVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uRnVsbFRlYXJTaGVldC5jYXRlZ29yaWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QuY2F0ZWdvcmllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jYXRlZ29yaWVzW2tleXNbaV1dICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5GdWxsVGVhclNoZWV0LmNhdGVnb3JpZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzW2tleXNbaV1dID0gJHJvb3QuZXBvY2hfcHJvdG8uVGVhclNoZWV0LmZyb21PYmplY3Qob2JqZWN0LmNhdGVnb3JpZXNba2V5c1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgRnVsbFRlYXJTaGVldC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLm9iamVjdHMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yaWVzID0ge307XG4gICAgICAgICAgdmFyIGtleXMyO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgJiYgKGtleXMyID0gT2JqZWN0LmtleXMobWVzc2FnZS5jYXRlZ29yaWVzKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzMi5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3JpZXNba2V5czJbal1dID0gJHJvb3QuZXBvY2hfcHJvdG8uVGVhclNoZWV0LnRvT2JqZWN0KG1lc3NhZ2UuY2F0ZWdvcmllc1trZXlzMltqXV0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBGdWxsVGVhclNoZWV0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEZ1bGxUZWFyU2hlZXQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5GdWxsVGVhclNoZWV0XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGdWxsVGVhclNoZWV0O1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiV2lkZ2V0VW5zcGVjaWZpZWRcIl0gPSAwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiV2lkZ2V0Q2FyZFwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJXaWRnZXRMaW5lc1wiXSA9IDI7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzNdID0gXCJXaWRnZXRCYXJcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiV2lkZ2V0RGF0YVRhYmxlXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIldpZGdldFhSYW5nZVwiXSA9IDU7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJXaWRnZXRIaXN0b2dyYW1cIl0gPSA2O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiV2lkZ2V0UGllXCJdID0gNztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbOF0gPSBcIldpZGdldEhlYXRNYXBcIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiV2lkZ2V0Qm94UGxvdFwiXSA9IDk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzEwXSA9IFwiV2lkZ2V0QXJlYVwiXSA9IDEwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMV0gPSBcIldpZGdldENvbHVtblwiXSA9IDExO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uRXBvY2hGb2xpb1R5cGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIlR5cGVVbnNwZWNpZmllZFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJUeXBlU3RyaW5nXCJdID0gMTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlR5cGVJbnRlZ2VyXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIlR5cGVEZWNpbWFsXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlR5cGVQZXJjZW50XCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIlR5cGVCb29sZWFuXCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIlR5cGVEYXRlVGltZVwiXSA9IDY7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzddID0gXCJUeXBlRGF0ZVwiXSA9IDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJUeXBlRGF5RHVyYXRpb25cIl0gPSA4O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs5XSA9IFwiVHlwZU1vbmV0YXJ5XCJdID0gOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJUeXBlRHVyYXRpb25cIl0gPSAxMDtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlNjYWxhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBTY2FsYXIocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuaW50ZWdlclZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kZWNpbWFsVmFsdWUgPSBudWxsO1xuICAgICAgICBTY2FsYXIucHJvdG90eXBlLnBlcmNlbnRWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuYm9vbGVhblZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS50aW1lc3RhbXBNcyA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuZGF0ZVZhbHVlID0gbnVsbDtcbiAgICAgICAgU2NhbGFyLnByb3RvdHlwZS5kYXlEdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUubW9uZXRhcnlWYWx1ZSA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUuZHVyYXRpb25NcyA9IG51bGw7XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUubnVsbFZhbHVlID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNjYWxhci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wic3RyaW5nVmFsdWVcIiwgXCJpbnRlZ2VyVmFsdWVcIiwgXCJkZWNpbWFsVmFsdWVcIiwgXCJwZXJjZW50VmFsdWVcIiwgXCJib29sZWFuVmFsdWVcIiwgXCJ0aW1lc3RhbXBNc1wiLCBcImRhdGVWYWx1ZVwiLCBcImRheUR1cmF0aW9uXCIsIFwibW9uZXRhcnlWYWx1ZVwiLCBcImR1cmF0aW9uTXNcIiwgXCJudWxsVmFsdWVcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgU2NhbGFyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXIocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ1ZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzdHJpbmdWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pbnRlZ2VyVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImludGVnZXJWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDE2XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UuaW50ZWdlclZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kZWNpbWFsVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRlY2ltYWxWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDI1XG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLmRlY2ltYWxWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGVyY2VudFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJwZXJjZW50VmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAzM1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5wZXJjZW50VmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xlYW5WYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYm9vbGVhblZhbHVlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgNDBcbiAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLmJvb2xlYW5WYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wTXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRpbWVzdGFtcE1zXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgNDhcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS50aW1lc3RhbXBNcyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0ZVZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXRlVmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA3LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA1NlxuICAgICAgICAgICAgKS5pbnQ2NChtZXNzYWdlLmRhdGVWYWx1ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF5RHVyYXRpb24gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRheUR1cmF0aW9uXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgOCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgNjRcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS5kYXlEdXJhdGlvbik7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibW9uZXRhcnlWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDksIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDczXG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLm1vbmV0YXJ5VmFsdWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmR1cmF0aW9uTXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImR1cmF0aW9uTXNcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxMCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgODBcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS5kdXJhdGlvbk1zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm51bGxWYWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDExLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4OFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLm51bGxWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ1ZhbHVlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kZWNpbWFsVmFsdWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wZXJjZW50VmFsdWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ib29sZWFuVmFsdWUgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTXMgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDc6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGVWYWx1ZSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgODoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF5RHVyYXRpb24gPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZHVyYXRpb25NcyA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgU2NhbGFyLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ1ZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ1ZhbHVlXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5zdHJpbmdWYWx1ZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1ZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW50ZWdlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImludGVnZXJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5pbnRlZ2VyVmFsdWUpICYmICEobWVzc2FnZS5pbnRlZ2VyVmFsdWUgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50ZWdlclZhbHVlLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuaW50ZWdlclZhbHVlLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaW50ZWdlclZhbHVlOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGVjaW1hbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlY2ltYWxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmRlY2ltYWxWYWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGVjaW1hbFZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGVyY2VudFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBlcmNlbnRWYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnBlcmNlbnRWYWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwicGVyY2VudFZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYm9vbGVhblZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJvb2xlYW5WYWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmJvb2xlYW5WYWx1ZSAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5WYWx1ZTogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXBNcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aW1lc3RhbXBNc1wiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50aW1lc3RhbXBNcykgJiYgIShtZXNzYWdlLnRpbWVzdGFtcE1zICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRpbWVzdGFtcE1zLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudGltZXN0YW1wTXMuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ0aW1lc3RhbXBNczogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGVWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRlVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnZhbHVlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnZhbHVlID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZGF0ZVZhbHVlKSAmJiAhKG1lc3NhZ2UuZGF0ZVZhbHVlICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRhdGVWYWx1ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRhdGVWYWx1ZS5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGVWYWx1ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRheUR1cmF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRheUR1cmF0aW9uXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmRheUR1cmF0aW9uKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF5RHVyYXRpb246IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtb25ldGFyeVZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwibW9uZXRhcnlWYWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmR1cmF0aW9uTXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZHVyYXRpb25Nc1wiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMudmFsdWUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kdXJhdGlvbk1zKSAmJiAhKG1lc3NhZ2UuZHVyYXRpb25NcyAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5kdXJhdGlvbk1zLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZHVyYXRpb25Ncy5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImR1cmF0aW9uTXM6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy52YWx1ZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFZhbHVlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnN0cmluZ1ZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnN0cmluZ1ZhbHVlID0gU3RyaW5nKG9iamVjdC5zdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5pbnRlZ2VyVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmludGVnZXJWYWx1ZSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5pbnRlZ2VyVmFsdWUpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRlZ2VyVmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gcGFyc2VJbnQob2JqZWN0LmludGVnZXJWYWx1ZSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5pbnRlZ2VyVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuaW50ZWdlclZhbHVlID0gb2JqZWN0LmludGVnZXJWYWx1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuaW50ZWdlclZhbHVlID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmludGVnZXJWYWx1ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuaW50ZWdlclZhbHVlLmxvdyA+Pj4gMCwgb2JqZWN0LmludGVnZXJWYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRlY2ltYWxWYWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5kZWNpbWFsVmFsdWUgPSBOdW1iZXIob2JqZWN0LmRlY2ltYWxWYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5wZXJjZW50VmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UucGVyY2VudFZhbHVlID0gTnVtYmVyKG9iamVjdC5wZXJjZW50VmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QuYm9vbGVhblZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmJvb2xlYW5WYWx1ZSA9IEJvb2xlYW4ob2JqZWN0LmJvb2xlYW5WYWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC50aW1lc3RhbXBNcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UudGltZXN0YW1wTXMgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QudGltZXN0YW1wTXMpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC50aW1lc3RhbXBNcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IHBhcnNlSW50KG9iamVjdC50aW1lc3RhbXBNcywgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC50aW1lc3RhbXBNcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS50aW1lc3RhbXBNcyA9IG9iamVjdC50aW1lc3RhbXBNcztcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QudGltZXN0YW1wTXMgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wTXMgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LnRpbWVzdGFtcE1zLmxvdyA+Pj4gMCwgb2JqZWN0LnRpbWVzdGFtcE1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZGF0ZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5kYXRlVmFsdWUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZGF0ZVZhbHVlKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGF0ZVZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGVWYWx1ZSA9IHBhcnNlSW50KG9iamVjdC5kYXRlVmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZGF0ZVZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmRhdGVWYWx1ZSA9IG9iamVjdC5kYXRlVmFsdWU7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGVWYWx1ZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXRlVmFsdWUgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LmRhdGVWYWx1ZS5sb3cgPj4+IDAsIG9iamVjdC5kYXRlVmFsdWUuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXlEdXJhdGlvbiAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5kYXlEdXJhdGlvbiA9IG9iamVjdC5kYXlEdXJhdGlvbiB8IDA7XG4gICAgICAgICAgaWYgKG9iamVjdC5tb25ldGFyeVZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgPSBOdW1iZXIob2JqZWN0Lm1vbmV0YXJ5VmFsdWUpO1xuICAgICAgICAgIGlmIChvYmplY3QuZHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UuZHVyYXRpb25NcyA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5kdXJhdGlvbk1zKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZHVyYXRpb25NcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gcGFyc2VJbnQob2JqZWN0LmR1cmF0aW9uTXMsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZHVyYXRpb25NcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5kdXJhdGlvbk1zID0gb2JqZWN0LmR1cmF0aW9uTXM7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmR1cmF0aW9uTXMgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZHVyYXRpb25NcyA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZHVyYXRpb25Ncy5sb3cgPj4+IDAsIG9iamVjdC5kdXJhdGlvbk1zLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lm51bGxWYWx1ZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubnVsbFZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSBvYmplY3QubnVsbFZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk5VTExfVkFMVUVcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS5udWxsVmFsdWUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ1ZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ1ZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3Quc3RyaW5nVmFsdWUgPSBtZXNzYWdlLnN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcInN0cmluZ1ZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmludGVnZXJWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbnRlZ2VyVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5pbnRlZ2VyVmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC5pbnRlZ2VyVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5pbnRlZ2VyVmFsdWUpIDogbWVzc2FnZS5pbnRlZ2VyVmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5pbnRlZ2VyVmFsdWUgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuaW50ZWdlclZhbHVlKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmludGVnZXJWYWx1ZS5sb3cgPj4+IDAsIG1lc3NhZ2UuaW50ZWdlclZhbHVlLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLmludGVnZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJpbnRlZ2VyVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGVjaW1hbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRlY2ltYWxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmRlY2ltYWxWYWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5kZWNpbWFsVmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UuZGVjaW1hbFZhbHVlKSA6IG1lc3NhZ2UuZGVjaW1hbFZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImRlY2ltYWxWYWx1ZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wZXJjZW50VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGVyY2VudFZhbHVlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QucGVyY2VudFZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLnBlcmNlbnRWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5wZXJjZW50VmFsdWUpIDogbWVzc2FnZS5wZXJjZW50VmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwicGVyY2VudFZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xlYW5WYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sZWFuVmFsdWVcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5ib29sZWFuVmFsdWUgPSBtZXNzYWdlLmJvb2xlYW5WYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJib29sZWFuVmFsdWVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wTXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGltZXN0YW1wTXNcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS50aW1lc3RhbXBNcyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcE1zID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UudGltZXN0YW1wTXMpIDogbWVzc2FnZS50aW1lc3RhbXBNcztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnRpbWVzdGFtcE1zID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnRpbWVzdGFtcE1zKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLnRpbWVzdGFtcE1zLmxvdyA+Pj4gMCwgbWVzc2FnZS50aW1lc3RhbXBNcy5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS50aW1lc3RhbXBNcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJ0aW1lc3RhbXBNc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRlVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0ZVZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZGF0ZVZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QuZGF0ZVZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZGF0ZVZhbHVlKSA6IG1lc3NhZ2UuZGF0ZVZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuZGF0ZVZhbHVlID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmRhdGVWYWx1ZSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5kYXRlVmFsdWUubG93ID4+PiAwLCBtZXNzYWdlLmRhdGVWYWx1ZS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5kYXRlVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiZGF0ZVZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRheUR1cmF0aW9uICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRheUR1cmF0aW9uXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuZGF5RHVyYXRpb24gPSBtZXNzYWdlLmRheUR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImRheUR1cmF0aW9uXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm1vbmV0YXJ5VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibW9uZXRhcnlWYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0Lm1vbmV0YXJ5VmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UubW9uZXRhcnlWYWx1ZSkgPyBTdHJpbmcobWVzc2FnZS5tb25ldGFyeVZhbHVlKSA6IG1lc3NhZ2UubW9uZXRhcnlWYWx1ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJtb25ldGFyeVZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmR1cmF0aW9uTXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZHVyYXRpb25Nc1wiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmR1cmF0aW9uTXMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC5kdXJhdGlvbk1zID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuZHVyYXRpb25NcykgOiBtZXNzYWdlLmR1cmF0aW9uTXM7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5kdXJhdGlvbk1zID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLmR1cmF0aW9uTXMpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZHVyYXRpb25Ncy5sb3cgPj4+IDAsIG1lc3NhZ2UuZHVyYXRpb25Ncy5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5kdXJhdGlvbk1zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBcImR1cmF0aW9uTXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bGxWYWx1ZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0Lm51bGxWYWx1ZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVbbWVzc2FnZS5udWxsVmFsdWVdID09PSB2b2lkIDAgPyBtZXNzYWdlLm51bGxWYWx1ZSA6ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5OdWxsVmFsdWVbbWVzc2FnZS5udWxsVmFsdWVdIDogbWVzc2FnZS5udWxsVmFsdWU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwibnVsbFZhbHVlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFNjYWxhci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBTY2FsYXIuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5TY2FsYXJcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNjYWxhcjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEFycmF5Mihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5Mi5wcm90b3R5cGUudmFsdWVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgQXJyYXkyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheTIocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5lbmNvZGUobWVzc2FnZS52YWx1ZXNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudmFsdWVzICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5Mi5pc0FycmF5KG1lc3NhZ2UudmFsdWVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudmVyaWZ5KG1lc3NhZ2UudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5BcnJheSlcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheTIuaXNBcnJheShvYmplY3QudmFsdWVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkFycmF5LnZhbHVlczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QudmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQXJyYXkudmFsdWVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmZyb21PYmplY3Qob2JqZWN0LnZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBBcnJheTIudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QudmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQXJyYXkyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEFycmF5Mi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkFycmF5XCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBcnJheTI7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5BeGlzVHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiQXhpc1Vuc3BlY2lmaWVkXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkF4aXNMaW5lYXJcIl0gPSAxO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsyXSA9IFwiQXhpc0xvZ2FyaXRobWljXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIkF4aXNEYXRlVGltZVwiXSA9IDM7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzRdID0gXCJBeGlzQ2F0ZWdvcnlcIl0gPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uRGFzaFN0eWxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJEYXNoU3R5bGVVbnNwZWNpZmllZFwiXSA9IDA7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJTb2xpZFwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJTaG9ydERhc2hcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiU2hvcnREb3RcIl0gPSAzO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs0XSA9IFwiU2hvcnREYXNoRG90XCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIlNob3J0RGFzaERvdERvdFwiXSA9IDU7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzZdID0gXCJEb3RcIl0gPSA2O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs3XSA9IFwiRGFzaFwiXSA9IDc7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzhdID0gXCJMb25nRGFzaFwiXSA9IDg7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzldID0gXCJEYXNoRG90XCJdID0gOTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMTBdID0gXCJMb25nRGFzaERvdFwiXSA9IDEwO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxMV0gPSBcIkxvbmdEYXNoRG90RG90XCJdID0gMTE7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Db2x1bW5EZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29sdW1uRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENvbHVtbkRlZi5wcm90b3R5cGUuaWQgPSBcIlwiO1xuICAgICAgICBDb2x1bW5EZWYucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBDb2x1bW5EZWYucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBDb2x1bW5EZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvbHVtbkRlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImlkXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMjRcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlkKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaWQ6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIENvbHVtbkRlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQ29sdW1uRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmlkICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmlkID0gU3RyaW5nKG9iamVjdC5pZCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5uYW1lICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSBTdHJpbmcob2JqZWN0Lm5hbWUpO1xuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlVW5zcGVjaWZpZWRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZVN0cmluZ1wiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlSW50ZWdlclwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGVjaW1hbFwiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlUGVyY2VudFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlQm9vbGVhblwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRGF0ZVRpbWVcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURhdGVcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURheUR1cmF0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVNb25ldGFyeVwiOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlRHVyYXRpb25cIjpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENvbHVtbkRlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuaWQgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIlR5cGVVbnNwZWNpZmllZFwiIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaWRcIikpXG4gICAgICAgICAgICBvYmplY3QuaWQgPSBtZXNzYWdlLmlkO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibmFtZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gbWVzc2FnZS5uYW1lO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb1R5cGVbbWVzc2FnZS50eXBlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS50eXBlIDogJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb1R5cGVbbWVzc2FnZS50eXBlXSA6IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBDb2x1bW5EZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ29sdW1uRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQ29sdW1uRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDb2x1bW5EZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5UYWJsZVJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUYWJsZVJvdyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRhYmxlUm93LnByb3RvdHlwZS52YWx1ZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBUYWJsZVJvdy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgVGFibGVSb3cocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlUm93LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmVuY29kZShtZXNzYWdlLnZhbHVlc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlUm93LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVSb3coKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudmFsdWVzICYmIG1lc3NhZ2UudmFsdWVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZVJvdy52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudmFsdWVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudmVyaWZ5KG1lc3NhZ2UudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlRhYmxlUm93KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdygpO1xuICAgICAgICAgIGlmIChvYmplY3QudmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnZhbHVlcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZVJvdy52YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlRhYmxlUm93LnZhbHVlczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZXMgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QudmFsdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QudmFsdWVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnRvT2JqZWN0KG1lc3NhZ2UudmFsdWVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVSb3cuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5UYWJsZVJvd1wiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGFibGVSb3c7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5UYWJsZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gVGFibGVEYXRhKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnJvd3MgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRhYmxlRGF0YS5wcm90b3R5cGUucm93cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRhYmxlRGF0YS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgVGFibGVEYXRhKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZURhdGEuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5yb3dzICE9IG51bGwgJiYgbWVzc2FnZS5yb3dzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5yb3dzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdy5lbmNvZGUobWVzc2FnZS5yb3dzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YSgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5yb3dzICYmIG1lc3NhZ2Uucm93cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yb3dzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5yb3dzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVSb3cuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZURhdGEuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZURhdGEudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnJvd3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicm93c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2Uucm93cykpXG4gICAgICAgICAgICAgIHJldHVybiBcInJvd3M6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uucm93cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZVJvdy52ZXJpZnkobWVzc2FnZS5yb3dzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInJvd3MuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVEYXRhKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UYWJsZURhdGEoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnJvd3MpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3Qucm93cykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZURhdGEucm93czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnJvd3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnJvd3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qucm93c1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uVGFibGVEYXRhLnJvd3M6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5yb3dzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVSb3cuZnJvbU9iamVjdChvYmplY3Qucm93c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZURhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5yb3dzID0gW107XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uucm93cyAmJiBtZXNzYWdlLnJvd3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3Qucm93cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnJvd3MubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5yb3dzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVSb3cudG9PYmplY3QobWVzc2FnZS5yb3dzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGVEYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFRhYmxlRGF0YS5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlRhYmxlRGF0YVwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gVGFibGVEYXRhO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uVGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gVGFibGUocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVGFibGUucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuY2F0ZWdvcnkgPSBcIlwiO1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUudGl0bGUgPSBcIlwiO1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUuY29sdW1ucyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFRhYmxlLnByb3RvdHlwZS5kYXRhID0gbnVsbDtcbiAgICAgICAgVGFibGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFRhYmxlKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInR5cGVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNhdGVnb3J5XCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0aXRsZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jb2x1bW5zICE9IG51bGwgJiYgbWVzc2FnZS5jb2x1bW5zLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jb2x1bW5zLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYuZW5jb2RlKG1lc3NhZ2UuY29sdW1uc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDM0XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJkYXRhXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uVGFibGVEYXRhLmVuY29kZShtZXNzYWdlLmRhdGEsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDQyXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jb2x1bW5zICYmIG1lc3NhZ2UuY29sdW1ucy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2x1bW5zID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jb2x1bW5zLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uQ29sdW1uRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmNhdGVnb3J5KSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcnk6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aXRsZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRpdGxlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGl0bGU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jb2x1bW5zICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNvbHVtbnNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmNvbHVtbnMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjb2x1bW5zOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNvbHVtbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ29sdW1uRGVmLnZlcmlmeShtZXNzYWdlLmNvbHVtbnNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY29sdW1ucy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlRhYmxlRGF0YS52ZXJpZnkobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YS5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgVGFibGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlRhYmxlKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5UYWJsZSgpO1xuICAgICAgICAgIHN3aXRjaCAob2JqZWN0LnR5cGUpIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSBvYmplY3QudHlwZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRVbnNwZWNpZmllZFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRDYXJkXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldExpbmVzXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEJhclwiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXREYXRhVGFibGVcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0WFJhbmdlXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEhpc3RvZ3JhbVwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRQaWVcIjpcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0SGVhdE1hcFwiOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRCb3hQbG90XCI6XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEFyZWFcIjpcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRDb2x1bW5cIjpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDExO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yeSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yeSA9IFN0cmluZyhvYmplY3QuY2F0ZWdvcnkpO1xuICAgICAgICAgIGlmIChvYmplY3QudGl0bGUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSBTdHJpbmcob2JqZWN0LnRpdGxlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNvbHVtbnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuY29sdW1ucykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZS5jb2x1bW5zOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY29sdW1ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuY29sdW1ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jb2x1bW5zW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZS5jb2x1bW5zOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuY29sdW1uc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkNvbHVtbkRlZi5mcm9tT2JqZWN0KG9iamVjdC5jb2x1bW5zW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5UYWJsZS5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZURhdGEuZnJvbU9iamVjdChvYmplY3QuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LmNvbHVtbnMgPSBbXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LnR5cGUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIldpZGdldFVuc3BlY2lmaWVkXCIgOiAwO1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5ID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC50aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldFttZXNzYWdlLnR5cGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0W21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlcIikpXG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnkgPSBtZXNzYWdlLmNhdGVnb3J5O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpdGxlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gbWVzc2FnZS50aXRsZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jb2x1bW5zICYmIG1lc3NhZ2UuY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5jb2x1bW5zID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuY29sdW1ucy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmNvbHVtbnNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5Db2x1bW5EZWYudG9PYmplY3QobWVzc2FnZS5jb2x1bW5zW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5UYWJsZURhdGEudG9PYmplY3QobWVzc2FnZS5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBUYWJsZS5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLlRhYmxlXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUYWJsZTtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkNhcmREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENhcmREYXRhKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENhcmREYXRhLnByb3RvdHlwZS50aXRsZSA9IFwiXCI7XG4gICAgICAgIENhcmREYXRhLnByb3RvdHlwZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIENhcmREYXRhLnByb3RvdHlwZS50eXBlID0gMDtcbiAgICAgICAgQ2FyZERhdGEucHJvdG90eXBlLmdyb3VwID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICAgICAgICBDYXJkRGF0YS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2FyZERhdGEocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREYXRhLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRpdGxlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UudGl0bGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5lbmNvZGUobWVzc2FnZS52YWx1ZSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMjRcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5ncm91cCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZ3JvdXBcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAzMlxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS5ncm91cCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNhcmREYXRhKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGF0YS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50aXRsZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInRpdGxlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci52ZXJpZnkobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidHlwZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXAgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JvdXBcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZ3JvdXApICYmICEobWVzc2FnZS5ncm91cCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5ncm91cC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmdyb3VwLmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZ3JvdXA6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkNhcmREYXRhKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YSgpO1xuICAgICAgICAgIGlmIChvYmplY3QudGl0bGUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSBTdHJpbmcob2JqZWN0LnRpdGxlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2FyZERhdGEudmFsdWU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZnJvbU9iamVjdChvYmplY3QudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG9iamVjdC50eXBlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gb2JqZWN0LnR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZVVuc3BlY2lmaWVkXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVTdHJpbmdcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZUludGVnZXJcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURlY2ltYWxcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZVBlcmNlbnRcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZUJvb2xlYW5cIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZURhdGVUaW1lXCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVEYXRlXCI6XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlR5cGVEYXlEdXJhdGlvblwiOlxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJUeXBlTW9uZXRhcnlcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVHlwZUR1cmF0aW9uXCI6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZ3JvdXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmdyb3VwID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0Lmdyb3VwKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cCA9IHBhcnNlSW50KG9iamVjdC5ncm91cCwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cCA9IG9iamVjdC5ncm91cDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZ3JvdXAgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXAgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0Lmdyb3VwLmxvdyA+Pj4gMCwgb2JqZWN0Lmdyb3VwLmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERhdGEudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiVHlwZVVuc3BlY2lmaWVkXCIgOiAwO1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgb2JqZWN0Lmdyb3VwID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXAgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpdGxlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gbWVzc2FnZS50aXRsZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci50b09iamVjdChtZXNzYWdlLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmVwb2NoX3Byb3RvLkVwb2NoRm9saW9UeXBlW21lc3NhZ2UudHlwZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UudHlwZSA6ICRyb290LmVwb2NoX3Byb3RvLkVwb2NoRm9saW9UeXBlW21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZ3JvdXAgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JvdXBcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZ3JvdXAgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC5ncm91cCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmdyb3VwKSA6IG1lc3NhZ2UuZ3JvdXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC5ncm91cCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5ncm91cCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5ncm91cC5sb3cgPj4+IDAsIG1lc3NhZ2UuZ3JvdXAuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLmdyb3VwO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREYXRhLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQ2FyZERhdGFcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENhcmREYXRhO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQ2FyZERlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBDYXJkRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENhcmREZWYucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBDYXJkRGVmLnByb3RvdHlwZS5jYXRlZ29yeSA9IFwiXCI7XG4gICAgICAgIENhcmREZWYucHJvdG90eXBlLmRhdGEgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBDYXJkRGVmLnByb3RvdHlwZS5ncm91cFNpemUgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gICAgICAgIENhcmREZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhcmREZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjYXRlZ29yeVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLmNhdGVnb3J5KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YS5lbmNvZGUobWVzc2FnZS5kYXRhW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmdyb3VwU2l6ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZ3JvdXBTaXplXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICkudWludDY0KG1lc3NhZ2UuZ3JvdXBTaXplKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNhcmREZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERhdGEuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ncm91cFNpemUgPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2FyZERlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKVxuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ0eXBlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmNhdGVnb3J5KSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcnk6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRhdGEpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERhdGEudmVyaWZ5KG1lc3NhZ2UuZGF0YVtpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmdyb3VwU2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJncm91cFNpemVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuZ3JvdXBTaXplKSAmJiAhKG1lc3NhZ2UuZ3JvdXBTaXplICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmdyb3VwU2l6ZS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmdyb3VwU2l6ZS5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImdyb3VwU2l6ZTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGVmKCk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFVuc3BlY2lmaWVkXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0TGluZXNcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QmFyXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldERhdGFUYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRYUmFuZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0SGlzdG9ncmFtXCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFBpZVwiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRIZWF0TWFwXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEJveFBsb3RcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QXJlYVwiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENvbHVtblwiOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmNhdGVnb3J5ICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5ID0gU3RyaW5nKG9iamVjdC5jYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmRhdGEpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2FyZERlZi5kYXRhOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXRhW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DYXJkRGVmLmRhdGE6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2FyZERhdGEuZnJvbU9iamVjdChvYmplY3QuZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuZ3JvdXBTaXplICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS5ncm91cFNpemUgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuZ3JvdXBTaXplKSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cFNpemUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBTaXplID0gcGFyc2VJbnQob2JqZWN0Lmdyb3VwU2l6ZSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5ncm91cFNpemUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuZ3JvdXBTaXplID0gb2JqZWN0Lmdyb3VwU2l6ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuZ3JvdXBTaXplID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLmdyb3VwU2l6ZSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuZ3JvdXBTaXplLmxvdyA+Pj4gMCwgb2JqZWN0Lmdyb3VwU2l6ZS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJXaWRnZXRVbnNwZWNpZmllZFwiIDogMDtcbiAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yeSA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXBTaXplID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuZ3JvdXBTaXplID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmVwb2NoX3Byb3RvLkVwb2NoRm9saW9EYXNoYm9hcmRXaWRnZXRbbWVzc2FnZS50eXBlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS50eXBlIDogJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldFttZXNzYWdlLnR5cGVdIDogbWVzc2FnZS50eXBlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3J5ID0gbWVzc2FnZS5jYXRlZ29yeTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmRhdGFbal0gPSAkcm9vdC5lcG9jaF9wcm90by5DYXJkRGF0YS50b09iamVjdChtZXNzYWdlLmRhdGFbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ncm91cFNpemUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZ3JvdXBTaXplXCIpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmdyb3VwU2l6ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0Lmdyb3VwU2l6ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmdyb3VwU2l6ZSkgOiBtZXNzYWdlLmdyb3VwU2l6ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0Lmdyb3VwU2l6ZSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5ncm91cFNpemUpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuZ3JvdXBTaXplLmxvdyA+Pj4gMCwgbWVzc2FnZS5ncm91cFNpemUuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLmdyb3VwU2l6ZTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBDYXJkRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIENhcmREZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5DYXJkRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBDYXJkRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQXhpc0RlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBBeGlzRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEF4aXNEZWYucHJvdG90eXBlLnR5cGUgPSBudWxsO1xuICAgICAgICBBeGlzRGVmLnByb3RvdHlwZS5sYWJlbCA9IG51bGw7XG4gICAgICAgIEF4aXNEZWYucHJvdG90eXBlLmNhdGVnb3JpZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc0RlZi5wcm90b3R5cGUsIFwiX3R5cGVcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1widHlwZVwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc0RlZi5wcm90b3R5cGUsIFwiX2xhYmVsXCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImxhYmVsXCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIEF4aXNEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEF4aXNEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEF4aXNEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgKS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmxhYmVsICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJsYWJlbFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLmxhYmVsKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yaWVzICE9IG51bGwgJiYgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5jYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQXhpc0RlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFiZWwgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jYXRlZ29yaWVzICYmIG1lc3NhZ2UuY2F0ZWdvcmllcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEF4aXNEZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5fdHlwZSA9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmxhYmVsICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxhYmVsXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl9sYWJlbCA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubGFiZWwpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJsYWJlbDogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcmllc1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY2F0ZWdvcmllcykpXG4gICAgICAgICAgICAgIHJldHVybiBcImNhdGVnb3JpZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY2F0ZWdvcmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmNhdGVnb3JpZXNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImNhdGVnb3JpZXM6IHN0cmluZ1tdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmKCk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkF4aXNVbnNwZWNpZmllZFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBeGlzTGluZWFyXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkF4aXNMb2dhcml0aG1pY1wiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSAyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBeGlzRGF0ZVRpbWVcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQXhpc0NhdGVnb3J5XCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmxhYmVsICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmxhYmVsID0gU3RyaW5nKG9iamVjdC5sYWJlbCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmNhdGVnb3JpZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQXhpc0RlZi5jYXRlZ29yaWVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2F0ZWdvcmllcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzW2ldID0gU3RyaW5nKG9iamVjdC5jYXRlZ29yaWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEF4aXNEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmVwb2NoX3Byb3RvLkF4aXNUeXBlW21lc3NhZ2UudHlwZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UudHlwZSA6ICRyb290LmVwb2NoX3Byb3RvLkF4aXNUeXBlW21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5fdHlwZSA9IFwidHlwZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5sYWJlbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsYWJlbFwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmxhYmVsID0gbWVzc2FnZS5sYWJlbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9sYWJlbCA9IFwibGFiZWxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcmllcyAmJiBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yaWVzW2pdID0gbWVzc2FnZS5jYXRlZ29yaWVzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBBeGlzRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEF4aXNEZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5BeGlzRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBeGlzRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uQ2hhcnREZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQ2hhcnREZWYocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLmlkID0gXCJcIjtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLnRpdGxlID0gXCJcIjtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLnR5cGUgPSAwO1xuICAgICAgICBDaGFydERlZi5wcm90b3R5cGUuY2F0ZWdvcnkgPSBcIlwiO1xuICAgICAgICBDaGFydERlZi5wcm90b3R5cGUueUF4aXMgPSBudWxsO1xuICAgICAgICBDaGFydERlZi5wcm90b3R5cGUueEF4aXMgPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhcnREZWYucHJvdG90eXBlLCBcIl95QXhpc1wiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJ5QXhpc1wiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hhcnREZWYucHJvdG90eXBlLCBcIl94QXhpc1wiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJ4QXhpc1wiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBDaGFydERlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2hhcnREZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImlkXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UuaWQpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0aXRsZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0eXBlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMjRcbiAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS50eXBlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jYXRlZ29yeSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2F0ZWdvcnlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAzNFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5jYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueUF4aXMgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInlBeGlzXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi5lbmNvZGUobWVzc2FnZS55QXhpcywgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNDJcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS54QXhpcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwieEF4aXNcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmLmVuY29kZShtZXNzYWdlLnhBeGlzLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICA1MFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0RGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55QXhpcyA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnhBeGlzID0gJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydERlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmlkKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaWQ6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aXRsZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRpdGxlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGl0bGU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS50eXBlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpXG4gICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcInR5cGU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcnkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjYXRlZ29yeTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnlBeGlzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlBeGlzXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl95QXhpcyA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYudmVyaWZ5KG1lc3NhZ2UueUF4aXMpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwieUF4aXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueEF4aXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieEF4aXNcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX3hBeGlzID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi52ZXJpZnkobWVzc2FnZS54QXhpcyk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ4QXhpcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QuaWQgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSBTdHJpbmcob2JqZWN0LmlkKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnRpdGxlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gU3RyaW5nKG9iamVjdC50aXRsZSk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QudHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IG9iamVjdC50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFVuc3BlY2lmaWVkXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENhcmRcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0TGluZXNcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QmFyXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldERhdGFUYWJsZVwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRYUmFuZ2VcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0SGlzdG9ncmFtXCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldFBpZVwiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXaWRnZXRIZWF0TWFwXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IDg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldEJveFBsb3RcIjpcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gOTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV2lkZ2V0QXJlYVwiOlxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldpZGdldENvbHVtblwiOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmNhdGVnb3J5ICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3J5ID0gU3RyaW5nKG9iamVjdC5jYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKG9iamVjdC55QXhpcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC55QXhpcyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnlBeGlzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnlBeGlzID0gJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi5mcm9tT2JqZWN0KG9iamVjdC55QXhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueEF4aXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QueEF4aXMgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5DaGFydERlZi54QXhpczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS54QXhpcyA9ICRyb290LmVwb2NoX3Byb3RvLkF4aXNEZWYuZnJvbU9iamVjdChvYmplY3QueEF4aXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LmlkID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC50aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QudHlwZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiV2lkZ2V0VW5zcGVjaWZpZWRcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnkgPSBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSlcbiAgICAgICAgICAgIG9iamVjdC5pZCA9IG1lc3NhZ2UuaWQ7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGl0bGVcIikpXG4gICAgICAgICAgICBvYmplY3QudGl0bGUgPSBtZXNzYWdlLnRpdGxlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnR5cGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidHlwZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC50eXBlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuZXBvY2hfcHJvdG8uRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldFttZXNzYWdlLnR5cGVdID09PSB2b2lkIDAgPyBtZXNzYWdlLnR5cGUgOiAkcm9vdC5lcG9jaF9wcm90by5FcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0W21lc3NhZ2UudHlwZV0gOiBtZXNzYWdlLnR5cGU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlcIikpXG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnkgPSBtZXNzYWdlLmNhdGVnb3J5O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnlBeGlzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlBeGlzXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QueUF4aXMgPSAkcm9vdC5lcG9jaF9wcm90by5BeGlzRGVmLnRvT2JqZWN0KG1lc3NhZ2UueUF4aXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX3lBeGlzID0gXCJ5QXhpc1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS54QXhpcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4QXhpc1wiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnhBeGlzID0gJHJvb3QuZXBvY2hfcHJvdG8uQXhpc0RlZi50b09iamVjdChtZXNzYWdlLnhBeGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll94QXhpcyA9IFwieEF4aXNcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnREZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5DaGFydERlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQ2hhcnREZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyYWlnaHRMaW5lRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5wcm90b3R5cGUudGl0bGUgPSBcIlwiO1xuICAgICAgICBTdHJhaWdodExpbmVEZWYucHJvdG90eXBlLnZhbHVlID0gMDtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLnByb3RvdHlwZS52ZXJ0aWNhbCA9IGZhbHNlO1xuICAgICAgICBTdHJhaWdodExpbmVEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFN0cmFpZ2h0TGluZURlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRpdGxlXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2UudGl0bGUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDE3XG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmVydGljYWxcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAyNFxuICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UudmVydGljYWwpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIFN0cmFpZ2h0TGluZURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVydGljYWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0aXRsZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRpdGxlKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwidGl0bGU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnZhbHVlICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnRpY2FsICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZlcnRpY2FsXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudmVydGljYWwgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbDogYm9vbGVhbiBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QudGl0bGUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSBTdHJpbmcob2JqZWN0LnRpdGxlKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gTnVtYmVyKG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC52ZXJ0aWNhbCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS52ZXJ0aWNhbCA9IEJvb2xlYW4ob2JqZWN0LnZlcnRpY2FsKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC50aXRsZSA9IFwiXCI7XG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSAwO1xuICAgICAgICAgICAgb2JqZWN0LnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRpdGxlXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnRpdGxlID0gbWVzc2FnZS50aXRsZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS52YWx1ZSkgPyBTdHJpbmcobWVzc2FnZS52YWx1ZSkgOiBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnRpY2FsICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZlcnRpY2FsXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnZlcnRpY2FsID0gbWVzc2FnZS52ZXJ0aWNhbDtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBTdHJhaWdodExpbmVEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyYWlnaHRMaW5lRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBTdHJhaWdodExpbmVEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5CYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEJhbmQocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQmFuZC5wcm90b3R5cGUuZnJvbSA9IG51bGw7XG4gICAgICAgIEJhbmQucHJvdG90eXBlLnRvID0gbnVsbDtcbiAgICAgICAgQmFuZC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQmFuZChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmZyb20gIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImZyb21cIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZW5jb2RlKG1lc3NhZ2UuZnJvbSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS50byAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidG9cIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZW5jb2RlKG1lc3NhZ2UudG8sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5CYW5kKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZyb20gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRvID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCYW5kLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnJvbSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmcm9tXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIudmVyaWZ5KG1lc3NhZ2UuZnJvbSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImZyb20uXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG8gIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidG9cIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci52ZXJpZnkobWVzc2FnZS50byk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcInRvLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBCYW5kLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5CYW5kKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5CYW5kKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZyb20gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5CYW5kLmZyb206IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuZnJvbSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci5mcm9tT2JqZWN0KG9iamVjdC5mcm9tKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC50byAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJhbmQudG86IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UudG8gPSAkcm9vdC5lcG9jaF9wcm90by5TY2FsYXIuZnJvbU9iamVjdChvYmplY3QudG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuZnJvbSA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QudG8gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5mcm9tICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImZyb21cIikpXG4gICAgICAgICAgICBvYmplY3QuZnJvbSA9ICRyb290LmVwb2NoX3Byb3RvLlNjYWxhci50b09iamVjdChtZXNzYWdlLmZyb20sIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRvXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnRvID0gJHJvb3QuZXBvY2hfcHJvdG8uU2NhbGFyLnRvT2JqZWN0KG1lc3NhZ2UudG8sIG9wdGlvbnMpO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJhbmQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFuZC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJhbmRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJhbmQ7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Qb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBQb2ludChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQb2ludC5wcm90b3R5cGUueCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIGZhbHNlKSA6IDA7XG4gICAgICAgIFBvaW50LnByb3RvdHlwZS55ID0gMDtcbiAgICAgICAgUG9pbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBQb2ludC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInhcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UueCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwieVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDE3XG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnkpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFBvaW50LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Qb2ludCgpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBQb2ludC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLngpICYmICEobWVzc2FnZS54ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLngubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54LmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwieDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieVwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnkgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInk6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Qb2ludCgpO1xuICAgICAgICAgIGlmIChvYmplY3QueCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC54KSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gcGFyc2VJbnQob2JqZWN0LngsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gb2JqZWN0Lng7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LnggPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QueC5sb3cgPj4+IDAsIG9iamVjdC54LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS55ID0gTnVtYmVyKG9iamVjdC55KTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgIG9iamVjdC54ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIG9iamVjdC55ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4XCIpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnggPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC54ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UueCkgOiBtZXNzYWdlLng7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC54ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLngpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UueC5sb3cgPj4+IDAsIG1lc3NhZ2UueC5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS54O1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieVwiKSlcbiAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLnkpID8gU3RyaW5nKG1lc3NhZ2UueSkgOiBtZXNzYWdlLnk7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgUG9pbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5Qb2ludFwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9pbnQ7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5MaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpbmUocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgTGluZS5wcm90b3R5cGUuZGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIExpbmUucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5kYXNoU3R5bGUgPSBudWxsO1xuICAgICAgICBMaW5lLnByb3RvdHlwZS5saW5lV2lkdGggPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGluZS5wcm90b3R5cGUsIFwiX2Rhc2hTdHlsZVwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJkYXNoU3R5bGVcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmUucHJvdG90eXBlLCBcIl9saW5lV2lkdGhcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wibGluZVdpZHRoXCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIExpbmUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExpbmUocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Qb2ludC5lbmNvZGUobWVzc2FnZS5kYXRhW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXNoU3R5bGUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImRhc2hTdHlsZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDI0XG4gICAgICAgICAgICApLmludDMyKG1lc3NhZ2UuZGFzaFN0eWxlKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lV2lkdGggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImxpbmVXaWR0aFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDMyXG4gICAgICAgICAgICApLnVpbnQzMihtZXNzYWdlLmxpbmVXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5MaW5lKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEucHVzaCgkcm9vdC5lcG9jaF9wcm90by5Qb2ludC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVXaWR0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuZGF0YSkpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGE6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5Qb2ludC52ZXJpZnkobWVzc2FnZS5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXNoU3R5bGUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGFzaFN0eWxlXCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl9kYXNoU3R5bGUgPSAxO1xuICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmRhc2hTdHlsZSkge1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBcImRhc2hTdHlsZTogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVXaWR0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaW5lV2lkdGhcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX2xpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmxpbmVXaWR0aCkpXG4gICAgICAgICAgICAgIHJldHVybiBcImxpbmVXaWR0aDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uTGluZSlcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uTGluZSgpO1xuICAgICAgICAgIGlmIChvYmplY3QuZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5kYXRhKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmUuZGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGF0YVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uTGluZS5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YVtpXSA9ICRyb290LmVwb2NoX3Byb3RvLlBvaW50LmZyb21PYmplY3Qob2JqZWN0LmRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgc3dpdGNoIChvYmplY3QuZGFzaFN0eWxlKSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5kYXNoU3R5bGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IG9iamVjdC5kYXNoU3R5bGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRGFzaFN0eWxlVW5zcGVjaWZpZWRcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTb2xpZFwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNob3J0RGFzaFwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNob3J0RG90XCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU2hvcnREYXNoRG90XCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU2hvcnREYXNoRG90RG90XCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRG90XCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRGFzaFwiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxvbmdEYXNoXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaFN0eWxlID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRGFzaERvdFwiOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkxvbmdEYXNoRG90XCI6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBtZXNzYWdlLmRhc2hTdHlsZSA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMb25nRGFzaERvdERvdFwiOlxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoU3R5bGUgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QubGluZVdpZHRoICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmxpbmVXaWR0aCA9IG9iamVjdC5saW5lV2lkdGggPj4+IDA7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QubmFtZSA9IFwiXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAmJiBtZXNzYWdlLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5kYXRhW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uUG9pbnQudG9PYmplY3QobWVzc2FnZS5kYXRhW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGFzaFN0eWxlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhc2hTdHlsZVwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmRhc2hTdHlsZSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmVwb2NoX3Byb3RvLkRhc2hTdHlsZVttZXNzYWdlLmRhc2hTdHlsZV0gPT09IHZvaWQgMCA/IG1lc3NhZ2UuZGFzaFN0eWxlIDogJHJvb3QuZXBvY2hfcHJvdG8uRGFzaFN0eWxlW21lc3NhZ2UuZGFzaFN0eWxlXSA6IG1lc3NhZ2UuZGFzaFN0eWxlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX2Rhc2hTdHlsZSA9IFwiZGFzaFN0eWxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVXaWR0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaW5lV2lkdGhcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5saW5lV2lkdGggPSBtZXNzYWdlLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0Ll9saW5lV2lkdGggPSBcImxpbmVXaWR0aFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBMaW5lLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIExpbmUuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5MaW5lXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBMaW5lO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uTGluZXNEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gTGluZXNEZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMubGluZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnlQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICB0aGlzLnhQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS5saW5lcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS5zdHJhaWdodExpbmVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgTGluZXNEZWYucHJvdG90eXBlLnlQbG90QmFuZHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuICAgICAgICBMaW5lc0RlZi5wcm90b3R5cGUueFBsb3RCYW5kcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIExpbmVzRGVmLnByb3RvdHlwZS5vdmVybGF5ID0gbnVsbDtcbiAgICAgICAgTGluZXNEZWYucHJvdG90eXBlLnN0YWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KExpbmVzRGVmLnByb3RvdHlwZSwgXCJfb3ZlcmxheVwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJvdmVybGF5XCJdKSxcbiAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG4gICAgICAgIExpbmVzRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5lbmNvZGUobWVzc2FnZS5jaGFydERlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lcyAhPSBudWxsICYmIG1lc3NhZ2UubGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5MaW5lLmVuY29kZShtZXNzYWdlLmxpbmVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmFpZ2h0TGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5lbmNvZGUobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnlQbG90QmFuZHMgIT0gbnVsbCAmJiBtZXNzYWdlLnlQbG90QmFuZHMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnlQbG90QmFuZHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkJhbmQuZW5jb2RlKG1lc3NhZ2UueVBsb3RCYW5kc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDM0XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS54UGxvdEJhbmRzICE9IG51bGwgJiYgbWVzc2FnZS54UGxvdEJhbmRzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS54UGxvdEJhbmRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5CYW5kLmVuY29kZShtZXNzYWdlLnhQbG90QmFuZHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICA0MlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uub3ZlcmxheSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwib3ZlcmxheVwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkxpbmUuZW5jb2RlKG1lc3NhZ2Uub3ZlcmxheSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdGFja2VkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzdGFja2VkXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNywgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgNTZcbiAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLnN0YWNrZWQpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5MaW5lc0RlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5saW5lcyAmJiBtZXNzYWdlLmxpbmVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkxpbmUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJhaWdodExpbmVzICYmIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UueVBsb3RCYW5kcyAmJiBtZXNzYWdlLnlQbG90QmFuZHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UueVBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueVBsb3RCYW5kcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkJhbmQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS54UGxvdEJhbmRzICYmIG1lc3NhZ2UueFBsb3RCYW5kcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS54UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS54UGxvdEJhbmRzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uQmFuZC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm92ZXJsYXkgPSAkcm9vdC5lcG9jaF9wcm90by5MaW5lLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5zdGFja2VkID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIExpbmVzRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGluZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmxpbmVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwibGluZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS52ZXJpZnkobWVzc2FnZS5saW5lc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJsaW5lcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJhaWdodExpbmVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmFpZ2h0TGluZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmFpZ2h0TGluZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJhaWdodExpbmVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLnZlcmlmeShtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyYWlnaHRMaW5lcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55UGxvdEJhbmRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlQbG90QmFuZHNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnlQbG90QmFuZHMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ5UGxvdEJhbmRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnlQbG90QmFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQmFuZC52ZXJpZnkobWVzc2FnZS55UGxvdEJhbmRzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInlQbG90QmFuZHMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFBsb3RCYW5kcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4UGxvdEJhbmRzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS54UGxvdEJhbmRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwieFBsb3RCYW5kczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS54UGxvdEJhbmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQudmVyaWZ5KG1lc3NhZ2UueFBsb3RCYW5kc1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ4UGxvdEJhbmRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm92ZXJsYXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3ZlcmxheVwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5fb3ZlcmxheSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkxpbmUudmVyaWZ5KG1lc3NhZ2Uub3ZlcmxheSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvdmVybGF5LlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnN0YWNrZWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RhY2tlZFwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnN0YWNrZWQgIT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJzdGFja2VkOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lc0RlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkxpbmVzRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLmNoYXJ0RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZnJvbU9iamVjdChvYmplY3QuY2hhcnREZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmxpbmVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLmxpbmVzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UubGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmxpbmVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5saW5lczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS5mcm9tT2JqZWN0KG9iamVjdC5saW5lc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3Quc3RyYWlnaHRMaW5lcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLnN0cmFpZ2h0TGluZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmFpZ2h0TGluZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLnN0cmFpZ2h0TGluZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLmZyb21PYmplY3Qob2JqZWN0LnN0cmFpZ2h0TGluZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnlQbG90QmFuZHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QueVBsb3RCYW5kcykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi55UGxvdEJhbmRzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UueVBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QueVBsb3RCYW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC55UGxvdEJhbmRzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi55UGxvdEJhbmRzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UueVBsb3RCYW5kc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQuZnJvbU9iamVjdChvYmplY3QueVBsb3RCYW5kc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueFBsb3RCYW5kcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC54UGxvdEJhbmRzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLnhQbG90QmFuZHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS54UGxvdEJhbmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC54UGxvdEJhbmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnhQbG90QmFuZHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkxpbmVzRGVmLnhQbG90QmFuZHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS54UGxvdEJhbmRzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uQmFuZC5mcm9tT2JqZWN0KG9iamVjdC54UGxvdEJhbmRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5vdmVybGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm92ZXJsYXkgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5MaW5lc0RlZi5vdmVybGF5OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLm92ZXJsYXkgPSAkcm9vdC5lcG9jaF9wcm90by5MaW5lLmZyb21PYmplY3Qob2JqZWN0Lm92ZXJsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnN0YWNrZWQgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2Uuc3RhY2tlZCA9IEJvb2xlYW4ob2JqZWN0LnN0YWNrZWQpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBMaW5lc0RlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QubGluZXMgPSBbXTtcbiAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICBvYmplY3QueVBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgb2JqZWN0LnhQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3Quc3RhY2tlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnRvT2JqZWN0KG1lc3NhZ2UuY2hhcnREZWYsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmxpbmVzICYmIG1lc3NhZ2UubGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QubGluZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5saW5lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmxpbmVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS50b09iamVjdChtZXNzYWdlLmxpbmVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLnRvT2JqZWN0KG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnlQbG90QmFuZHMgJiYgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnlQbG90QmFuZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS55UGxvdEJhbmRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QueVBsb3RCYW5kc1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLkJhbmQudG9PYmplY3QobWVzc2FnZS55UGxvdEJhbmRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFBsb3RCYW5kcyAmJiBtZXNzYWdlLnhQbG90QmFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QueFBsb3RCYW5kcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnhQbG90QmFuZHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC54UGxvdEJhbmRzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uQmFuZC50b09iamVjdChtZXNzYWdlLnhQbG90QmFuZHNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5vdmVybGF5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm92ZXJsYXlcIikpIHtcbiAgICAgICAgICAgIG9iamVjdC5vdmVybGF5ID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZS50b09iamVjdChtZXNzYWdlLm92ZXJsYXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX292ZXJsYXkgPSBcIm92ZXJsYXlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhY2tlZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdGFja2VkXCIpKVxuICAgICAgICAgICAgb2JqZWN0LnN0YWNrZWQgPSBtZXNzYWdlLnN0YWNrZWQ7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGluZXNEZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5MaW5lc0RlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGluZXNEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5IZWF0TWFwUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gSGVhdE1hcFBvaW50KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlYXRNYXBQb2ludC5wcm90b3R5cGUueCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgICAgICAgSGVhdE1hcFBvaW50LnByb3RvdHlwZS55ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgdHJ1ZSkgOiAwO1xuICAgICAgICBIZWF0TWFwUG9pbnQucHJvdG90eXBlLnZhbHVlID0gMDtcbiAgICAgICAgSGVhdE1hcFBvaW50LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBIZWF0TWFwUG9pbnQocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInhcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLnVpbnQ2NChtZXNzYWdlLngpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAxNlxuICAgICAgICAgICAgKS51aW50NjQobWVzc2FnZS55KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidmFsdWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAyNVxuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50KCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnggPSByZWFkZXIudWludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwUG9pbnQuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwUG9pbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54KSAmJiAhKG1lc3NhZ2UueCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueC5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIng6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueSkgJiYgIShtZXNzYWdlLnkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnkuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS52YWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludCgpO1xuICAgICAgICAgIGlmIChvYmplY3QueCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC54KSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnggPSBwYXJzZUludChvYmplY3QueCwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnggPSBvYmplY3QueDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC54LmxvdyA+Pj4gMCwgb2JqZWN0LnguaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC55KSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC55ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnkgPSBwYXJzZUludChvYmplY3QueSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC55ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnkgPSBvYmplY3QueTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC55LmxvdyA+Pj4gMCwgb2JqZWN0LnkuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSBOdW1iZXIob2JqZWN0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcFBvaW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9iamVjdC54ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLngpIDogbWVzc2FnZS54O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS54KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLngubG93ID4+PiAwLCBtZXNzYWdlLnguaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLng7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5XCIpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UueSkgOiBtZXNzYWdlLnk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIG9iamVjdC55ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLnkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UueS5sb3cgPj4+IDAsIG1lc3NhZ2UueS5oaWdoID4+PiAwKS50b051bWJlcih0cnVlKSA6IG1lc3NhZ2UueTtcbiAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS52YWx1ZSkgPyBTdHJpbmcobWVzc2FnZS52YWx1ZSkgOiBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBQb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwUG9pbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5IZWF0TWFwUG9pbnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEhlYXRNYXBQb2ludDtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkhlYXRNYXBEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gSGVhdE1hcERlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEhlYXRNYXBEZWYucHJvdG90eXBlLmNoYXJ0RGVmID0gbnVsbDtcbiAgICAgICAgSGVhdE1hcERlZi5wcm90b3R5cGUucG9pbnRzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgSGVhdE1hcERlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgSGVhdE1hcERlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmVuY29kZShtZXNzYWdlLmNoYXJ0RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAhPSBudWxsICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludC5lbmNvZGUobWVzc2FnZS5wb2ludHNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBvaW50cyAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50cy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudmVyaWZ5KG1lc3NhZ2UuY2hhcnREZWYpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydERlZi5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicG9pbnRzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5wb2ludHMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJwb2ludHM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBQb2ludC52ZXJpZnkobWVzc2FnZS5wb2ludHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYuY2hhcnREZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5mcm9tT2JqZWN0KG9iamVjdC5jaGFydERlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QucG9pbnRzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnBvaW50cykpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5IZWF0TWFwRGVmLnBvaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBvaW50c1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uSGVhdE1hcERlZi5wb2ludHM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHNbaV0gPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwUG9pbnQuZnJvbU9iamVjdChvYmplY3QucG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEhlYXRNYXBEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5wb2ludHMgPSBbXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9IG51bGw7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi50b09iamVjdChtZXNzYWdlLmNoYXJ0RGVmLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QucG9pbnRzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uSGVhdE1hcFBvaW50LnRvT2JqZWN0KG1lc3NhZ2UucG9pbnRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgSGVhdE1hcERlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBIZWF0TWFwRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uSGVhdE1hcERlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSGVhdE1hcERlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkJhckRlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBCYXJEZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQmFyRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIEJhckRlZi5wcm90b3R5cGUuZGF0YSA9IG51bGw7XG4gICAgICAgIEJhckRlZi5wcm90b3R5cGUuc3RyYWlnaHRMaW5lcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEJhckRlZi5wcm90b3R5cGUuYmFyV2lkdGggPSBudWxsO1xuICAgICAgICBCYXJEZWYucHJvdG90eXBlLnZlcnRpY2FsID0gZmFsc2U7XG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXJEZWYucHJvdG90eXBlLCBcIl9iYXJXaWR0aFwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJiYXJXaWR0aFwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBCYXJEZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJhckRlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZW5jb2RlKG1lc3NhZ2UuY2hhcnREZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF0YVwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkFycmF5LmVuY29kZShtZXNzYWdlLmRhdGEsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAhPSBudWxsICYmIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLmVuY29kZShtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmFyV2lkdGggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJhcldpZHRoXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICkudWludDMyKG1lc3NhZ2UuYmFyV2lkdGgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZlcnRpY2FsICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2ZXJ0aWNhbFwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDQwXG4gICAgICAgICAgICApLmJvb2wobWVzc2FnZS52ZXJ0aWNhbCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQmFyRGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5BcnJheS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJhcldpZHRoID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVydGljYWwgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi52ZXJpZnkobWVzc2FnZS5jaGFydERlZik7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0RGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkudmVyaWZ5KG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJhaWdodExpbmVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5zdHJhaWdodExpbmVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwic3RyYWlnaHRMaW5lczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi52ZXJpZnkobWVzc2FnZS5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmFpZ2h0TGluZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmFyV2lkdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmFyV2lkdGhcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuX2JhcldpZHRoID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuYmFyV2lkdGgpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJiYXJXaWR0aDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJ0aWNhbFwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnZlcnRpY2FsICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWw6IGJvb2xlYW4gZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQmFyRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5CYXJEZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNoYXJ0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNoYXJ0RGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQmFyRGVmLmNoYXJ0RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZnJvbU9iamVjdChvYmplY3QuY2hhcnREZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJhckRlZi5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5BcnJheS5mcm9tT2JqZWN0KG9iamVjdC5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5zdHJhaWdodExpbmVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnN0cmFpZ2h0TGluZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQmFyRGVmLnN0cmFpZ2h0TGluZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmFpZ2h0TGluZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJhckRlZi5zdHJhaWdodExpbmVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5mcm9tT2JqZWN0KG9iamVjdC5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5iYXJXaWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5iYXJXaWR0aCA9IG9iamVjdC5iYXJXaWR0aCA+Pj4gMDtcbiAgICAgICAgICBpZiAob2JqZWN0LnZlcnRpY2FsICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnZlcnRpY2FsID0gQm9vbGVhbihvYmplY3QudmVydGljYWwpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCYXJEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QudmVydGljYWwgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi50b09iamVjdChtZXNzYWdlLmNoYXJ0RGVmLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpXG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLkFycmF5LnRvT2JqZWN0KG1lc3NhZ2UuZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAmJiBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLnRvT2JqZWN0KG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJhcldpZHRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJhcldpZHRoXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuYmFyV2lkdGggPSBtZXNzYWdlLmJhcldpZHRoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX2JhcldpZHRoID0gXCJiYXJXaWR0aFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS52ZXJ0aWNhbCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2ZXJ0aWNhbFwiKSlcbiAgICAgICAgICAgIG9iamVjdC52ZXJ0aWNhbCA9IG1lc3NhZ2UudmVydGljYWw7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQmFyRGVmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIEJhckRlZi5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJhckRlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQmFyRGVmO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIEhpc3RvZ3JhbURlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBIaXN0b2dyYW1EZWYucHJvdG90eXBlLmNoYXJ0RGVmID0gbnVsbDtcbiAgICAgICAgSGlzdG9ncmFtRGVmLnByb3RvdHlwZS5kYXRhID0gbnVsbDtcbiAgICAgICAgSGlzdG9ncmFtRGVmLnByb3RvdHlwZS5zdHJhaWdodExpbmVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLnByb3RvdHlwZS5iaW5zQ291bnQgPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSGlzdG9ncmFtRGVmLnByb3RvdHlwZSwgXCJfYmluc0NvdW50XCIsIHtcbiAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImJpbnNDb3VudFwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBIaXN0b2dyYW1EZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvZ3JhbURlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZW5jb2RlKG1lc3NhZ2UuY2hhcnREZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF0YVwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkFycmF5LmVuY29kZShtZXNzYWdlLmRhdGEsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcyAhPSBudWxsICYmIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLmVuY29kZShtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmluc0NvdW50ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJiaW5zQ291bnRcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICAzMlxuICAgICAgICAgICAgKS51aW50MzIobWVzc2FnZS5iaW5zQ291bnQpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnN0cmFpZ2h0TGluZXMgJiYgbWVzc2FnZS5zdHJhaWdodExpbmVzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmFpZ2h0TGluZXMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5iaW5zQ291bnQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5BcnJheS52ZXJpZnkobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0YS5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJhaWdodExpbmVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmFpZ2h0TGluZXNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnN0cmFpZ2h0TGluZXMpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJzdHJhaWdodExpbmVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnN0cmFpZ2h0TGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uU3RyYWlnaHRMaW5lRGVmLnZlcmlmeShtZXNzYWdlLnN0cmFpZ2h0TGluZXNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic3RyYWlnaHRMaW5lcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5iaW5zQ291bnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmluc0NvdW50XCIpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLl9iaW5zQ291bnQgPSAxO1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5iaW5zQ291bnQpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJiaW5zQ291bnQ6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNoYXJ0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNoYXJ0RGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLmNoYXJ0RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZnJvbU9iamVjdChvYmplY3QuY2hhcnREZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGF0YSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5kYXRhOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5BcnJheS5mcm9tT2JqZWN0KG9iamVjdC5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5zdHJhaWdodExpbmVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LnN0cmFpZ2h0TGluZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLnN0cmFpZ2h0TGluZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5zdHJhaWdodExpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cmFpZ2h0TGluZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5zdHJhaWdodExpbmVzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlN0cmFpZ2h0TGluZURlZi5mcm9tT2JqZWN0KG9iamVjdC5zdHJhaWdodExpbmVzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5iaW5zQ291bnQgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuYmluc0NvdW50ID0gb2JqZWN0LmJpbnNDb3VudCA+Pj4gMDtcbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgSGlzdG9ncmFtRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3Quc3RyYWlnaHRMaW5lcyA9IFtdO1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnRvT2JqZWN0KG1lc3NhZ2UuY2hhcnREZWYsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZGF0YVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gJHJvb3QuZXBvY2hfcHJvdG8uQXJyYXkudG9PYmplY3QobWVzc2FnZS5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zdHJhaWdodExpbmVzICYmIG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5zdHJhaWdodExpbmVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2Uuc3RyYWlnaHRMaW5lcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnN0cmFpZ2h0TGluZXNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5TdHJhaWdodExpbmVEZWYudG9PYmplY3QobWVzc2FnZS5zdHJhaWdodExpbmVzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmluc0NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJpbnNDb3VudFwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJpbnNDb3VudCA9IG1lc3NhZ2UuYmluc0NvdW50O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICBvYmplY3QuX2JpbnNDb3VudCA9IFwiYmluc0NvdW50XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEhpc3RvZ3JhbURlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBIaXN0b2dyYW1EZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5IaXN0b2dyYW1EZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEhpc3RvZ3JhbURlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQm94UGxvdERhdGFQb2ludChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnByb3RvdHlwZS5sb3cgPSAwO1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnByb3RvdHlwZS5xMSA9IDA7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQucHJvdG90eXBlLm1lZGlhbiA9IDA7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQucHJvdG90eXBlLnEzID0gMDtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5wcm90b3R5cGUuaGlnaCA9IDA7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJveFBsb3REYXRhUG9pbnQocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5sb3cgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImxvd1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDlcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UubG93KTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5xMSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwicTFcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAxN1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5xMSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubWVkaWFuICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJtZWRpYW5cIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAyNVxuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5tZWRpYW4pO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnEzICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJxM1wiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDMzXG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnEzKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5oaWdoICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJoaWdoXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNSwgd2lyZVR5cGUgMSA9Ki9cbiAgICAgICAgICAgICAgNDFcbiAgICAgICAgICAgICkuZG91YmxlKG1lc3NhZ2UuaGlnaCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50KCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxvdyA9IHJlYWRlci5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnExID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVkaWFuID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucTMgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oaWdoID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmxvdyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsb3dcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5sb3cgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcImxvdzogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnExICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInExXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UucTEgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInExOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubWVkaWFuICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1lZGlhblwiKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLm1lZGlhbiAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwibWVkaWFuOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucTMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicTNcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5xMyAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwicTM6IG51bWJlciBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5oaWdoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhpZ2hcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5oaWdoICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJoaWdoOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnQoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmxvdyAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5sb3cgPSBOdW1iZXIob2JqZWN0Lmxvdyk7XG4gICAgICAgICAgaWYgKG9iamVjdC5xMSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5xMSA9IE51bWJlcihvYmplY3QucTEpO1xuICAgICAgICAgIGlmIChvYmplY3QubWVkaWFuICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLm1lZGlhbiA9IE51bWJlcihvYmplY3QubWVkaWFuKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnEzICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnEzID0gTnVtYmVyKG9iamVjdC5xMyk7XG4gICAgICAgICAgaWYgKG9iamVjdC5oaWdoICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmhpZ2ggPSBOdW1iZXIob2JqZWN0LmhpZ2gpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5sb3cgPSAwO1xuICAgICAgICAgICAgb2JqZWN0LnExID0gMDtcbiAgICAgICAgICAgIG9iamVjdC5tZWRpYW4gPSAwO1xuICAgICAgICAgICAgb2JqZWN0LnEzID0gMDtcbiAgICAgICAgICAgIG9iamVjdC5oaWdoID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubG93ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxvd1wiKSlcbiAgICAgICAgICAgIG9iamVjdC5sb3cgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UubG93KSA/IFN0cmluZyhtZXNzYWdlLmxvdykgOiBtZXNzYWdlLmxvdztcbiAgICAgICAgICBpZiAobWVzc2FnZS5xMSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJxMVwiKSlcbiAgICAgICAgICAgIG9iamVjdC5xMSA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5xMSkgPyBTdHJpbmcobWVzc2FnZS5xMSkgOiBtZXNzYWdlLnExO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm1lZGlhbiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtZWRpYW5cIikpXG4gICAgICAgICAgICBvYmplY3QubWVkaWFuID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLm1lZGlhbikgPyBTdHJpbmcobWVzc2FnZS5tZWRpYW4pIDogbWVzc2FnZS5tZWRpYW47XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucTMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicTNcIikpXG4gICAgICAgICAgICBvYmplY3QucTMgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UucTMpID8gU3RyaW5nKG1lc3NhZ2UucTMpIDogbWVzc2FnZS5xMztcbiAgICAgICAgICBpZiAobWVzc2FnZS5oaWdoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhpZ2hcIikpXG4gICAgICAgICAgICBvYmplY3QuaGlnaCA9IG9wdGlvbnMuanNvbiAmJiAhaXNGaW5pdGUobWVzc2FnZS5oaWdoKSA/IFN0cmluZyhtZXNzYWdlLmhpZ2gpIDogbWVzc2FnZS5oaWdoO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludC5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJveFBsb3REYXRhUG9pbnQ7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5Cb3hQbG90T3V0bGllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBCb3hQbG90T3V0bGllcihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBCb3hQbG90T3V0bGllci5wcm90b3R5cGUuY2F0ZWdvcnlJbmRleCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsIDAsIHRydWUpIDogMDtcbiAgICAgICAgQm94UGxvdE91dGxpZXIucHJvdG90eXBlLnZhbHVlID0gMDtcbiAgICAgICAgQm94UGxvdE91dGxpZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJveFBsb3RPdXRsaWVyKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5SW5kZXggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNhdGVnb3J5SW5kZXhcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLnVpbnQ2NChtZXNzYWdlLmNhdGVnb3J5SW5kZXgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgIDE3XG4gICAgICAgICAgICApLmRvdWJsZShtZXNzYWdlLnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCA9IHJlYWRlci51aW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdE91dGxpZXIuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yeUluZGV4XCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmNhdGVnb3J5SW5kZXgpICYmICEobWVzc2FnZS5jYXRlZ29yeUluZGV4ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLmNhdGVnb3J5SW5kZXgubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5jYXRlZ29yeUluZGV4LmhpZ2gpKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcnlJbmRleDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UudmFsdWUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90T3V0bGllcilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNhdGVnb3J5SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgIChtZXNzYWdlLmNhdGVnb3J5SW5kZXggPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuY2F0ZWdvcnlJbmRleCkpLnVuc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuY2F0ZWdvcnlJbmRleCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yeUluZGV4ID0gcGFyc2VJbnQob2JqZWN0LmNhdGVnb3J5SW5kZXgsIDEwKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuY2F0ZWdvcnlJbmRleCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yeUluZGV4ID0gb2JqZWN0LmNhdGVnb3J5SW5kZXg7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LmNhdGVnb3J5SW5kZXggPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcnlJbmRleCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuY2F0ZWdvcnlJbmRleC5sb3cgPj4+IDAsIG9iamVjdC5jYXRlZ29yeUluZGV4LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gTnVtYmVyKG9iamVjdC52YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3RPdXRsaWVyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yeUluZGV4ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnlJbmRleCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3J5SW5kZXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlJbmRleFwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jYXRlZ29yeUluZGV4ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnlJbmRleCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLmNhdGVnb3J5SW5kZXgpIDogbWVzc2FnZS5jYXRlZ29yeUluZGV4O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QuY2F0ZWdvcnlJbmRleCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5jYXRlZ29yeUluZGV4KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLmNhdGVnb3J5SW5kZXgubG93ID4+PiAwLCBtZXNzYWdlLmNhdGVnb3J5SW5kZXguaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSkgOiBtZXNzYWdlLmNhdGVnb3J5SW5kZXg7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidmFsdWVcIikpXG4gICAgICAgICAgICBvYmplY3QudmFsdWUgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UudmFsdWUpID8gU3RyaW5nKG1lc3NhZ2UudmFsdWUpIDogbWVzc2FnZS52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90T3V0bGllci5nZXRUeXBlVXJsID0gZnVuY3Rpb24gZ2V0VHlwZVVybCh0eXBlVXJsUHJlZml4KSB7XG4gICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2Vwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBCb3hQbG90T3V0bGllcjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQm94UGxvdERhdGFQb2ludERlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy5vdXRsaWVycyA9IFtdO1xuICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLnByb3RvdHlwZS5vdXRsaWVycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYucHJvdG90eXBlLnBvaW50cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEJveFBsb3REYXRhUG9pbnREZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5vdXRsaWVycyAhPSBudWxsICYmIG1lc3NhZ2Uub3V0bGllcnMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLm91dGxpZXJzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90T3V0bGllci5lbmNvZGUobWVzc2FnZS5vdXRsaWVyc1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50LmVuY29kZShtZXNzYWdlLnBvaW50c1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub3V0bGllcnMgJiYgbWVzc2FnZS5vdXRsaWVycy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRsaWVycyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0bGllcnMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90T3V0bGllci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBvaW50cyAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50cy5wdXNoKCRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2Uub3V0bGllcnMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwib3V0bGllcnNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLm91dGxpZXJzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwib3V0bGllcnM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2Uub3V0bGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIudmVyaWZ5KG1lc3NhZ2Uub3V0bGllcnNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib3V0bGllcnMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBvaW50c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucG9pbnRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50LnZlcmlmeShtZXNzYWdlLnBvaW50c1tpXSk7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwb2ludHMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0Lm91dGxpZXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lm91dGxpZXJzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYub3V0bGllcnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5vdXRsaWVycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3Qub3V0bGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qub3V0bGllcnNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYub3V0bGllcnM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5vdXRsaWVyc1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3RPdXRsaWVyLmZyb21PYmplY3Qob2JqZWN0Lm91dGxpZXJzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5wb2ludHMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucG9pbnRzKSlcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYucG9pbnRzOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucG9pbnRzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLnBvaW50czogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50c1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnQuZnJvbU9iamVjdChvYmplY3QucG9pbnRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REYXRhUG9pbnREZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0Lm91dGxpZXJzID0gW107XG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLm91dGxpZXJzICYmIG1lc3NhZ2Uub3V0bGllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3Qub3V0bGllcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5vdXRsaWVycy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0Lm91dGxpZXJzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdE91dGxpZXIudG9PYmplY3QobWVzc2FnZS5vdXRsaWVyc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5wb2ludHNbal0gPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50LnRvT2JqZWN0KG1lc3NhZ2UucG9pbnRzW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERhdGFQb2ludERlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGF0YVBvaW50RGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQm94UGxvdERhdGFQb2ludERlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQm94UGxvdERhdGFQb2ludERlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkJveFBsb3REZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gQm94UGxvdERlZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBCb3hQbG90RGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIEJveFBsb3REZWYucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuICAgICAgICBCb3hQbG90RGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb3hQbG90RGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZW5jb2RlKG1lc3NhZ2UuY2hhcnREZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZGF0YVwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYuZW5jb2RlKG1lc3NhZ2UuZGF0YSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REZWYuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudmVyaWZ5KG1lc3NhZ2UuY2hhcnREZWYpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydERlZi5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYudmVyaWZ5KG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIEJveFBsb3REZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNoYXJ0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNoYXJ0RGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQm94UGxvdERlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmRhdGEgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5Cb3hQbG90RGVmLmRhdGE6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REYXRhUG9pbnREZWYuZnJvbU9iamVjdChvYmplY3QuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9IG51bGw7XG4gICAgICAgICAgICBvYmplY3QuZGF0YSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudG9PYmplY3QobWVzc2FnZS5jaGFydERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJkYXRhXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGF0YVBvaW50RGVmLnRvT2JqZWN0KG1lc3NhZ2UuZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgQm94UGxvdERlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBCb3hQbG90RGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQm94UGxvdERlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gQm94UGxvdERlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlhSYW5nZVBvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhSYW5nZVBvaW50KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFhSYW5nZVBvaW50LnByb3RvdHlwZS54ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcbiAgICAgICAgWFJhbmdlUG9pbnQucHJvdG90eXBlLngyID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwgMCwgZmFsc2UpIDogMDtcbiAgICAgICAgWFJhbmdlUG9pbnQucHJvdG90eXBlLnkgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLCAwLCB0cnVlKSA6IDA7XG4gICAgICAgIFhSYW5nZVBvaW50LnByb3RvdHlwZS5pc0xvbmcgPSBmYWxzZTtcbiAgICAgICAgWFJhbmdlUG9pbnQuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFhSYW5nZVBvaW50KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VQb2ludC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInhcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAwID0qL1xuICAgICAgICAgICAgICA4XG4gICAgICAgICAgICApLmludDY0KG1lc3NhZ2UueCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueDIgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIngyXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMTZcbiAgICAgICAgICAgICkuaW50NjQobWVzc2FnZS54Mik7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwieVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgIDI0XG4gICAgICAgICAgICApLnVpbnQ2NChtZXNzYWdlLnkpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmlzTG9uZyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaXNMb25nXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICkuYm9vbChtZXNzYWdlLmlzTG9uZyk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VQb2ludC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50KCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnggPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLngyID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS55ID0gcmVhZGVyLnVpbnQ2NCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaXNMb25nID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54KSAmJiAhKG1lc3NhZ2UueCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueC5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIng6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS54MiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4MlwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS54MikgJiYgIShtZXNzYWdlLngyICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLngyLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueDIuaGlnaCkpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ4MjogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS55KSAmJiAhKG1lc3NhZ2UueSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS55LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UueS5oaWdoKSkpXG4gICAgICAgICAgICAgIHJldHVybiBcInk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5pc0xvbmcgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaXNMb25nXCIpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuaXNMb25nICE9PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiaXNMb25nOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VQb2ludC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC54ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAobWVzc2FnZS54ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LngpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnggPSBwYXJzZUludChvYmplY3QueCwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnggPSBvYmplY3QueDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC54LmxvdyA+Pj4gMCwgb2JqZWN0LnguaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC54MiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueDIgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QueDIpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54MiA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54MiA9IHBhcnNlSW50KG9iamVjdC54MiwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC54MiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS54MiA9IG9iamVjdC54MjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueDIgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgIG1lc3NhZ2UueDIgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LngyLmxvdyA+Pj4gMCwgb2JqZWN0LngyLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgKG1lc3NhZ2UueSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC55KSkudW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC55ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnkgPSBwYXJzZUludChvYmplY3QueSwgMTApO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC55ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBtZXNzYWdlLnkgPSBvYmplY3QueTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QueSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgbWVzc2FnZS55ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC55LmxvdyA+Pj4gMCwgb2JqZWN0LnkuaGlnaCA+Pj4gMCkudG9OdW1iZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuaXNMb25nICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLmlzTG9uZyA9IEJvb2xlYW4ob2JqZWN0LmlzTG9uZyk7XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZVBvaW50LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnggPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgb2JqZWN0LngyID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueDIgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIHRydWUpO1xuICAgICAgICAgICAgICBvYmplY3QueSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICBvYmplY3QuaXNMb25nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwieFwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS54ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLngpIDogbWVzc2FnZS54O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBvYmplY3QueCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS54KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLngubG93ID4+PiAwLCBtZXNzYWdlLnguaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UueDtcbiAgICAgICAgICBpZiAobWVzc2FnZS54MiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ4MlwiKSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS54MiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LngyID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UueDIpIDogbWVzc2FnZS54MjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LngyID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLngyKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLngyLmxvdyA+Pj4gMCwgbWVzc2FnZS54Mi5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS54MjtcbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UueSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS55KSA6IG1lc3NhZ2UueTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UueSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS55LmxvdyA+Pj4gMCwgbWVzc2FnZS55LmhpZ2ggPj4+IDApLnRvTnVtYmVyKHRydWUpIDogbWVzc2FnZS55O1xuICAgICAgICAgIGlmIChtZXNzYWdlLmlzTG9uZyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpc0xvbmdcIikpXG4gICAgICAgICAgICBvYmplY3QuaXNMb25nID0gbWVzc2FnZS5pc0xvbmc7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlUG9pbnQuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5YUmFuZ2VQb2ludFwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gWFJhbmdlUG9pbnQ7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5YUmFuZ2VEZWYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZnVuY3Rpb24gWFJhbmdlRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgWFJhbmdlRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIFhSYW5nZURlZi5wcm90b3R5cGUuY2F0ZWdvcmllcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFhSYW5nZURlZi5wcm90b3R5cGUucG9pbnRzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgWFJhbmdlRGVmLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBYUmFuZ2VEZWYocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZURlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJjaGFydERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmVuY29kZShtZXNzYWdlLmNoYXJ0RGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNhdGVnb3JpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLmNhdGVnb3JpZXNbaV0pO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAhPSBudWxsICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50LmVuY29kZShtZXNzYWdlLnBvaW50c1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAzLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoLCBlcnJvcikge1xuICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB2b2lkIDAgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2F0ZWdvcmllcyAmJiBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2F0ZWdvcmllcy5wdXNoKHJlYWRlci5zdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzID0gW107XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMucHVzaCgkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZURlZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG4gICAgICAgIFhSYW5nZURlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLnZlcmlmeShtZXNzYWdlLmNoYXJ0RGVmKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnREZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcmllcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjYXRlZ29yaWVzXCIpKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5jYXRlZ29yaWVzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcmllczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5jYXRlZ29yaWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuY2F0ZWdvcmllc1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiY2F0ZWdvcmllczogc3RyaW5nW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInBvaW50c1wiKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucG9pbnRzKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VQb2ludC52ZXJpZnkobWVzc2FnZS5wb2ludHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZURlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmKCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5jaGFydERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5jaGFydERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlhSYW5nZURlZi5jaGFydERlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jaGFydERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0RGVmLmZyb21PYmplY3Qob2JqZWN0LmNoYXJ0RGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5jYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmNhdGVnb3JpZXMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLmNhdGVnb3JpZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5jYXRlZ29yaWVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5jYXRlZ29yaWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICBtZXNzYWdlLmNhdGVnb3JpZXNbaV0gPSBTdHJpbmcob2JqZWN0LmNhdGVnb3JpZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5wb2ludHMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLnBvaW50czogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QucG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBvaW50c1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLnBvaW50czogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50c1tpXSA9ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZVBvaW50LmZyb21PYmplY3Qob2JqZWN0LnBvaW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgb2JqZWN0LmNhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgIG9iamVjdC5wb2ludHMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSBudWxsO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmNoYXJ0RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoYXJ0RGVmXCIpKVxuICAgICAgICAgICAgb2JqZWN0LmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudG9PYmplY3QobWVzc2FnZS5jaGFydERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2F0ZWdvcmllcyAmJiBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QuY2F0ZWdvcmllcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmNhdGVnb3JpZXMubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgIG9iamVjdC5jYXRlZ29yaWVzW2pdID0gbWVzc2FnZS5jYXRlZ29yaWVzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgJiYgbWVzc2FnZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICBvYmplY3QucG9pbnRzW2pdID0gJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlUG9pbnQudG9PYmplY3QobWVzc2FnZS5wb2ludHNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBYUmFuZ2VEZWYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgWFJhbmdlRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uWFJhbmdlRGVmXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBYUmFuZ2VEZWY7XG4gICAgICB9KCk7XG4gICAgICBlcG9jaF9wcm90by5QaWVEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBpZURhdGEocHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGllRGF0YS5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgIFBpZURhdGEucHJvdG90eXBlLnkgPSAwO1xuICAgICAgICBQaWVEYXRhLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQaWVEYXRhKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibmFtZVwiKSlcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLm5hbWUpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInlcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAxID0qL1xuICAgICAgICAgICAgICAxN1xuICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS55KTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnkgPSByZWFkZXIuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKSB7XG4gICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UubmFtZSkpXG4gICAgICAgICAgICAgIHJldHVybiBcIm5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS55ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInlcIikpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS55ICE9PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICByZXR1cm4gXCJ5OiBudW1iZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGEuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEoKTtcbiAgICAgICAgICBpZiAob2JqZWN0Lm5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IFN0cmluZyhvYmplY3QubmFtZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC55ICE9IG51bGwpXG4gICAgICAgICAgICBtZXNzYWdlLnkgPSBOdW1iZXIob2JqZWN0LnkpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC55ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ5XCIpKVxuICAgICAgICAgICAgb2JqZWN0LnkgPSBvcHRpb25zLmpzb24gJiYgIWlzRmluaXRlKG1lc3NhZ2UueSkgPyBTdHJpbmcobWVzc2FnZS55KSA6IG1lc3NhZ2UueTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGEuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5QaWVEYXRhXCI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBQaWVEYXRhO1xuICAgICAgfSgpO1xuICAgICAgZXBvY2hfcHJvdG8uUGllRGF0YURlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBQaWVEYXRhRGVmKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGllRGF0YURlZi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG4gICAgICAgIFBpZURhdGFEZWYucHJvdG90eXBlLnBvaW50cyA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFBpZURhdGFEZWYucHJvdG90eXBlLnNpemUgPSBcIlwiO1xuICAgICAgICBQaWVEYXRhRGVmLnByb3RvdHlwZS5pbm5lclNpemUgPSBudWxsO1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUGllRGF0YURlZi5wcm90b3R5cGUsIFwiX2lubmVyU2l6ZVwiLCB7XG4gICAgICAgICAgZ2V0OiAkdXRpbC5vbmVPZkdldHRlcigkb25lT2ZGaWVsZHMgPSBbXCJpbm5lclNpemVcIl0pLFxuICAgICAgICAgIHNldDogJHV0aWwub25lT2ZTZXR0ZXIoJG9uZU9mRmllbGRzKVxuICAgICAgICB9KTtcbiAgICAgICAgUGllRGF0YURlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUGllRGF0YURlZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLm5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm5hbWVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAxMFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5wb2ludHMgIT0gbnVsbCAmJiBtZXNzYWdlLnBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucG9pbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhLmVuY29kZShtZXNzYWdlLnBvaW50c1tpXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCAyLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5zaXplICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzaXplXCIpKVxuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMjZcbiAgICAgICAgICAgICkuc3RyaW5nKG1lc3NhZ2Uuc2l6ZSk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW5uZXJTaXplICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJpbm5lclNpemVcIikpXG4gICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAzNFxuICAgICAgICAgICAgKS5zdHJpbmcobWVzc2FnZS5pbm5lclNpemUpO1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURhdGFEZWYuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZigpO1xuICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucG9pbnRzICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzLnB1c2goJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNpemUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA0OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lclNpemUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpIHtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5uYW1lKSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwibmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnBvaW50cyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwb2ludHNcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnBvaW50cykpXG4gICAgICAgICAgICAgIHJldHVybiBcInBvaW50czogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YS52ZXJpZnkobWVzc2FnZS5wb2ludHNbaV0pO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicG9pbnRzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLnNpemUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic2l6ZVwiKSkge1xuICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnNpemUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJzaXplOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaW5uZXJTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImlubmVyU2l6ZVwiKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5faW5uZXJTaXplID0gMTtcbiAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5pbm5lclNpemUpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJpbm5lclNpemU6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZilcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZigpO1xuICAgICAgICAgIGlmIChvYmplY3QubmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gU3RyaW5nKG9iamVjdC5uYW1lKTtcbiAgICAgICAgICBpZiAob2JqZWN0LnBvaW50cykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5wb2ludHMpKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uUGllRGF0YURlZi5wb2ludHM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LnBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5wb2ludHNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLlBpZURhdGFEZWYucG9pbnRzOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRzW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YS5mcm9tT2JqZWN0KG9iamVjdC5wb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2Uuc2l6ZSA9IFN0cmluZyhvYmplY3Quc2l6ZSk7XG4gICAgICAgICAgaWYgKG9iamVjdC5pbm5lclNpemUgIT0gbnVsbClcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJTaXplID0gU3RyaW5nKG9iamVjdC5pbm5lclNpemUpO1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhRGVmLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICBvYmplY3QucG9pbnRzID0gW107XG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgIG9iamVjdC5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG9iamVjdC5zaXplID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJuYW1lXCIpKVxuICAgICAgICAgICAgb2JqZWN0Lm5hbWUgPSBtZXNzYWdlLm5hbWU7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucG9pbnRzICYmIG1lc3NhZ2UucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0LnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnBvaW50cy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LnBvaW50c1tqXSA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURhdGEudG9PYmplY3QobWVzc2FnZS5wb2ludHNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5zaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInNpemVcIikpXG4gICAgICAgICAgICBvYmplY3Quc2l6ZSA9IG1lc3NhZ2Uuc2l6ZTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5pbm5lclNpemUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5uZXJTaXplXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuaW5uZXJTaXplID0gbWVzc2FnZS5pbm5lclNpemU7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5faW5uZXJTaXplID0gXCJpbm5lclNpemVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGF0YURlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEYXRhRGVmLmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uUGllRGF0YURlZlwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGllRGF0YURlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLlBpZURlZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBQaWVEZWYocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUGllRGVmLnByb3RvdHlwZS5jaGFydERlZiA9IG51bGw7XG4gICAgICAgIFBpZURlZi5wcm90b3R5cGUuZGF0YSA9ICR1dGlsLmVtcHR5QXJyYXk7XG4gICAgICAgIFBpZURlZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUGllRGVmKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEZWYuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi5lbmNvZGUobWVzc2FnZS5jaGFydERlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5kYXRhLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhRGVmLmVuY29kZShtZXNzYWdlLmRhdGFbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmKCk7XG4gICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmRhdGEgJiYgbWVzc2FnZS5kYXRhLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEucHVzaCgkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgUGllRGVmLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICBpZiAobWVzc2FnZS5jaGFydERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGFydERlZlwiKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYudmVyaWZ5KG1lc3NhZ2UuY2hhcnREZWYpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydERlZi5cIiArIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImRhdGFcIikpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmRhdGEpKVxuICAgICAgICAgICAgICByZXR1cm4gXCJkYXRhOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZi52ZXJpZnkobWVzc2FnZS5kYXRhW2ldKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGEuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmKVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5lcG9jaF9wcm90by5QaWVEZWYoKTtcbiAgICAgICAgICBpZiAob2JqZWN0LmNoYXJ0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNoYXJ0RGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uUGllRGVmLmNoYXJ0RGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmNoYXJ0RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnREZWYuZnJvbU9iamVjdChvYmplY3QuY2hhcnREZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZGF0YSkpXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5lcG9jaF9wcm90by5QaWVEZWYuZGF0YTogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZGF0YVtpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uUGllRGVmLmRhdGE6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhW2ldID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGF0YURlZi5mcm9tT2JqZWN0KG9iamVjdC5kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgb2JqZWN0LmRhdGEgPSBbXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgIG9iamVjdC5jaGFydERlZiA9IG51bGw7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuY2hhcnREZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiY2hhcnREZWZcIikpXG4gICAgICAgICAgICBvYmplY3QuY2hhcnREZWYgPSAkcm9vdC5lcG9jaF9wcm90by5DaGFydERlZi50b09iamVjdChtZXNzYWdlLmNoYXJ0RGVmLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5kYXRhICYmIG1lc3NhZ2UuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iamVjdC5kYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZGF0YS5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgb2JqZWN0LmRhdGFbal0gPSAkcm9vdC5lcG9jaF9wcm90by5QaWVEYXRhRGVmLnRvT2JqZWN0KG1lc3NhZ2UuZGF0YVtqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIFBpZURlZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBQaWVEZWYuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR5cGVVcmxQcmVmaXggPSBcInR5cGUuZ29vZ2xlYXBpcy5jb21cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9lcG9jaF9wcm90by5QaWVEZWZcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFBpZURlZjtcbiAgICAgIH0oKTtcbiAgICAgIGVwb2NoX3Byb3RvLkNoYXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIENoYXJ0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS5saW5lc0RlZiA9IG51bGw7XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS5oZWF0TWFwRGVmID0gbnVsbDtcbiAgICAgICAgQ2hhcnQucHJvdG90eXBlLmJhckRlZiA9IG51bGw7XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS5oaXN0b2dyYW1EZWYgPSBudWxsO1xuICAgICAgICBDaGFydC5wcm90b3R5cGUuYm94UGxvdERlZiA9IG51bGw7XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS54UmFuZ2VEZWYgPSBudWxsO1xuICAgICAgICBDaGFydC5wcm90b3R5cGUucGllRGVmID0gbnVsbDtcbiAgICAgICAgdmFyICRvbmVPZkZpZWxkcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENoYXJ0LnByb3RvdHlwZSwgXCJjaGFydFR5cGVcIiwge1xuICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wibGluZXNEZWZcIiwgXCJoZWF0TWFwRGVmXCIsIFwiYmFyRGVmXCIsIFwiaGlzdG9ncmFtRGVmXCIsIFwiYm94UGxvdERlZlwiLCBcInhSYW5nZURlZlwiLCBcInBpZURlZlwiXSksXG4gICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuICAgICAgICBDaGFydC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2hhcnQocHJvcGVydGllcyk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZXNEZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImxpbmVzRGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYuZW5jb2RlKG1lc3NhZ2UubGluZXNEZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGVhdE1hcERlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiaGVhdE1hcERlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYuZW5jb2RlKG1lc3NhZ2UuaGVhdE1hcERlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5iYXJEZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJhckRlZlwiKSlcbiAgICAgICAgICAgICRyb290LmVwb2NoX3Byb3RvLkJhckRlZi5lbmNvZGUobWVzc2FnZS5iYXJEZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDI2XG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlzdG9ncmFtRGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJoaXN0b2dyYW1EZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYuZW5jb2RlKG1lc3NhZ2UuaGlzdG9ncmFtRGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA0LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAzNFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLmJveFBsb3REZWYgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcImJveFBsb3REZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmLmVuY29kZShtZXNzYWdlLmJveFBsb3REZWYsIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgIC8qIGlkIDUsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgIDQyXG4gICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFJhbmdlRGVmICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ4UmFuZ2VEZWZcIikpXG4gICAgICAgICAgICAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYuZW5jb2RlKG1lc3NhZ2UueFJhbmdlRGVmLCB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICA1MFxuICAgICAgICAgICAgKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgIGlmIChtZXNzYWdlLnBpZURlZiAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwicGllRGVmXCIpKVxuICAgICAgICAgICAgJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmLmVuY29kZShtZXNzYWdlLnBpZURlZiwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgLyogaWQgNywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgNThcbiAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnQoKTtcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGluZXNEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5MaW5lc0RlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhdE1hcERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIDM6IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJhckRlZiA9ICRyb290LmVwb2NoX3Byb3RvLkJhckRlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGlzdG9ncmFtRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5ib3hQbG90RGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERlZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgNjoge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UueFJhbmdlRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uWFJhbmdlRGVmLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5waWVEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5QaWVEZWYuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnQudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgaWYgKG1lc3NhZ2UubGluZXNEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGluZXNEZWZcIikpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2hhcnRUeXBlID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYudmVyaWZ5KG1lc3NhZ2UubGluZXNEZWYpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibGluZXNEZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGVhdE1hcERlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoZWF0TWFwRGVmXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5jaGFydFR5cGUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0VHlwZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYudmVyaWZ5KG1lc3NhZ2UuaGVhdE1hcERlZik7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJoZWF0TWFwRGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJhckRlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiYXJEZWZcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRUeXBlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2hhcnRUeXBlID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQmFyRGVmLnZlcmlmeShtZXNzYWdlLmJhckRlZik7XG4gICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJiYXJEZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuaGlzdG9ncmFtRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhpc3RvZ3JhbURlZlwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuY2hhcnRUeXBlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydFR5cGU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jaGFydFR5cGUgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5IaXN0b2dyYW1EZWYudmVyaWZ5KG1lc3NhZ2UuaGlzdG9ncmFtRGVmKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImhpc3RvZ3JhbURlZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5ib3hQbG90RGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJveFBsb3REZWZcIikpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9PT0gMSlcbiAgICAgICAgICAgICAgcmV0dXJuIFwiY2hhcnRUeXBlOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuY2hhcnRUeXBlID0gMTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZXBvY2hfcHJvdG8uQm94UGxvdERlZi52ZXJpZnkobWVzc2FnZS5ib3hQbG90RGVmKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImJveFBsb3REZWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFJhbmdlRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhSYW5nZURlZlwiKSkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuY2hhcnRUeXBlID09PSAxKVxuICAgICAgICAgICAgICByZXR1cm4gXCJjaGFydFR5cGU6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgcHJvcGVydGllcy5jaGFydFR5cGUgPSAxO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYudmVyaWZ5KG1lc3NhZ2UueFJhbmdlRGVmKTtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInhSYW5nZURlZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5waWVEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGllRGVmXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcy5jaGFydFR5cGUgPT09IDEpXG4gICAgICAgICAgICAgIHJldHVybiBcImNoYXJ0VHlwZTogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmNoYXJ0VHlwZSA9IDE7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURlZi52ZXJpZnkobWVzc2FnZS5waWVEZWYpO1xuICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicGllRGVmLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBDaGFydC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZXBvY2hfcHJvdG8uQ2hhcnQpXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmVwb2NoX3Byb3RvLkNoYXJ0KCk7XG4gICAgICAgICAgaWYgKG9iamVjdC5saW5lc0RlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5saW5lc0RlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LmxpbmVzRGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmxpbmVzRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYuZnJvbU9iamVjdChvYmplY3QubGluZXNEZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmhlYXRNYXBEZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaGVhdE1hcERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LmhlYXRNYXBEZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuaGVhdE1hcERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkhlYXRNYXBEZWYuZnJvbU9iamVjdChvYmplY3QuaGVhdE1hcERlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QuYmFyRGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmJhckRlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LmJhckRlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS5iYXJEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5CYXJEZWYuZnJvbU9iamVjdChvYmplY3QuYmFyRGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5oaXN0b2dyYW1EZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuaGlzdG9ncmFtRGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2hhcnQuaGlzdG9ncmFtRGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLmhpc3RvZ3JhbURlZiA9ICRyb290LmVwb2NoX3Byb3RvLkhpc3RvZ3JhbURlZi5mcm9tT2JqZWN0KG9iamVjdC5oaXN0b2dyYW1EZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2JqZWN0LmJveFBsb3REZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYm94UGxvdERlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LmJveFBsb3REZWY6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgIG1lc3NhZ2UuYm94UGxvdERlZiA9ICRyb290LmVwb2NoX3Byb3RvLkJveFBsb3REZWYuZnJvbU9iamVjdChvYmplY3QuYm94UGxvdERlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvYmplY3QueFJhbmdlRGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnhSYW5nZURlZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmVwb2NoX3Byb3RvLkNoYXJ0LnhSYW5nZURlZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgbWVzc2FnZS54UmFuZ2VEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5YUmFuZ2VEZWYuZnJvbU9iamVjdChvYmplY3QueFJhbmdlRGVmKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9iamVjdC5waWVEZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucGllRGVmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZXBvY2hfcHJvdG8uQ2hhcnQucGllRGVmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICBtZXNzYWdlLnBpZURlZiA9ICRyb290LmVwb2NoX3Byb3RvLlBpZURlZi5mcm9tT2JqZWN0KG9iamVjdC5waWVEZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hhcnQudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICBpZiAobWVzc2FnZS5saW5lc0RlZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsaW5lc0RlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmxpbmVzRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uTGluZXNEZWYudG9PYmplY3QobWVzc2FnZS5saW5lc0RlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcImxpbmVzRGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmhlYXRNYXBEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGVhdE1hcERlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmhlYXRNYXBEZWYgPSAkcm9vdC5lcG9jaF9wcm90by5IZWF0TWFwRGVmLnRvT2JqZWN0KG1lc3NhZ2UuaGVhdE1hcERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcImhlYXRNYXBEZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuYmFyRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJhckRlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJhckRlZiA9ICRyb290LmVwb2NoX3Byb3RvLkJhckRlZi50b09iamVjdChtZXNzYWdlLmJhckRlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcImJhckRlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5oaXN0b2dyYW1EZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGlzdG9ncmFtRGVmXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QuaGlzdG9ncmFtRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uSGlzdG9ncmFtRGVmLnRvT2JqZWN0KG1lc3NhZ2UuaGlzdG9ncmFtRGVmLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LmNoYXJ0VHlwZSA9IFwiaGlzdG9ncmFtRGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmJveFBsb3REZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYm94UGxvdERlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LmJveFBsb3REZWYgPSAkcm9vdC5lcG9jaF9wcm90by5Cb3hQbG90RGVmLnRvT2JqZWN0KG1lc3NhZ2UuYm94UGxvdERlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcImJveFBsb3REZWZcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UueFJhbmdlRGVmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhSYW5nZURlZlwiKSkge1xuICAgICAgICAgICAgb2JqZWN0LnhSYW5nZURlZiA9ICRyb290LmVwb2NoX3Byb3RvLlhSYW5nZURlZi50b09iamVjdChtZXNzYWdlLnhSYW5nZURlZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgIG9iamVjdC5jaGFydFR5cGUgPSBcInhSYW5nZURlZlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5waWVEZWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGllRGVmXCIpKSB7XG4gICAgICAgICAgICBvYmplY3QucGllRGVmID0gJHJvb3QuZXBvY2hfcHJvdG8uUGllRGVmLnRvT2JqZWN0KG1lc3NhZ2UucGllRGVmLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgb2JqZWN0LmNoYXJ0VHlwZSA9IFwicGllRGVmXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIENoYXJ0LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICBpZiAodHlwZVVybFByZWZpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0eXBlVXJsUHJlZml4ICsgXCIvZXBvY2hfcHJvdG8uQ2hhcnRcIjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENoYXJ0O1xuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGVwb2NoX3Byb3RvO1xuICAgIH0oKTtcbiAgICAkcm9vdC5nb29nbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnb29nbGUgPSB7fTtcbiAgICAgIGdvb2dsZS5wcm90b2J1ZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdG9idWYgPSB7fTtcbiAgICAgICAgcHJvdG9idWYuU3RydWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gU3RydWN0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZmllbGRzID0ge307XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFN0cnVjdC5wcm90b3R5cGUuZmllbGRzID0gJHV0aWwuZW1wdHlPYmplY3Q7XG4gICAgICAgICAgU3RydWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cnVjdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiZmllbGRzXCIpKVxuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMobWVzc2FnZS5maWVsZHMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5mb3JrKCkudWludDMyKFxuICAgICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAgIDEwXG4gICAgICAgICAgICAgICAgKS5zdHJpbmcoa2V5c1tpXSk7XG4gICAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmVuY29kZShtZXNzYWdlLmZpZWxkc1trZXlzW2ldXSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovXG4gICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKS5sZGVsaW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgsIGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHZvaWQgMCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QoKSwga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgIGlmICh0YWcgPT09IGVycm9yKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMToge1xuICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZmllbGRzID09PSAkdXRpbC5lbXB0eU9iamVjdClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgIGtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhZzIgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnMiA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZzIgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmaWVsZHNcIikpIHtcbiAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc09iamVjdChtZXNzYWdlLmZpZWxkcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmllbGRzOiBvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKG1lc3NhZ2UuZmllbGRzKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudmVyaWZ5KG1lc3NhZ2UuZmllbGRzW2tleVtpXV0pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcImZpZWxkcy5cIiArIGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFN0cnVjdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0KVxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5maWVsZHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZmllbGRzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuU3RydWN0LmZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLmZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0LmZpZWxkcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmZpZWxkc1trZXlzW2ldXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuU3RydWN0LmZpZWxkczogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmllbGRzW2tleXNbaV1dID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlLmZyb21PYmplY3Qob2JqZWN0LmZpZWxkc1trZXlzW2ldXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vYmplY3RzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgIG9iamVjdC5maWVsZHMgPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXlzMjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmZpZWxkcyAmJiAoa2V5czIgPSBPYmplY3Qua2V5cyhtZXNzYWdlLmZpZWxkcykpLmxlbmd0aCkge1xuICAgICAgICAgICAgICBvYmplY3QuZmllbGRzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5czIubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgb2JqZWN0LmZpZWxkc1trZXlzMltqXV0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudG9PYmplY3QobWVzc2FnZS5maWVsZHNba2V5czJbal1dLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBTdHJ1Y3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgU3RydWN0LmdldFR5cGVVcmwgPSBmdW5jdGlvbiBnZXRUeXBlVXJsKHR5cGVVcmxQcmVmaXgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlVXJsUHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZVVybFByZWZpeCA9IFwidHlwZS5nb29nbGVhcGlzLmNvbVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVVcmxQcmVmaXggKyBcIi9nb29nbGUucHJvdG9idWYuU3RydWN0XCI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gU3RydWN0O1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLlZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gVmFsdWUocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubnVsbFZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubnVtYmVyVmFsdWUgPSBudWxsO1xuICAgICAgICAgIFZhbHVlLnByb3RvdHlwZS5zdHJpbmdWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLmJvb2xWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLnN0cnVjdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICBWYWx1ZS5wcm90b3R5cGUubGlzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWx1ZS5wcm90b3R5cGUsIFwia2luZFwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcIm51bGxWYWx1ZVwiLCBcIm51bWJlclZhbHVlXCIsIFwic3RyaW5nVmFsdWVcIiwgXCJib29sVmFsdWVcIiwgXCJzdHJ1Y3RWYWx1ZVwiLCBcImxpc3RWYWx1ZVwiXSksXG4gICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBWYWx1ZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVsbFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJudWxsVmFsdWVcIikpXG4gICAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki9cbiAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICkuaW50MzIobWVzc2FnZS5udWxsVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVtYmVyVmFsdWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIm51bWJlclZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDIsIHdpcmVUeXBlIDEgPSovXG4gICAgICAgICAgICAgICAgMTdcbiAgICAgICAgICAgICAgKS5kb3VibGUobWVzc2FnZS5udW1iZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwic3RyaW5nVmFsdWVcIikpXG4gICAgICAgICAgICAgIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgLyogaWQgMywgd2lyZVR5cGUgMiA9Ki9cbiAgICAgICAgICAgICAgICAyNlxuICAgICAgICAgICAgICApLnN0cmluZyhtZXNzYWdlLnN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiYm9vbFZhbHVlXCIpKVxuICAgICAgICAgICAgICB3cml0ZXIudWludDMyKFxuICAgICAgICAgICAgICAgIC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovXG4gICAgICAgICAgICAgICAgMzJcbiAgICAgICAgICAgICAgKS5ib29sKG1lc3NhZ2UuYm9vbFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cnVjdFZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJzdHJ1Y3RWYWx1ZVwiKSlcbiAgICAgICAgICAgICAgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC5lbmNvZGUobWVzc2FnZS5zdHJ1Y3RWYWx1ZSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA1LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDQyXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxpc3RWYWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwibGlzdFZhbHVlXCIpKVxuICAgICAgICAgICAgICAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmVuY29kZShtZXNzYWdlLmxpc3RWYWx1ZSwgd3JpdGVyLnVpbnQzMihcbiAgICAgICAgICAgICAgICAvKiBpZCA2LCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgIDUwXG4gICAgICAgICAgICAgICkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBWYWx1ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlZhbHVlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICBpZiAodGFnID09PSBlcnJvcilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVsbFZhbHVlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bWJlclZhbHVlID0gcmVhZGVyLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYm9vbFZhbHVlID0gcmVhZGVyLmJvb2woKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIDU6IHtcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3RydWN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuU3RydWN0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpc3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5udWxsVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFZhbHVlOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm51bWJlclZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm51bWJlclZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmtpbmQgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwia2luZDogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMua2luZCA9IDE7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5udW1iZXJWYWx1ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudW1iZXJWYWx1ZTogbnVtYmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJpbmdWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJpbmdWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uuc3RyaW5nVmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1ZhbHVlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMua2luZCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJraW5kOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgcHJvcGVydGllcy5raW5kID0gMTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmJvb2xWYWx1ZSAhPT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYm9vbFZhbHVlOiBib29sZWFuIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdHJ1Y3RWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdHJ1Y3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC52ZXJpZnkobWVzc2FnZS5zdHJ1Y3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwic3RydWN0VmFsdWUuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGlzdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpc3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5raW5kID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBcImtpbmQ6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmtpbmQgPSAxO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52ZXJpZnkobWVzc2FnZS5saXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcImxpc3RWYWx1ZS5cIiArIGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZSgpO1xuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QubnVsbFZhbHVlKSB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubnVsbFZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IG9iamVjdC5udWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJOVUxMX1ZBTFVFXCI6XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm51bGxWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0Lm51bWJlclZhbHVlICE9IG51bGwpXG4gICAgICAgICAgICAgIG1lc3NhZ2UubnVtYmVyVmFsdWUgPSBOdW1iZXIob2JqZWN0Lm51bWJlclZhbHVlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RyaW5nVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgbWVzc2FnZS5zdHJpbmdWYWx1ZSA9IFN0cmluZyhvYmplY3Quc3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5ib29sVmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgbWVzc2FnZS5ib29sVmFsdWUgPSBCb29sZWFuKG9iamVjdC5ib29sVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5zdHJ1Y3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnN0cnVjdFZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5nb29nbGUucHJvdG9idWYuVmFsdWUuc3RydWN0VmFsdWU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5zdHJ1Y3RWYWx1ZSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QuZnJvbU9iamVjdChvYmplY3Quc3RydWN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5saXN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5saXN0VmFsdWUgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5saXN0VmFsdWU6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgbWVzc2FnZS5saXN0VmFsdWUgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuTGlzdFZhbHVlLmZyb21PYmplY3Qob2JqZWN0Lmxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIFZhbHVlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5udWxsVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVsbFZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5udWxsVmFsdWUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA9PT0gdm9pZCAwID8gbWVzc2FnZS5udWxsVmFsdWUgOiAkcm9vdC5nb29nbGUucHJvdG9idWYuTnVsbFZhbHVlW21lc3NhZ2UubnVsbFZhbHVlXSA6IG1lc3NhZ2UubnVsbFZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcIm51bGxWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubnVtYmVyVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibnVtYmVyVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0Lm51bWJlclZhbHVlID0gb3B0aW9ucy5qc29uICYmICFpc0Zpbml0ZShtZXNzYWdlLm51bWJlclZhbHVlKSA/IFN0cmluZyhtZXNzYWdlLm51bWJlclZhbHVlKSA6IG1lc3NhZ2UubnVtYmVyVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwibnVtYmVyVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0cmluZ1ZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInN0cmluZ1ZhbHVlXCIpKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5zdHJpbmdWYWx1ZSA9IG1lc3NhZ2Uuc3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwic3RyaW5nVmFsdWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmJvb2xWYWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJib29sVmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmJvb2xWYWx1ZSA9IG1lc3NhZ2UuYm9vbFZhbHVlO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmtpbmQgPSBcImJvb2xWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uuc3RydWN0VmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3RydWN0VmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LnN0cnVjdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdC50b09iamVjdChtZXNzYWdlLnN0cnVjdFZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5raW5kID0gXCJzdHJ1Y3RWYWx1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGlzdFZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxpc3RWYWx1ZVwiKSkge1xuICAgICAgICAgICAgICBvYmplY3QubGlzdFZhbHVlID0gJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS50b09iamVjdChtZXNzYWdlLmxpc3RWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICBvYmplY3Qua2luZCA9IFwibGlzdFZhbHVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgVmFsdWUuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2dvb2dsZS5wcm90b2J1Zi5WYWx1ZVwiO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIFZhbHVlO1xuICAgICAgICB9KCk7XG4gICAgICAgIHByb3RvYnVmLk51bGxWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIk5VTExfVkFMVUVcIl0gPSAwO1xuICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcHJvdG9idWYuTGlzdFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnVuY3Rpb24gTGlzdFZhbHVlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudmFsdWVzID0gJHV0aWwuZW1wdHlBcnJheTtcbiAgICAgICAgICBMaXN0VmFsdWUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdFZhbHVlKHByb3BlcnRpZXMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWVzICE9IG51bGwgJiYgbWVzc2FnZS52YWx1ZXMubGVuZ3RoKVxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5lbmNvZGUobWVzc2FnZS52YWx1ZXNbaV0sIHdyaXRlci51aW50MzIoXG4gICAgICAgICAgICAgICAgICAvKiBpZCAxLCB3aXJlVHlwZSAyID0qL1xuICAgICAgICAgICAgICAgICAgMTBcbiAgICAgICAgICAgICAgICApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgTGlzdFZhbHVlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCwgZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdm9pZCAwID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gZXJyb3IpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZXMucHVzaCgkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZXNcIikpIHtcbiAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UudmFsdWVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudmVyaWZ5KG1lc3NhZ2UudmFsdWVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YWx1ZXMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZSlcbiAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudmFsdWVzKSB7XG4gICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QudmFsdWVzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52YWx1ZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZXNbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuZ29vZ2xlLnByb3RvYnVmLkxpc3RWYWx1ZS52YWx1ZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlc1tpXSA9ICRyb290Lmdvb2dsZS5wcm90b2J1Zi5WYWx1ZS5mcm9tT2JqZWN0KG9iamVjdC52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgIG9iamVjdC52YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UudmFsdWVzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZXNbal0gPSAkcm9vdC5nb29nbGUucHJvdG9idWYuVmFsdWUudG9PYmplY3QobWVzc2FnZS52YWx1ZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIExpc3RWYWx1ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMaXN0VmFsdWUuZ2V0VHlwZVVybCA9IGZ1bmN0aW9uIGdldFR5cGVVcmwodHlwZVVybFByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVVcmxQcmVmaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICB0eXBlVXJsUHJlZml4ID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZVVybFByZWZpeCArIFwiL2dvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWVcIjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBMaXN0VmFsdWU7XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIHByb3RvYnVmO1xuICAgICAgfSgpO1xuICAgICAgcmV0dXJuIGdvb2dsZTtcbiAgICB9KCk7XG4gICAgbW9kdWxlMi5leHBvcnRzID0gJHJvb3Q7XG4gIH1cbn0pO1xuZXhwb3J0IGRlZmF1bHQgcmVxdWlyZV90ZWFyc2hlZXQoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/tearsheet.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@tanstack/react-table/build/lib/index.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-table/build/lib/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   flexRender: () => (/* binding */ flexRender),\n/* harmony export */   useReactTable: () => (/* binding */ useReactTable)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tanstack/table-core */ \"(pages-dir-browser)/./node_modules/@tanstack/table-core/build/lib/index.mjs\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"flexRender\",\"useReactTable\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/**\n   * react-table\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\n\n\n\n\n//\n\n/**\n * If rendering headers, cells, or footers with custom markup, use flexRender instead of `cell.getValue()` or `cell.renderValue()`.\n */\nfunction flexRender(Comp, props) {\n  return !Comp ? null : isReactComponent(Comp) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, props) : Comp;\n}\nfunction isReactComponent(component) {\n  return isClassComponent(component) || typeof component === 'function' || isExoticComponent(component);\n}\nfunction isClassComponent(component) {\n  return typeof component === 'function' && (() => {\n    const proto = Object.getPrototypeOf(component);\n    return proto.prototype && proto.prototype.isReactComponent;\n  })();\n}\nfunction isExoticComponent(component) {\n  return typeof component === 'object' && typeof component.$$typeof === 'symbol' && ['react.memo', 'react.forward_ref'].includes(component.$$typeof.description);\n}\nfunction useReactTable(options) {\n  // Compose in the generic options to the user options\n  const resolvedOptions = {\n    state: {},\n    // Dummy state\n    onStateChange: () => {},\n    // noop\n    renderFallbackValue: null,\n    ...options\n  };\n\n  // Create a new table and store it in state\n  const [tableRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    current: (0,_tanstack_table_core__WEBPACK_IMPORTED_MODULE_1__.createTable)(resolvedOptions)\n  }));\n\n  // By default, manage table state here using the table's initial state\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => tableRef.current.initialState);\n\n  // Compose the default state above with any user state. This will allow the user\n  // to only control a subset of the state if desired.\n  tableRef.current.setOptions(prev => ({\n    ...prev,\n    ...options,\n    state: {\n      ...state,\n      ...options.state\n    },\n    // Similarly, we'll maintain both our internal state and any user-provided\n    // state.\n    onStateChange: updater => {\n      setState(updater);\n      options.onStateChange == null || options.onStateChange(updater);\n    }\n  }));\n  return tableRef.current;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdGFibGUvYnVpbGQvbGliL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0I7QUFDb0I7QUFDZDs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsZ0RBQW1CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMkNBQWM7QUFDbkMsYUFBYSxpRUFBVztBQUN4QixHQUFHOztBQUVIO0FBQ0EsNEJBQTRCLDJDQUFjOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVxQztBQUNyQyIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXRhYmxlL2J1aWxkL2xpYi9pbmRleC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICAqIHJlYWN0LXRhYmxlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlVGFibGUgfSBmcm9tICdAdGFuc3RhY2svdGFibGUtY29yZSc7XG5leHBvcnQgKiBmcm9tICdAdGFuc3RhY2svdGFibGUtY29yZSc7XG5cbi8vXG5cbi8qKlxuICogSWYgcmVuZGVyaW5nIGhlYWRlcnMsIGNlbGxzLCBvciBmb290ZXJzIHdpdGggY3VzdG9tIG1hcmt1cCwgdXNlIGZsZXhSZW5kZXIgaW5zdGVhZCBvZiBgY2VsbC5nZXRWYWx1ZSgpYCBvciBgY2VsbC5yZW5kZXJWYWx1ZSgpYC5cbiAqL1xuZnVuY3Rpb24gZmxleFJlbmRlcihDb21wLCBwcm9wcykge1xuICByZXR1cm4gIUNvbXAgPyBudWxsIDogaXNSZWFjdENvbXBvbmVudChDb21wKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXAsIHByb3BzKSA6IENvbXA7XG59XG5mdW5jdGlvbiBpc1JlYWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gaXNDbGFzc0NvbXBvbmVudChjb21wb25lbnQpIHx8IHR5cGVvZiBjb21wb25lbnQgPT09ICdmdW5jdGlvbicgfHwgaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmICgoKSA9PiB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY29tcG9uZW50KTtcbiAgICByZXR1cm4gcHJvdG8ucHJvdG90eXBlICYmIHByb3RvLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xuICB9KSgpO1xufVxuZnVuY3Rpb24gaXNFeG90aWNDb21wb25lbnQoY29tcG9uZW50KSB7XG4gIHJldHVybiB0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgY29tcG9uZW50LiQkdHlwZW9mID09PSAnc3ltYm9sJyAmJiBbJ3JlYWN0Lm1lbW8nLCAncmVhY3QuZm9yd2FyZF9yZWYnXS5pbmNsdWRlcyhjb21wb25lbnQuJCR0eXBlb2YuZGVzY3JpcHRpb24pO1xufVxuZnVuY3Rpb24gdXNlUmVhY3RUYWJsZShvcHRpb25zKSB7XG4gIC8vIENvbXBvc2UgaW4gdGhlIGdlbmVyaWMgb3B0aW9ucyB0byB0aGUgdXNlciBvcHRpb25zXG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICBzdGF0ZToge30sXG4gICAgLy8gRHVtbXkgc3RhdGVcbiAgICBvblN0YXRlQ2hhbmdlOiAoKSA9PiB7fSxcbiAgICAvLyBub29wXG4gICAgcmVuZGVyRmFsbGJhY2tWYWx1ZTogbnVsbCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHRhYmxlIGFuZCBzdG9yZSBpdCBpbiBzdGF0ZVxuICBjb25zdCBbdGFibGVSZWZdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gKHtcbiAgICBjdXJyZW50OiBjcmVhdGVUYWJsZShyZXNvbHZlZE9wdGlvbnMpXG4gIH0pKTtcblxuICAvLyBCeSBkZWZhdWx0LCBtYW5hZ2UgdGFibGUgc3RhdGUgaGVyZSB1c2luZyB0aGUgdGFibGUncyBpbml0aWFsIHN0YXRlXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gdGFibGVSZWYuY3VycmVudC5pbml0aWFsU3RhdGUpO1xuXG4gIC8vIENvbXBvc2UgdGhlIGRlZmF1bHQgc3RhdGUgYWJvdmUgd2l0aCBhbnkgdXNlciBzdGF0ZS4gVGhpcyB3aWxsIGFsbG93IHRoZSB1c2VyXG4gIC8vIHRvIG9ubHkgY29udHJvbCBhIHN1YnNldCBvZiB0aGUgc3RhdGUgaWYgZGVzaXJlZC5cbiAgdGFibGVSZWYuY3VycmVudC5zZXRPcHRpb25zKHByZXYgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm9wdGlvbnMsXG4gICAgc3RhdGU6IHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgLi4ub3B0aW9ucy5zdGF0ZVxuICAgIH0sXG4gICAgLy8gU2ltaWxhcmx5LCB3ZSdsbCBtYWludGFpbiBib3RoIG91ciBpbnRlcm5hbCBzdGF0ZSBhbmQgYW55IHVzZXItcHJvdmlkZWRcbiAgICAvLyBzdGF0ZS5cbiAgICBvblN0YXRlQ2hhbmdlOiB1cGRhdGVyID0+IHtcbiAgICAgIHNldFN0YXRlKHVwZGF0ZXIpO1xuICAgICAgb3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgb3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gdGFibGVSZWYuY3VycmVudDtcbn1cblxuZXhwb3J0IHsgZmxleFJlbmRlciwgdXNlUmVhY3RUYWJsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@tanstack/react-table/build/lib/index.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(pages-dir-browser)/./node_modules/react-dom/index.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__) if([\"default\",\"useVirtualizer\",\"useWindowVirtualizer\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n  const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(() => ({}), {})[1];\n  const resolvedOptions = {\n    ...options,\n    onChange: (instance2, sync) => {\n      var _a;\n      if (sync) {\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n      } else {\n        rerender();\n      }\n      (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n    }\n  };\n  const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\n    () => new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions)\n  );\n  instance.setOptions(resolvedOptions);\n  useIsomorphicLayoutEffect(() => {\n    return instance._didMount();\n  }, []);\n  useIsomorphicLayoutEffect(() => {\n    return instance._willUpdate();\n  });\n  return instance;\n}\nfunction useVirtualizer(options) {\n  return useVirtualizerBase({\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n    ...options\n  });\n}\nfunction useWindowVirtualizer(options) {\n  return useVirtualizerBase({\n    getScrollElement: () => typeof document !== \"undefined\" ? window : null,\n    observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n    observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n    scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n    initialOffset: () => typeof document !== \"undefined\" ? window.scrollY : 0,\n    ...options\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQzhIO0FBQzdIO0FBQ3ZDLG9FQUFvRSxrREFBcUIsR0FBRyw0Q0FBZTtBQUMzRztBQUNBLG1CQUFtQiw2Q0FBZ0IsVUFBVSxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFTO0FBQ2pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJDQUFjO0FBQ25DLGNBQWMsK0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsZ0JBQWdCLGlFQUFhO0FBQzdCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFpQjtBQUN6QywwQkFBMEIsdUVBQW1CO0FBQzdDLGdCQUFnQixnRUFBWTtBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmbHVzaFN5bmMgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBWaXJ0dWFsaXplciwgZWxlbWVudFNjcm9sbCwgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsIG9ic2VydmVFbGVtZW50UmVjdCwgd2luZG93U2Nyb2xsLCBvYnNlcnZlV2luZG93T2Zmc2V0LCBvYnNlcnZlV2luZG93UmVjdCB9IGZyb20gXCJAdGFuc3RhY2svdmlydHVhbC1jb3JlXCI7XG5leHBvcnQgKiBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZVZpcnR1YWxpemVyQmFzZShvcHRpb25zKSB7XG4gIGNvbnN0IHJlcmVuZGVyID0gUmVhY3QudXNlUmVkdWNlcigoKSA9PiAoe30pLCB7fSlbMV07XG4gIGNvbnN0IHJlc29sdmVkT3B0aW9ucyA9IHtcbiAgICAuLi5vcHRpb25zLFxuICAgIG9uQ2hhbmdlOiAoaW5zdGFuY2UyLCBzeW5jKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc3luYykge1xuICAgICAgICBmbHVzaFN5bmMocmVyZW5kZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVyZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIChfYSA9IG9wdGlvbnMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGluc3RhbmNlMiwgc3luYyk7XG4gICAgfVxuICB9O1xuICBjb25zdCBbaW5zdGFuY2VdID0gUmVhY3QudXNlU3RhdGUoXG4gICAgKCkgPT4gbmV3IFZpcnR1YWxpemVyKHJlc29sdmVkT3B0aW9ucylcbiAgKTtcbiAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhyZXNvbHZlZE9wdGlvbnMpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2RpZE1vdW50KCk7XG4gIH0sIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl93aWxsVXBkYXRlKCk7XG4gIH0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIG9ic2VydmVFbGVtZW50UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiBlbGVtZW50U2Nyb2xsLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dWaXJ0dWFsaXplcihvcHRpb25zKSB7XG4gIHJldHVybiB1c2VWaXJ0dWFsaXplckJhc2Uoe1xuICAgIGdldFNjcm9sbEVsZW1lbnQ6ICgpID0+IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGwsXG4gICAgb2JzZXJ2ZUVsZW1lbnRSZWN0OiBvYnNlcnZlV2luZG93UmVjdCxcbiAgICBvYnNlcnZlRWxlbWVudE9mZnNldDogb2JzZXJ2ZVdpbmRvd09mZnNldCxcbiAgICBzY3JvbGxUb0ZuOiB3aW5kb3dTY3JvbGwsXG4gICAgaW5pdGlhbE9mZnNldDogKCkgPT4gdHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnNjcm9sbFkgOiAwLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59XG5leHBvcnQge1xuICB1c2VWaXJ0dWFsaXplcixcbiAgdXNlV2luZG93VmlydHVhbGl6ZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@tanstack/table-core/build/lib/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/table-core/build/lib/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColumnFaceting: () => (/* binding */ ColumnFaceting),\n/* harmony export */   ColumnFiltering: () => (/* binding */ ColumnFiltering),\n/* harmony export */   ColumnGrouping: () => (/* binding */ ColumnGrouping),\n/* harmony export */   ColumnOrdering: () => (/* binding */ ColumnOrdering),\n/* harmony export */   ColumnPinning: () => (/* binding */ ColumnPinning),\n/* harmony export */   ColumnSizing: () => (/* binding */ ColumnSizing),\n/* harmony export */   ColumnVisibility: () => (/* binding */ ColumnVisibility),\n/* harmony export */   GlobalFaceting: () => (/* binding */ GlobalFaceting),\n/* harmony export */   GlobalFiltering: () => (/* binding */ GlobalFiltering),\n/* harmony export */   Headers: () => (/* binding */ Headers),\n/* harmony export */   RowExpanding: () => (/* binding */ RowExpanding),\n/* harmony export */   RowPagination: () => (/* binding */ RowPagination),\n/* harmony export */   RowPinning: () => (/* binding */ RowPinning),\n/* harmony export */   RowSelection: () => (/* binding */ RowSelection),\n/* harmony export */   RowSorting: () => (/* binding */ RowSorting),\n/* harmony export */   _getVisibleLeafColumns: () => (/* binding */ _getVisibleLeafColumns),\n/* harmony export */   aggregationFns: () => (/* binding */ aggregationFns),\n/* harmony export */   buildHeaderGroups: () => (/* binding */ buildHeaderGroups),\n/* harmony export */   createCell: () => (/* binding */ createCell),\n/* harmony export */   createColumn: () => (/* binding */ createColumn),\n/* harmony export */   createColumnHelper: () => (/* binding */ createColumnHelper),\n/* harmony export */   createRow: () => (/* binding */ createRow),\n/* harmony export */   createTable: () => (/* binding */ createTable),\n/* harmony export */   defaultColumnSizing: () => (/* binding */ defaultColumnSizing),\n/* harmony export */   expandRows: () => (/* binding */ expandRows),\n/* harmony export */   filterFns: () => (/* binding */ filterFns),\n/* harmony export */   flattenBy: () => (/* binding */ flattenBy),\n/* harmony export */   functionalUpdate: () => (/* binding */ functionalUpdate),\n/* harmony export */   getCoreRowModel: () => (/* binding */ getCoreRowModel),\n/* harmony export */   getExpandedRowModel: () => (/* binding */ getExpandedRowModel),\n/* harmony export */   getFacetedMinMaxValues: () => (/* binding */ getFacetedMinMaxValues),\n/* harmony export */   getFacetedRowModel: () => (/* binding */ getFacetedRowModel),\n/* harmony export */   getFacetedUniqueValues: () => (/* binding */ getFacetedUniqueValues),\n/* harmony export */   getFilteredRowModel: () => (/* binding */ getFilteredRowModel),\n/* harmony export */   getGroupedRowModel: () => (/* binding */ getGroupedRowModel),\n/* harmony export */   getMemoOptions: () => (/* binding */ getMemoOptions),\n/* harmony export */   getPaginationRowModel: () => (/* binding */ getPaginationRowModel),\n/* harmony export */   getSortedRowModel: () => (/* binding */ getSortedRowModel),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isNumberArray: () => (/* binding */ isNumberArray),\n/* harmony export */   isRowSelected: () => (/* binding */ isRowSelected),\n/* harmony export */   isSubRowSelected: () => (/* binding */ isSubRowSelected),\n/* harmony export */   makeStateUpdater: () => (/* binding */ makeStateUpdater),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   orderColumns: () => (/* binding */ orderColumns),\n/* harmony export */   passiveEventSupported: () => (/* binding */ passiveEventSupported),\n/* harmony export */   reSplitAlphaNumeric: () => (/* binding */ reSplitAlphaNumeric),\n/* harmony export */   selectRowsFn: () => (/* binding */ selectRowsFn),\n/* harmony export */   shouldAutoRemoveFilter: () => (/* binding */ shouldAutoRemoveFilter),\n/* harmony export */   sortingFns: () => (/* binding */ sortingFns)\n/* harmony export */ });\n/**\n   * table-core\n   *\n   * Copyright (c) TanStack\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE.md file in the root directory of this source tree.\n   *\n   * @license MIT\n   */\n// type Person = {\n//   firstName: string\n//   lastName: string\n//   age: number\n//   visits: number\n//   status: string\n//   progress: number\n//   createdAt: Date\n//   nested: {\n//     foo: [\n//       {\n//         bar: 'bar'\n//       }\n//     ]\n//     bar: { subBar: boolean }[]\n//     baz: {\n//       foo: 'foo'\n//       bar: {\n//         baz: 'baz'\n//       }\n//     }\n//   }\n// }\n\n// const test: DeepKeys<Person> = 'nested.foo.0.bar'\n// const test2: DeepKeys<Person> = 'nested.bar'\n\n// const helper = createColumnHelper<Person>()\n\n// helper.accessor('nested.foo', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.foo.0.bar', {\n//   cell: info => info.getValue(),\n// })\n\n// helper.accessor('nested.bar', {\n//   cell: info => info.getValue(),\n// })\n\nfunction createColumnHelper() {\n  return {\n    accessor: (accessor, column) => {\n      return typeof accessor === 'function' ? {\n        ...column,\n        accessorFn: accessor\n      } : {\n        ...column,\n        accessorKey: accessor\n      };\n    },\n    display: column => column,\n    group: column => column\n  };\n}\n\n// Is this type a tuple?\n\n// If this type is a tuple, what indices are allowed?\n\n///\n\nfunction functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nfunction noop() {\n  //\n}\nfunction makeStateUpdater(key, instance) {\n  return updater => {\n    instance.setState(old => {\n      return {\n        ...old,\n        [key]: functionalUpdate(updater, old[key])\n      };\n    });\n  };\n}\nfunction isFunction(d) {\n  return d instanceof Function;\n}\nfunction isNumberArray(d) {\n  return Array.isArray(d) && d.every(val => typeof val === 'number');\n}\nfunction flattenBy(arr, getChildren) {\n  const flat = [];\n  const recurse = subArr => {\n    subArr.forEach(item => {\n      flat.push(item);\n      const children = getChildren(item);\n      if (children != null && children.length) {\n        recurse(children);\n      }\n    });\n  };\n  recurse(arr);\n  return flat;\n}\nfunction memo(getDeps, fn, opts) {\n  let deps = [];\n  let result;\n  return depArgs => {\n    let depTime;\n    if (opts.key && opts.debug) depTime = Date.now();\n    const newDeps = getDeps(depArgs);\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && opts.debug) resultTime = Date.now();\n    result = fn(...newDeps);\n    opts == null || opts.onChange == null || opts.onChange(result);\n    if (opts.key && opts.debug) {\n      if (opts != null && opts.debug()) {\n        const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n        const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n        const resultFpsPercentage = resultEndTime / 16;\n        const pad = (str, num) => {\n          str = String(str);\n          while (str.length < num) {\n            str = ' ' + str;\n          }\n          return str;\n        };\n        console.info(`%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n      }\n    }\n    return result;\n  };\n}\nfunction getMemoOptions(tableOptions, debugLevel, key, onChange) {\n  return {\n    debug: () => {\n      var _tableOptions$debugAl;\n      return (_tableOptions$debugAl = tableOptions == null ? void 0 : tableOptions.debugAll) != null ? _tableOptions$debugAl : tableOptions[debugLevel];\n    },\n    key:  true && key,\n    onChange\n  };\n}\n\nfunction createCell(table, row, column, columnId) {\n  const getRenderValue = () => {\n    var _cell$getValue;\n    return (_cell$getValue = cell.getValue()) != null ? _cell$getValue : table.options.renderFallbackValue;\n  };\n  const cell = {\n    id: `${row.id}_${column.id}`,\n    row,\n    column,\n    getValue: () => row.getValue(columnId),\n    renderValue: getRenderValue,\n    getContext: memo(() => [table, column, row, cell], (table, column, row, cell) => ({\n      table,\n      column,\n      row,\n      cell: cell,\n      getValue: cell.getValue,\n      renderValue: cell.renderValue\n    }), getMemoOptions(table.options, 'debugCells', 'cell.getContext'))\n  };\n  table._features.forEach(feature => {\n    feature.createCell == null || feature.createCell(cell, column, row, table);\n  }, {});\n  return cell;\n}\n\nfunction createColumn(table, columnDef, depth, parent) {\n  var _ref, _resolvedColumnDef$id;\n  const defaultColumn = table._getDefaultColumnDef();\n  const resolvedColumnDef = {\n    ...defaultColumn,\n    ...columnDef\n  };\n  const accessorKey = resolvedColumnDef.accessorKey;\n  let id = (_ref = (_resolvedColumnDef$id = resolvedColumnDef.id) != null ? _resolvedColumnDef$id : accessorKey ? typeof String.prototype.replaceAll === 'function' ? accessorKey.replaceAll('.', '_') : accessorKey.replace(/\\./g, '_') : undefined) != null ? _ref : typeof resolvedColumnDef.header === 'string' ? resolvedColumnDef.header : undefined;\n  let accessorFn;\n  if (resolvedColumnDef.accessorFn) {\n    accessorFn = resolvedColumnDef.accessorFn;\n  } else if (accessorKey) {\n    // Support deep accessor keys\n    if (accessorKey.includes('.')) {\n      accessorFn = originalRow => {\n        let result = originalRow;\n        for (const key of accessorKey.split('.')) {\n          var _result;\n          result = (_result = result) == null ? void 0 : _result[key];\n          if ( true && result === undefined) {\n            console.warn(`\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`);\n          }\n        }\n        return result;\n      };\n    } else {\n      accessorFn = originalRow => originalRow[resolvedColumnDef.accessorKey];\n    }\n  }\n  if (!id) {\n    if (true) {\n      throw new Error(resolvedColumnDef.accessorFn ? `Columns require an id when using an accessorFn` : `Columns require an id when using a non-string header`);\n    }\n    throw new Error();\n  }\n  let column = {\n    id: `${String(id)}`,\n    accessorFn,\n    parent: parent,\n    depth,\n    columnDef: resolvedColumnDef,\n    columns: [],\n    getFlatColumns: memo(() => [true], () => {\n      var _column$columns;\n      return [column, ...((_column$columns = column.columns) == null ? void 0 : _column$columns.flatMap(d => d.getFlatColumns()))];\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getFlatColumns')),\n    getLeafColumns: memo(() => [table._getOrderColumnsFn()], orderColumns => {\n      var _column$columns2;\n      if ((_column$columns2 = column.columns) != null && _column$columns2.length) {\n        let leafColumns = column.columns.flatMap(column => column.getLeafColumns());\n        return orderColumns(leafColumns);\n      }\n      return [column];\n    }, getMemoOptions(table.options, 'debugColumns', 'column.getLeafColumns'))\n  };\n  for (const feature of table._features) {\n    feature.createColumn == null || feature.createColumn(column, table);\n  }\n\n  // Yes, we have to convert table to unknown, because we know more than the compiler here.\n  return column;\n}\n\nconst debug = 'debugHeaders';\n//\n\nfunction createHeader(table, column, options) {\n  var _options$id;\n  const id = (_options$id = options.id) != null ? _options$id : column.id;\n  let header = {\n    id,\n    column,\n    index: options.index,\n    isPlaceholder: !!options.isPlaceholder,\n    placeholderId: options.placeholderId,\n    depth: options.depth,\n    subHeaders: [],\n    colSpan: 0,\n    rowSpan: 0,\n    headerGroup: null,\n    getLeafHeaders: () => {\n      const leafHeaders = [];\n      const recurseHeader = h => {\n        if (h.subHeaders && h.subHeaders.length) {\n          h.subHeaders.map(recurseHeader);\n        }\n        leafHeaders.push(h);\n      };\n      recurseHeader(header);\n      return leafHeaders;\n    },\n    getContext: () => ({\n      table,\n      header: header,\n      column\n    })\n  };\n  table._features.forEach(feature => {\n    feature.createHeader == null || feature.createHeader(header, table);\n  });\n  return header;\n}\nconst Headers = {\n  createTable: table => {\n    // Header Groups\n\n    table.getHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n      var _left$map$filter, _right$map$filter;\n      const leftColumns = (_left$map$filter = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter : [];\n      const rightColumns = (_right$map$filter = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter : [];\n      const centerColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n      const headerGroups = buildHeaderGroups(allColumns, [...leftColumns, ...centerColumns, ...rightColumns], table);\n      return headerGroups;\n    }, getMemoOptions(table.options, debug, 'getHeaderGroups'));\n    table.getCenterHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, leafColumns, left, right) => {\n      leafColumns = leafColumns.filter(column => !(left != null && left.includes(column.id)) && !(right != null && right.includes(column.id)));\n      return buildHeaderGroups(allColumns, leafColumns, table, 'center');\n    }, getMemoOptions(table.options, debug, 'getCenterHeaderGroups'));\n    table.getLeftHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.left], (allColumns, leafColumns, left) => {\n      var _left$map$filter2;\n      const orderedLeafColumns = (_left$map$filter2 = left == null ? void 0 : left.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _left$map$filter2 : [];\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'left');\n    }, getMemoOptions(table.options, debug, 'getLeftHeaderGroups'));\n    table.getRightHeaderGroups = memo(() => [table.getAllColumns(), table.getVisibleLeafColumns(), table.getState().columnPinning.right], (allColumns, leafColumns, right) => {\n      var _right$map$filter2;\n      const orderedLeafColumns = (_right$map$filter2 = right == null ? void 0 : right.map(columnId => leafColumns.find(d => d.id === columnId)).filter(Boolean)) != null ? _right$map$filter2 : [];\n      return buildHeaderGroups(allColumns, orderedLeafColumns, table, 'right');\n    }, getMemoOptions(table.options, debug, 'getRightHeaderGroups'));\n\n    // Footer Groups\n\n    table.getFooterGroups = memo(() => [table.getHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getFooterGroups'));\n    table.getLeftFooterGroups = memo(() => [table.getLeftHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getLeftFooterGroups'));\n    table.getCenterFooterGroups = memo(() => [table.getCenterHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getCenterFooterGroups'));\n    table.getRightFooterGroups = memo(() => [table.getRightHeaderGroups()], headerGroups => {\n      return [...headerGroups].reverse();\n    }, getMemoOptions(table.options, debug, 'getRightFooterGroups'));\n\n    // Flat Headers\n\n    table.getFlatHeaders = memo(() => [table.getHeaderGroups()], headerGroups => {\n      return headerGroups.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getFlatHeaders'));\n    table.getLeftFlatHeaders = memo(() => [table.getLeftHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getLeftFlatHeaders'));\n    table.getCenterFlatHeaders = memo(() => [table.getCenterHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getCenterFlatHeaders'));\n    table.getRightFlatHeaders = memo(() => [table.getRightHeaderGroups()], left => {\n      return left.map(headerGroup => {\n        return headerGroup.headers;\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getRightFlatHeaders'));\n\n    // Leaf Headers\n\n    table.getCenterLeafHeaders = memo(() => [table.getCenterFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders;\n        return !((_header$subHeaders = header.subHeaders) != null && _header$subHeaders.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getCenterLeafHeaders'));\n    table.getLeftLeafHeaders = memo(() => [table.getLeftFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders2;\n        return !((_header$subHeaders2 = header.subHeaders) != null && _header$subHeaders2.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getLeftLeafHeaders'));\n    table.getRightLeafHeaders = memo(() => [table.getRightFlatHeaders()], flatHeaders => {\n      return flatHeaders.filter(header => {\n        var _header$subHeaders3;\n        return !((_header$subHeaders3 = header.subHeaders) != null && _header$subHeaders3.length);\n      });\n    }, getMemoOptions(table.options, debug, 'getRightLeafHeaders'));\n    table.getLeafHeaders = memo(() => [table.getLeftHeaderGroups(), table.getCenterHeaderGroups(), table.getRightHeaderGroups()], (left, center, right) => {\n      var _left$0$headers, _left$, _center$0$headers, _center$, _right$0$headers, _right$;\n      return [...((_left$0$headers = (_left$ = left[0]) == null ? void 0 : _left$.headers) != null ? _left$0$headers : []), ...((_center$0$headers = (_center$ = center[0]) == null ? void 0 : _center$.headers) != null ? _center$0$headers : []), ...((_right$0$headers = (_right$ = right[0]) == null ? void 0 : _right$.headers) != null ? _right$0$headers : [])].map(header => {\n        return header.getLeafHeaders();\n      }).flat();\n    }, getMemoOptions(table.options, debug, 'getLeafHeaders'));\n  }\n};\nfunction buildHeaderGroups(allColumns, columnsToGroup, table, headerFamily) {\n  var _headerGroups$0$heade, _headerGroups$;\n  // Find the max depth of the columns:\n  // build the leaf column row\n  // build each buffer row going up\n  //    placeholder for non-existent level\n  //    real column for existing level\n\n  let maxDepth = 0;\n  const findMaxDepth = function (columns, depth) {\n    if (depth === void 0) {\n      depth = 1;\n    }\n    maxDepth = Math.max(maxDepth, depth);\n    columns.filter(column => column.getIsVisible()).forEach(column => {\n      var _column$columns;\n      if ((_column$columns = column.columns) != null && _column$columns.length) {\n        findMaxDepth(column.columns, depth + 1);\n      }\n    }, 0);\n  };\n  findMaxDepth(allColumns);\n  let headerGroups = [];\n  const createHeaderGroup = (headersToGroup, depth) => {\n    // The header group we are creating\n    const headerGroup = {\n      depth,\n      id: [headerFamily, `${depth}`].filter(Boolean).join('_'),\n      headers: []\n    };\n\n    // The parent columns we're going to scan next\n    const pendingParentHeaders = [];\n\n    // Scan each column for parents\n    headersToGroup.forEach(headerToGroup => {\n      // What is the latest (last) parent column?\n\n      const latestPendingParentHeader = [...pendingParentHeaders].reverse()[0];\n      const isLeafHeader = headerToGroup.column.depth === headerGroup.depth;\n      let column;\n      let isPlaceholder = false;\n      if (isLeafHeader && headerToGroup.column.parent) {\n        // The parent header is new\n        column = headerToGroup.column.parent;\n      } else {\n        // The parent header is repeated\n        column = headerToGroup.column;\n        isPlaceholder = true;\n      }\n      if (latestPendingParentHeader && (latestPendingParentHeader == null ? void 0 : latestPendingParentHeader.column) === column) {\n        // This column is repeated. Add it as a sub header to the next batch\n        latestPendingParentHeader.subHeaders.push(headerToGroup);\n      } else {\n        // This is a new header. Let's create it\n        const header = createHeader(table, column, {\n          id: [headerFamily, depth, column.id, headerToGroup == null ? void 0 : headerToGroup.id].filter(Boolean).join('_'),\n          isPlaceholder,\n          placeholderId: isPlaceholder ? `${pendingParentHeaders.filter(d => d.column === column).length}` : undefined,\n          depth,\n          index: pendingParentHeaders.length\n        });\n\n        // Add the headerToGroup as a subHeader of the new header\n        header.subHeaders.push(headerToGroup);\n        // Add the new header to the pendingParentHeaders to get grouped\n        // in the next batch\n        pendingParentHeaders.push(header);\n      }\n      headerGroup.headers.push(headerToGroup);\n      headerToGroup.headerGroup = headerGroup;\n    });\n    headerGroups.push(headerGroup);\n    if (depth > 0) {\n      createHeaderGroup(pendingParentHeaders, depth - 1);\n    }\n  };\n  const bottomHeaders = columnsToGroup.map((column, index) => createHeader(table, column, {\n    depth: maxDepth,\n    index\n  }));\n  createHeaderGroup(bottomHeaders, maxDepth - 1);\n  headerGroups.reverse();\n\n  // headerGroups = headerGroups.filter(headerGroup => {\n  //   return !headerGroup.headers.every(header => header.isPlaceholder)\n  // })\n\n  const recurseHeadersForSpans = headers => {\n    const filteredHeaders = headers.filter(header => header.column.getIsVisible());\n    return filteredHeaders.map(header => {\n      let colSpan = 0;\n      let rowSpan = 0;\n      let childRowSpans = [0];\n      if (header.subHeaders && header.subHeaders.length) {\n        childRowSpans = [];\n        recurseHeadersForSpans(header.subHeaders).forEach(_ref => {\n          let {\n            colSpan: childColSpan,\n            rowSpan: childRowSpan\n          } = _ref;\n          colSpan += childColSpan;\n          childRowSpans.push(childRowSpan);\n        });\n      } else {\n        colSpan = 1;\n      }\n      const minChildRowSpan = Math.min(...childRowSpans);\n      rowSpan = rowSpan + minChildRowSpan;\n      header.colSpan = colSpan;\n      header.rowSpan = rowSpan;\n      return {\n        colSpan,\n        rowSpan\n      };\n    });\n  };\n  recurseHeadersForSpans((_headerGroups$0$heade = (_headerGroups$ = headerGroups[0]) == null ? void 0 : _headerGroups$.headers) != null ? _headerGroups$0$heade : []);\n  return headerGroups;\n}\n\nconst createRow = (table, id, original, rowIndex, depth, subRows, parentId) => {\n  let row = {\n    id,\n    index: rowIndex,\n    original,\n    depth,\n    parentId,\n    _valuesCache: {},\n    _uniqueValuesCache: {},\n    getValue: columnId => {\n      if (row._valuesCache.hasOwnProperty(columnId)) {\n        return row._valuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.accessorFn)) {\n        return undefined;\n      }\n      row._valuesCache[columnId] = column.accessorFn(row.original, rowIndex);\n      return row._valuesCache[columnId];\n    },\n    getUniqueValues: columnId => {\n      if (row._uniqueValuesCache.hasOwnProperty(columnId)) {\n        return row._uniqueValuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.accessorFn)) {\n        return undefined;\n      }\n      if (!column.columnDef.getUniqueValues) {\n        row._uniqueValuesCache[columnId] = [row.getValue(columnId)];\n        return row._uniqueValuesCache[columnId];\n      }\n      row._uniqueValuesCache[columnId] = column.columnDef.getUniqueValues(row.original, rowIndex);\n      return row._uniqueValuesCache[columnId];\n    },\n    renderValue: columnId => {\n      var _row$getValue;\n      return (_row$getValue = row.getValue(columnId)) != null ? _row$getValue : table.options.renderFallbackValue;\n    },\n    subRows: subRows != null ? subRows : [],\n    getLeafRows: () => flattenBy(row.subRows, d => d.subRows),\n    getParentRow: () => row.parentId ? table.getRow(row.parentId, true) : undefined,\n    getParentRows: () => {\n      let parentRows = [];\n      let currentRow = row;\n      while (true) {\n        const parentRow = currentRow.getParentRow();\n        if (!parentRow) break;\n        parentRows.push(parentRow);\n        currentRow = parentRow;\n      }\n      return parentRows.reverse();\n    },\n    getAllCells: memo(() => [table.getAllLeafColumns()], leafColumns => {\n      return leafColumns.map(column => {\n        return createCell(table, row, column, column.id);\n      });\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCells')),\n    _getAllCellsByColumnId: memo(() => [row.getAllCells()], allCells => {\n      return allCells.reduce((acc, cell) => {\n        acc[cell.column.id] = cell;\n        return acc;\n      }, {});\n    }, getMemoOptions(table.options, 'debugRows', 'getAllCellsByColumnId'))\n  };\n  for (let i = 0; i < table._features.length; i++) {\n    const feature = table._features[i];\n    feature == null || feature.createRow == null || feature.createRow(row, table);\n  }\n  return row;\n};\n\n//\n\nconst ColumnFaceting = {\n  createColumn: (column, table) => {\n    column._getFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, column.id);\n    column.getFacetedRowModel = () => {\n      if (!column._getFacetedRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return column._getFacetedRowModel();\n    };\n    column._getFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, column.id);\n    column.getFacetedUniqueValues = () => {\n      if (!column._getFacetedUniqueValues) {\n        return new Map();\n      }\n      return column._getFacetedUniqueValues();\n    };\n    column._getFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, column.id);\n    column.getFacetedMinMaxValues = () => {\n      if (!column._getFacetedMinMaxValues) {\n        return undefined;\n      }\n      return column._getFacetedMinMaxValues();\n    };\n  }\n};\n\nconst includesString = (row, columnId, filterValue) => {\n  var _filterValue$toString, _row$getValue;\n  const search = filterValue == null || (_filterValue$toString = filterValue.toString()) == null ? void 0 : _filterValue$toString.toLowerCase();\n  return Boolean((_row$getValue = row.getValue(columnId)) == null || (_row$getValue = _row$getValue.toString()) == null || (_row$getValue = _row$getValue.toLowerCase()) == null ? void 0 : _row$getValue.includes(search));\n};\nincludesString.autoRemove = val => testFalsey(val);\nconst includesStringSensitive = (row, columnId, filterValue) => {\n  var _row$getValue2;\n  return Boolean((_row$getValue2 = row.getValue(columnId)) == null || (_row$getValue2 = _row$getValue2.toString()) == null ? void 0 : _row$getValue2.includes(filterValue));\n};\nincludesStringSensitive.autoRemove = val => testFalsey(val);\nconst equalsString = (row, columnId, filterValue) => {\n  var _row$getValue3;\n  return ((_row$getValue3 = row.getValue(columnId)) == null || (_row$getValue3 = _row$getValue3.toString()) == null ? void 0 : _row$getValue3.toLowerCase()) === (filterValue == null ? void 0 : filterValue.toLowerCase());\n};\nequalsString.autoRemove = val => testFalsey(val);\nconst arrIncludes = (row, columnId, filterValue) => {\n  var _row$getValue4;\n  return (_row$getValue4 = row.getValue(columnId)) == null ? void 0 : _row$getValue4.includes(filterValue);\n};\narrIncludes.autoRemove = val => testFalsey(val);\nconst arrIncludesAll = (row, columnId, filterValue) => {\n  return !filterValue.some(val => {\n    var _row$getValue5;\n    return !((_row$getValue5 = row.getValue(columnId)) != null && _row$getValue5.includes(val));\n  });\n};\narrIncludesAll.autoRemove = val => testFalsey(val) || !(val != null && val.length);\nconst arrIncludesSome = (row, columnId, filterValue) => {\n  return filterValue.some(val => {\n    var _row$getValue6;\n    return (_row$getValue6 = row.getValue(columnId)) == null ? void 0 : _row$getValue6.includes(val);\n  });\n};\narrIncludesSome.autoRemove = val => testFalsey(val) || !(val != null && val.length);\nconst equals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) === filterValue;\n};\nequals.autoRemove = val => testFalsey(val);\nconst weakEquals = (row, columnId, filterValue) => {\n  return row.getValue(columnId) == filterValue;\n};\nweakEquals.autoRemove = val => testFalsey(val);\nconst inNumberRange = (row, columnId, filterValue) => {\n  let [min, max] = filterValue;\n  const rowValue = row.getValue(columnId);\n  return rowValue >= min && rowValue <= max;\n};\ninNumberRange.resolveFilterValue = val => {\n  let [unsafeMin, unsafeMax] = val;\n  let parsedMin = typeof unsafeMin !== 'number' ? parseFloat(unsafeMin) : unsafeMin;\n  let parsedMax = typeof unsafeMax !== 'number' ? parseFloat(unsafeMax) : unsafeMax;\n  let min = unsafeMin === null || Number.isNaN(parsedMin) ? -Infinity : parsedMin;\n  let max = unsafeMax === null || Number.isNaN(parsedMax) ? Infinity : parsedMax;\n  if (min > max) {\n    const temp = min;\n    min = max;\n    max = temp;\n  }\n  return [min, max];\n};\ninNumberRange.autoRemove = val => testFalsey(val) || testFalsey(val[0]) && testFalsey(val[1]);\n\n// Export\n\nconst filterFns = {\n  includesString,\n  includesStringSensitive,\n  equalsString,\n  arrIncludes,\n  arrIncludesAll,\n  arrIncludesSome,\n  equals,\n  weakEquals,\n  inNumberRange\n};\n// Utils\n\nfunction testFalsey(val) {\n  return val === undefined || val === null || val === '';\n}\n\n//\n\nconst ColumnFiltering = {\n  getDefaultColumnDef: () => {\n    return {\n      filterFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      columnFilters: [],\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnFiltersChange: makeStateUpdater('columnFilters', table),\n      filterFromLeafRows: false,\n      maxLeafRowFilterDepth: 100\n    };\n  },\n  createColumn: (column, table) => {\n    column.getAutoFilterFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'string') {\n        return filterFns.includesString;\n      }\n      if (typeof value === 'number') {\n        return filterFns.inNumberRange;\n      }\n      if (typeof value === 'boolean') {\n        return filterFns.equals;\n      }\n      if (value !== null && typeof value === 'object') {\n        return filterFns.equals;\n      }\n      if (Array.isArray(value)) {\n        return filterFns.arrIncludes;\n      }\n      return filterFns.weakEquals;\n    };\n    column.getFilterFn = () => {\n      var _table$options$filter, _table$options$filter2;\n      return isFunction(column.columnDef.filterFn) ? column.columnDef.filterFn : column.columnDef.filterFn === 'auto' ? column.getAutoFilterFn() : // @ts-ignore\n      (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[column.columnDef.filterFn]) != null ? _table$options$filter : filterFns[column.columnDef.filterFn];\n    };\n    column.getCanFilter = () => {\n      var _column$columnDef$ena, _table$options$enable, _table$options$enable2;\n      return ((_column$columnDef$ena = column.columnDef.enableColumnFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnFilters) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && !!column.accessorFn;\n    };\n    column.getIsFiltered = () => column.getFilterIndex() > -1;\n    column.getFilterValue = () => {\n      var _table$getState$colum;\n      return (_table$getState$colum = table.getState().columnFilters) == null || (_table$getState$colum = _table$getState$colum.find(d => d.id === column.id)) == null ? void 0 : _table$getState$colum.value;\n    };\n    column.getFilterIndex = () => {\n      var _table$getState$colum2, _table$getState$colum3;\n      return (_table$getState$colum2 = (_table$getState$colum3 = table.getState().columnFilters) == null ? void 0 : _table$getState$colum3.findIndex(d => d.id === column.id)) != null ? _table$getState$colum2 : -1;\n    };\n    column.setFilterValue = value => {\n      table.setColumnFilters(old => {\n        const filterFn = column.getFilterFn();\n        const previousFilter = old == null ? void 0 : old.find(d => d.id === column.id);\n        const newFilter = functionalUpdate(value, previousFilter ? previousFilter.value : undefined);\n\n        //\n        if (shouldAutoRemoveFilter(filterFn, newFilter, column)) {\n          var _old$filter;\n          return (_old$filter = old == null ? void 0 : old.filter(d => d.id !== column.id)) != null ? _old$filter : [];\n        }\n        const newFilterObj = {\n          id: column.id,\n          value: newFilter\n        };\n        if (previousFilter) {\n          var _old$map;\n          return (_old$map = old == null ? void 0 : old.map(d => {\n            if (d.id === column.id) {\n              return newFilterObj;\n            }\n            return d;\n          })) != null ? _old$map : [];\n        }\n        if (old != null && old.length) {\n          return [...old, newFilterObj];\n        }\n        return [newFilterObj];\n      });\n    };\n  },\n  createRow: (row, _table) => {\n    row.columnFilters = {};\n    row.columnFiltersMeta = {};\n  },\n  createTable: table => {\n    table.setColumnFilters = updater => {\n      const leafColumns = table.getAllLeafColumns();\n      const updateFn = old => {\n        var _functionalUpdate;\n        return (_functionalUpdate = functionalUpdate(updater, old)) == null ? void 0 : _functionalUpdate.filter(filter => {\n          const column = leafColumns.find(d => d.id === filter.id);\n          if (column) {\n            const filterFn = column.getFilterFn();\n            if (shouldAutoRemoveFilter(filterFn, filter.value, column)) {\n              return false;\n            }\n          }\n          return true;\n        });\n      };\n      table.options.onColumnFiltersChange == null || table.options.onColumnFiltersChange(updateFn);\n    };\n    table.resetColumnFilters = defaultState => {\n      var _table$initialState$c, _table$initialState;\n      table.setColumnFilters(defaultState ? [] : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnFilters) != null ? _table$initialState$c : []);\n    };\n    table.getPreFilteredRowModel = () => table.getCoreRowModel();\n    table.getFilteredRowModel = () => {\n      if (!table._getFilteredRowModel && table.options.getFilteredRowModel) {\n        table._getFilteredRowModel = table.options.getFilteredRowModel(table);\n      }\n      if (table.options.manualFiltering || !table._getFilteredRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return table._getFilteredRowModel();\n    };\n  }\n};\nfunction shouldAutoRemoveFilter(filterFn, value, column) {\n  return (filterFn && filterFn.autoRemove ? filterFn.autoRemove(value, column) : false) || typeof value === 'undefined' || typeof value === 'string' && !value;\n}\n\nconst sum = (columnId, _leafRows, childRows) => {\n  // It's faster to just add the aggregations together instead of\n  // process leaf nodes individually\n  return childRows.reduce((sum, next) => {\n    const nextValue = next.getValue(columnId);\n    return sum + (typeof nextValue === 'number' ? nextValue : 0);\n  }, 0);\n};\nconst min = (columnId, _leafRows, childRows) => {\n  let min;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null && (min > value || min === undefined && value >= value)) {\n      min = value;\n    }\n  });\n  return min;\n};\nconst max = (columnId, _leafRows, childRows) => {\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null && (max < value || max === undefined && value >= value)) {\n      max = value;\n    }\n  });\n  return max;\n};\nconst extent = (columnId, _leafRows, childRows) => {\n  let min;\n  let max;\n  childRows.forEach(row => {\n    const value = row.getValue(columnId);\n    if (value != null) {\n      if (min === undefined) {\n        if (value >= value) min = max = value;\n      } else {\n        if (min > value) min = value;\n        if (max < value) max = value;\n      }\n    }\n  });\n  return [min, max];\n};\nconst mean = (columnId, leafRows) => {\n  let count = 0;\n  let sum = 0;\n  leafRows.forEach(row => {\n    let value = row.getValue(columnId);\n    if (value != null && (value = +value) >= value) {\n      ++count, sum += value;\n    }\n  });\n  if (count) return sum / count;\n  return;\n};\nconst median = (columnId, leafRows) => {\n  if (!leafRows.length) {\n    return;\n  }\n  const values = leafRows.map(row => row.getValue(columnId));\n  if (!isNumberArray(values)) {\n    return;\n  }\n  if (values.length === 1) {\n    return values[0];\n  }\n  const mid = Math.floor(values.length / 2);\n  const nums = values.sort((a, b) => a - b);\n  return values.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;\n};\nconst unique = (columnId, leafRows) => {\n  return Array.from(new Set(leafRows.map(d => d.getValue(columnId))).values());\n};\nconst uniqueCount = (columnId, leafRows) => {\n  return new Set(leafRows.map(d => d.getValue(columnId))).size;\n};\nconst count = (_columnId, leafRows) => {\n  return leafRows.length;\n};\nconst aggregationFns = {\n  sum,\n  min,\n  max,\n  extent,\n  mean,\n  median,\n  unique,\n  uniqueCount,\n  count\n};\n\n//\n\nconst ColumnGrouping = {\n  getDefaultColumnDef: () => {\n    return {\n      aggregatedCell: props => {\n        var _toString, _props$getValue;\n        return (_toString = (_props$getValue = props.getValue()) == null || _props$getValue.toString == null ? void 0 : _props$getValue.toString()) != null ? _toString : null;\n      },\n      aggregationFn: 'auto'\n    };\n  },\n  getInitialState: state => {\n    return {\n      grouping: [],\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onGroupingChange: makeStateUpdater('grouping', table),\n      groupedColumnMode: 'reorder'\n    };\n  },\n  createColumn: (column, table) => {\n    column.toggleGrouping = () => {\n      table.setGrouping(old => {\n        // Find any existing grouping for this column\n        if (old != null && old.includes(column.id)) {\n          return old.filter(d => d !== column.id);\n        }\n        return [...(old != null ? old : []), column.id];\n      });\n    };\n    column.getCanGroup = () => {\n      var _column$columnDef$ena, _table$options$enable;\n      return ((_column$columnDef$ena = column.columnDef.enableGrouping) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGrouping) != null ? _table$options$enable : true) && (!!column.accessorFn || !!column.columnDef.getGroupingValue);\n    };\n    column.getIsGrouped = () => {\n      var _table$getState$group;\n      return (_table$getState$group = table.getState().grouping) == null ? void 0 : _table$getState$group.includes(column.id);\n    };\n    column.getGroupedIndex = () => {\n      var _table$getState$group2;\n      return (_table$getState$group2 = table.getState().grouping) == null ? void 0 : _table$getState$group2.indexOf(column.id);\n    };\n    column.getToggleGroupingHandler = () => {\n      const canGroup = column.getCanGroup();\n      return () => {\n        if (!canGroup) return;\n        column.toggleGrouping();\n      };\n    };\n    column.getAutoAggregationFn = () => {\n      const firstRow = table.getCoreRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'number') {\n        return aggregationFns.sum;\n      }\n      if (Object.prototype.toString.call(value) === '[object Date]') {\n        return aggregationFns.extent;\n      }\n    };\n    column.getAggregationFn = () => {\n      var _table$options$aggreg, _table$options$aggreg2;\n      if (!column) {\n        throw new Error();\n      }\n      return isFunction(column.columnDef.aggregationFn) ? column.columnDef.aggregationFn : column.columnDef.aggregationFn === 'auto' ? column.getAutoAggregationFn() : (_table$options$aggreg = (_table$options$aggreg2 = table.options.aggregationFns) == null ? void 0 : _table$options$aggreg2[column.columnDef.aggregationFn]) != null ? _table$options$aggreg : aggregationFns[column.columnDef.aggregationFn];\n    };\n  },\n  createTable: table => {\n    table.setGrouping = updater => table.options.onGroupingChange == null ? void 0 : table.options.onGroupingChange(updater);\n    table.resetGrouping = defaultState => {\n      var _table$initialState$g, _table$initialState;\n      table.setGrouping(defaultState ? [] : (_table$initialState$g = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.grouping) != null ? _table$initialState$g : []);\n    };\n    table.getPreGroupedRowModel = () => table.getFilteredRowModel();\n    table.getGroupedRowModel = () => {\n      if (!table._getGroupedRowModel && table.options.getGroupedRowModel) {\n        table._getGroupedRowModel = table.options.getGroupedRowModel(table);\n      }\n      if (table.options.manualGrouping || !table._getGroupedRowModel) {\n        return table.getPreGroupedRowModel();\n      }\n      return table._getGroupedRowModel();\n    };\n  },\n  createRow: (row, table) => {\n    row.getIsGrouped = () => !!row.groupingColumnId;\n    row.getGroupingValue = columnId => {\n      if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n        return row._groupingValuesCache[columnId];\n      }\n      const column = table.getColumn(columnId);\n      if (!(column != null && column.columnDef.getGroupingValue)) {\n        return row.getValue(columnId);\n      }\n      row._groupingValuesCache[columnId] = column.columnDef.getGroupingValue(row.original);\n      return row._groupingValuesCache[columnId];\n    };\n    row._groupingValuesCache = {};\n  },\n  createCell: (cell, column, row, table) => {\n    cell.getIsGrouped = () => column.getIsGrouped() && column.id === row.groupingColumnId;\n    cell.getIsPlaceholder = () => !cell.getIsGrouped() && column.getIsGrouped();\n    cell.getIsAggregated = () => {\n      var _row$subRows;\n      return !cell.getIsGrouped() && !cell.getIsPlaceholder() && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n    };\n  }\n};\nfunction orderColumns(leafColumns, grouping, groupedColumnMode) {\n  if (!(grouping != null && grouping.length) || !groupedColumnMode) {\n    return leafColumns;\n  }\n  const nonGroupingColumns = leafColumns.filter(col => !grouping.includes(col.id));\n  if (groupedColumnMode === 'remove') {\n    return nonGroupingColumns;\n  }\n  const groupingColumns = grouping.map(g => leafColumns.find(col => col.id === g)).filter(Boolean);\n  return [...groupingColumns, ...nonGroupingColumns];\n}\n\n//\n\nconst ColumnOrdering = {\n  getInitialState: state => {\n    return {\n      columnOrder: [],\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnOrderChange: makeStateUpdater('columnOrder', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.getIndex = memo(position => [_getVisibleLeafColumns(table, position)], columns => columns.findIndex(d => d.id === column.id), getMemoOptions(table.options, 'debugColumns', 'getIndex'));\n    column.getIsFirstColumn = position => {\n      var _columns$;\n      const columns = _getVisibleLeafColumns(table, position);\n      return ((_columns$ = columns[0]) == null ? void 0 : _columns$.id) === column.id;\n    };\n    column.getIsLastColumn = position => {\n      var _columns;\n      const columns = _getVisibleLeafColumns(table, position);\n      return ((_columns = columns[columns.length - 1]) == null ? void 0 : _columns.id) === column.id;\n    };\n  },\n  createTable: table => {\n    table.setColumnOrder = updater => table.options.onColumnOrderChange == null ? void 0 : table.options.onColumnOrderChange(updater);\n    table.resetColumnOrder = defaultState => {\n      var _table$initialState$c;\n      table.setColumnOrder(defaultState ? [] : (_table$initialState$c = table.initialState.columnOrder) != null ? _table$initialState$c : []);\n    };\n    table._getOrderColumnsFn = memo(() => [table.getState().columnOrder, table.getState().grouping, table.options.groupedColumnMode], (columnOrder, grouping, groupedColumnMode) => columns => {\n      // Sort grouped columns to the start of the column list\n      // before the headers are built\n      let orderedColumns = [];\n\n      // If there is no order, return the normal columns\n      if (!(columnOrder != null && columnOrder.length)) {\n        orderedColumns = columns;\n      } else {\n        const columnOrderCopy = [...columnOrder];\n\n        // If there is an order, make a copy of the columns\n        const columnsCopy = [...columns];\n\n        // And make a new ordered array of the columns\n\n        // Loop over the columns and place them in order into the new array\n        while (columnsCopy.length && columnOrderCopy.length) {\n          const targetColumnId = columnOrderCopy.shift();\n          const foundIndex = columnsCopy.findIndex(d => d.id === targetColumnId);\n          if (foundIndex > -1) {\n            orderedColumns.push(columnsCopy.splice(foundIndex, 1)[0]);\n          }\n        }\n\n        // If there are any columns left, add them to the end\n        orderedColumns = [...orderedColumns, ...columnsCopy];\n      }\n      return orderColumns(orderedColumns, grouping, groupedColumnMode);\n    }, getMemoOptions(table.options, 'debugTable', '_getOrderColumnsFn'));\n  }\n};\n\n//\n\nconst getDefaultColumnPinningState = () => ({\n  left: [],\n  right: []\n});\nconst ColumnPinning = {\n  getInitialState: state => {\n    return {\n      columnPinning: getDefaultColumnPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnPinningChange: makeStateUpdater('columnPinning', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.pin = position => {\n      const columnIds = column.getLeafColumns().map(d => d.id).filter(Boolean);\n      table.setColumnPinning(old => {\n        var _old$left3, _old$right3;\n        if (position === 'right') {\n          var _old$left, _old$right;\n          return {\n            left: ((_old$left = old == null ? void 0 : old.left) != null ? _old$left : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n            right: [...((_old$right = old == null ? void 0 : old.right) != null ? _old$right : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds]\n          };\n        }\n        if (position === 'left') {\n          var _old$left2, _old$right2;\n          return {\n            left: [...((_old$left2 = old == null ? void 0 : old.left) != null ? _old$left2 : []).filter(d => !(columnIds != null && columnIds.includes(d))), ...columnIds],\n            right: ((_old$right2 = old == null ? void 0 : old.right) != null ? _old$right2 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n          };\n        }\n        return {\n          left: ((_old$left3 = old == null ? void 0 : old.left) != null ? _old$left3 : []).filter(d => !(columnIds != null && columnIds.includes(d))),\n          right: ((_old$right3 = old == null ? void 0 : old.right) != null ? _old$right3 : []).filter(d => !(columnIds != null && columnIds.includes(d)))\n        };\n      });\n    };\n    column.getCanPin = () => {\n      const leafColumns = column.getLeafColumns();\n      return leafColumns.some(d => {\n        var _d$columnDef$enablePi, _ref, _table$options$enable;\n        return ((_d$columnDef$enablePi = d.columnDef.enablePinning) != null ? _d$columnDef$enablePi : true) && ((_ref = (_table$options$enable = table.options.enableColumnPinning) != null ? _table$options$enable : table.options.enablePinning) != null ? _ref : true);\n      });\n    };\n    column.getIsPinned = () => {\n      const leafColumnIds = column.getLeafColumns().map(d => d.id);\n      const {\n        left,\n        right\n      } = table.getState().columnPinning;\n      const isLeft = leafColumnIds.some(d => left == null ? void 0 : left.includes(d));\n      const isRight = leafColumnIds.some(d => right == null ? void 0 : right.includes(d));\n      return isLeft ? 'left' : isRight ? 'right' : false;\n    };\n    column.getPinnedIndex = () => {\n      var _table$getState$colum, _table$getState$colum2;\n      const position = column.getIsPinned();\n      return position ? (_table$getState$colum = (_table$getState$colum2 = table.getState().columnPinning) == null || (_table$getState$colum2 = _table$getState$colum2[position]) == null ? void 0 : _table$getState$colum2.indexOf(column.id)) != null ? _table$getState$colum : -1 : 0;\n    };\n  },\n  createRow: (row, table) => {\n    row.getCenterVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allCells, left, right) => {\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n      return allCells.filter(d => !leftAndRight.includes(d.column.id));\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterVisibleCells'));\n    row.getLeftVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.left], (allCells, left) => {\n      const cells = (left != null ? left : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\n        ...d,\n        position: 'left'\n      }));\n      return cells;\n    }, getMemoOptions(table.options, 'debugRows', 'getLeftVisibleCells'));\n    row.getRightVisibleCells = memo(() => [row._getAllVisibleCells(), table.getState().columnPinning.right], (allCells, right) => {\n      const cells = (right != null ? right : []).map(columnId => allCells.find(cell => cell.column.id === columnId)).filter(Boolean).map(d => ({\n        ...d,\n        position: 'right'\n      }));\n      return cells;\n    }, getMemoOptions(table.options, 'debugRows', 'getRightVisibleCells'));\n  },\n  createTable: table => {\n    table.setColumnPinning = updater => table.options.onColumnPinningChange == null ? void 0 : table.options.onColumnPinningChange(updater);\n    table.resetColumnPinning = defaultState => {\n      var _table$initialState$c, _table$initialState;\n      return table.setColumnPinning(defaultState ? getDefaultColumnPinningState() : (_table$initialState$c = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.columnPinning) != null ? _table$initialState$c : getDefaultColumnPinningState());\n    };\n    table.getIsSomeColumnsPinned = position => {\n      var _pinningState$positio;\n      const pinningState = table.getState().columnPinning;\n      if (!position) {\n        var _pinningState$left, _pinningState$right;\n        return Boolean(((_pinningState$left = pinningState.left) == null ? void 0 : _pinningState$left.length) || ((_pinningState$right = pinningState.right) == null ? void 0 : _pinningState$right.length));\n      }\n      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n    };\n    table.getLeftLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left], (allColumns, left) => {\n      return (left != null ? left : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n    }, getMemoOptions(table.options, 'debugColumns', 'getLeftLeafColumns'));\n    table.getRightLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.right], (allColumns, right) => {\n      return (right != null ? right : []).map(columnId => allColumns.find(column => column.id === columnId)).filter(Boolean);\n    }, getMemoOptions(table.options, 'debugColumns', 'getRightLeafColumns'));\n    table.getCenterLeafColumns = memo(() => [table.getAllLeafColumns(), table.getState().columnPinning.left, table.getState().columnPinning.right], (allColumns, left, right) => {\n      const leftAndRight = [...(left != null ? left : []), ...(right != null ? right : [])];\n      return allColumns.filter(d => !leftAndRight.includes(d.id));\n    }, getMemoOptions(table.options, 'debugColumns', 'getCenterLeafColumns'));\n  }\n};\n\nfunction safelyAccessDocument(_document) {\n  return _document || (typeof document !== 'undefined' ? document : null);\n}\n\n//\n\n//\n\nconst defaultColumnSizing = {\n  size: 150,\n  minSize: 20,\n  maxSize: Number.MAX_SAFE_INTEGER\n};\nconst getDefaultColumnSizingInfoState = () => ({\n  startOffset: null,\n  startSize: null,\n  deltaOffset: null,\n  deltaPercentage: null,\n  isResizingColumn: false,\n  columnSizingStart: []\n});\nconst ColumnSizing = {\n  getDefaultColumnDef: () => {\n    return defaultColumnSizing;\n  },\n  getInitialState: state => {\n    return {\n      columnSizing: {},\n      columnSizingInfo: getDefaultColumnSizingInfoState(),\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      columnResizeMode: 'onEnd',\n      columnResizeDirection: 'ltr',\n      onColumnSizingChange: makeStateUpdater('columnSizing', table),\n      onColumnSizingInfoChange: makeStateUpdater('columnSizingInfo', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.getSize = () => {\n      var _column$columnDef$min, _ref, _column$columnDef$max;\n      const columnSize = table.getState().columnSizing[column.id];\n      return Math.min(Math.max((_column$columnDef$min = column.columnDef.minSize) != null ? _column$columnDef$min : defaultColumnSizing.minSize, (_ref = columnSize != null ? columnSize : column.columnDef.size) != null ? _ref : defaultColumnSizing.size), (_column$columnDef$max = column.columnDef.maxSize) != null ? _column$columnDef$max : defaultColumnSizing.maxSize);\n    };\n    column.getStart = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(0, column.getIndex(position)).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getStart'));\n    column.getAfter = memo(position => [position, _getVisibleLeafColumns(table, position), table.getState().columnSizing], (position, columns) => columns.slice(column.getIndex(position) + 1).reduce((sum, column) => sum + column.getSize(), 0), getMemoOptions(table.options, 'debugColumns', 'getAfter'));\n    column.resetSize = () => {\n      table.setColumnSizing(_ref2 => {\n        let {\n          [column.id]: _,\n          ...rest\n        } = _ref2;\n        return rest;\n      });\n    };\n    column.getCanResize = () => {\n      var _column$columnDef$ena, _table$options$enable;\n      return ((_column$columnDef$ena = column.columnDef.enableResizing) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableColumnResizing) != null ? _table$options$enable : true);\n    };\n    column.getIsResizing = () => {\n      return table.getState().columnSizingInfo.isResizingColumn === column.id;\n    };\n  },\n  createHeader: (header, table) => {\n    header.getSize = () => {\n      let sum = 0;\n      const recurse = header => {\n        if (header.subHeaders.length) {\n          header.subHeaders.forEach(recurse);\n        } else {\n          var _header$column$getSiz;\n          sum += (_header$column$getSiz = header.column.getSize()) != null ? _header$column$getSiz : 0;\n        }\n      };\n      recurse(header);\n      return sum;\n    };\n    header.getStart = () => {\n      if (header.index > 0) {\n        const prevSiblingHeader = header.headerGroup.headers[header.index - 1];\n        return prevSiblingHeader.getStart() + prevSiblingHeader.getSize();\n      }\n      return 0;\n    };\n    header.getResizeHandler = _contextDocument => {\n      const column = table.getColumn(header.column.id);\n      const canResize = column == null ? void 0 : column.getCanResize();\n      return e => {\n        if (!column || !canResize) {\n          return;\n        }\n        e.persist == null || e.persist();\n        if (isTouchStartEvent(e)) {\n          // lets not respond to multiple touches (e.g. 2 or 3 fingers)\n          if (e.touches && e.touches.length > 1) {\n            return;\n          }\n        }\n        const startSize = header.getSize();\n        const columnSizingStart = header ? header.getLeafHeaders().map(d => [d.column.id, d.column.getSize()]) : [[column.id, column.getSize()]];\n        const clientX = isTouchStartEvent(e) ? Math.round(e.touches[0].clientX) : e.clientX;\n        const newColumnSizing = {};\n        const updateOffset = (eventType, clientXPos) => {\n          if (typeof clientXPos !== 'number') {\n            return;\n          }\n          table.setColumnSizingInfo(old => {\n            var _old$startOffset, _old$startSize;\n            const deltaDirection = table.options.columnResizeDirection === 'rtl' ? -1 : 1;\n            const deltaOffset = (clientXPos - ((_old$startOffset = old == null ? void 0 : old.startOffset) != null ? _old$startOffset : 0)) * deltaDirection;\n            const deltaPercentage = Math.max(deltaOffset / ((_old$startSize = old == null ? void 0 : old.startSize) != null ? _old$startSize : 0), -0.999999);\n            old.columnSizingStart.forEach(_ref3 => {\n              let [columnId, headerSize] = _ref3;\n              newColumnSizing[columnId] = Math.round(Math.max(headerSize + headerSize * deltaPercentage, 0) * 100) / 100;\n            });\n            return {\n              ...old,\n              deltaOffset,\n              deltaPercentage\n            };\n          });\n          if (table.options.columnResizeMode === 'onChange' || eventType === 'end') {\n            table.setColumnSizing(old => ({\n              ...old,\n              ...newColumnSizing\n            }));\n          }\n        };\n        const onMove = clientXPos => updateOffset('move', clientXPos);\n        const onEnd = clientXPos => {\n          updateOffset('end', clientXPos);\n          table.setColumnSizingInfo(old => ({\n            ...old,\n            isResizingColumn: false,\n            startOffset: null,\n            startSize: null,\n            deltaOffset: null,\n            deltaPercentage: null,\n            columnSizingStart: []\n          }));\n        };\n        const contextDocument = safelyAccessDocument(_contextDocument);\n        const mouseEvents = {\n          moveHandler: e => onMove(e.clientX),\n          upHandler: e => {\n            contextDocument == null || contextDocument.removeEventListener('mousemove', mouseEvents.moveHandler);\n            contextDocument == null || contextDocument.removeEventListener('mouseup', mouseEvents.upHandler);\n            onEnd(e.clientX);\n          }\n        };\n        const touchEvents = {\n          moveHandler: e => {\n            if (e.cancelable) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n            onMove(e.touches[0].clientX);\n            return false;\n          },\n          upHandler: e => {\n            var _e$touches$;\n            contextDocument == null || contextDocument.removeEventListener('touchmove', touchEvents.moveHandler);\n            contextDocument == null || contextDocument.removeEventListener('touchend', touchEvents.upHandler);\n            if (e.cancelable) {\n              e.preventDefault();\n              e.stopPropagation();\n            }\n            onEnd((_e$touches$ = e.touches[0]) == null ? void 0 : _e$touches$.clientX);\n          }\n        };\n        const passiveIfSupported = passiveEventSupported() ? {\n          passive: false\n        } : false;\n        if (isTouchStartEvent(e)) {\n          contextDocument == null || contextDocument.addEventListener('touchmove', touchEvents.moveHandler, passiveIfSupported);\n          contextDocument == null || contextDocument.addEventListener('touchend', touchEvents.upHandler, passiveIfSupported);\n        } else {\n          contextDocument == null || contextDocument.addEventListener('mousemove', mouseEvents.moveHandler, passiveIfSupported);\n          contextDocument == null || contextDocument.addEventListener('mouseup', mouseEvents.upHandler, passiveIfSupported);\n        }\n        table.setColumnSizingInfo(old => ({\n          ...old,\n          startOffset: clientX,\n          startSize,\n          deltaOffset: 0,\n          deltaPercentage: 0,\n          columnSizingStart,\n          isResizingColumn: column.id\n        }));\n      };\n    };\n  },\n  createTable: table => {\n    table.setColumnSizing = updater => table.options.onColumnSizingChange == null ? void 0 : table.options.onColumnSizingChange(updater);\n    table.setColumnSizingInfo = updater => table.options.onColumnSizingInfoChange == null ? void 0 : table.options.onColumnSizingInfoChange(updater);\n    table.resetColumnSizing = defaultState => {\n      var _table$initialState$c;\n      table.setColumnSizing(defaultState ? {} : (_table$initialState$c = table.initialState.columnSizing) != null ? _table$initialState$c : {});\n    };\n    table.resetHeaderSizeInfo = defaultState => {\n      var _table$initialState$c2;\n      table.setColumnSizingInfo(defaultState ? getDefaultColumnSizingInfoState() : (_table$initialState$c2 = table.initialState.columnSizingInfo) != null ? _table$initialState$c2 : getDefaultColumnSizingInfoState());\n    };\n    table.getTotalSize = () => {\n      var _table$getHeaderGroup, _table$getHeaderGroup2;\n      return (_table$getHeaderGroup = (_table$getHeaderGroup2 = table.getHeaderGroups()[0]) == null ? void 0 : _table$getHeaderGroup2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getHeaderGroup : 0;\n    };\n    table.getLeftTotalSize = () => {\n      var _table$getLeftHeaderG, _table$getLeftHeaderG2;\n      return (_table$getLeftHeaderG = (_table$getLeftHeaderG2 = table.getLeftHeaderGroups()[0]) == null ? void 0 : _table$getLeftHeaderG2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getLeftHeaderG : 0;\n    };\n    table.getCenterTotalSize = () => {\n      var _table$getCenterHeade, _table$getCenterHeade2;\n      return (_table$getCenterHeade = (_table$getCenterHeade2 = table.getCenterHeaderGroups()[0]) == null ? void 0 : _table$getCenterHeade2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getCenterHeade : 0;\n    };\n    table.getRightTotalSize = () => {\n      var _table$getRightHeader, _table$getRightHeader2;\n      return (_table$getRightHeader = (_table$getRightHeader2 = table.getRightHeaderGroups()[0]) == null ? void 0 : _table$getRightHeader2.headers.reduce((sum, header) => {\n        return sum + header.getSize();\n      }, 0)) != null ? _table$getRightHeader : 0;\n    };\n  }\n};\nlet passiveSupported = null;\nfunction passiveEventSupported() {\n  if (typeof passiveSupported === 'boolean') return passiveSupported;\n  let supported = false;\n  try {\n    const options = {\n      get passive() {\n        supported = true;\n        return false;\n      }\n    };\n    const noop = () => {};\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop);\n  } catch (err) {\n    supported = false;\n  }\n  passiveSupported = supported;\n  return passiveSupported;\n}\nfunction isTouchStartEvent(e) {\n  return e.type === 'touchstart';\n}\n\n//\n\nconst ColumnVisibility = {\n  getInitialState: state => {\n    return {\n      columnVisibility: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onColumnVisibilityChange: makeStateUpdater('columnVisibility', table)\n    };\n  },\n  createColumn: (column, table) => {\n    column.toggleVisibility = value => {\n      if (column.getCanHide()) {\n        table.setColumnVisibility(old => ({\n          ...old,\n          [column.id]: value != null ? value : !column.getIsVisible()\n        }));\n      }\n    };\n    column.getIsVisible = () => {\n      var _ref, _table$getState$colum;\n      const childColumns = column.columns;\n      return (_ref = childColumns.length ? childColumns.some(c => c.getIsVisible()) : (_table$getState$colum = table.getState().columnVisibility) == null ? void 0 : _table$getState$colum[column.id]) != null ? _ref : true;\n    };\n    column.getCanHide = () => {\n      var _column$columnDef$ena, _table$options$enable;\n      return ((_column$columnDef$ena = column.columnDef.enableHiding) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableHiding) != null ? _table$options$enable : true);\n    };\n    column.getToggleVisibilityHandler = () => {\n      return e => {\n        column.toggleVisibility == null || column.toggleVisibility(e.target.checked);\n      };\n    };\n  },\n  createRow: (row, table) => {\n    row._getAllVisibleCells = memo(() => [row.getAllCells(), table.getState().columnVisibility], cells => {\n      return cells.filter(cell => cell.column.getIsVisible());\n    }, getMemoOptions(table.options, 'debugRows', '_getAllVisibleCells'));\n    row.getVisibleCells = memo(() => [row.getLeftVisibleCells(), row.getCenterVisibleCells(), row.getRightVisibleCells()], (left, center, right) => [...left, ...center, ...right], getMemoOptions(table.options, 'debugRows', 'getVisibleCells'));\n  },\n  createTable: table => {\n    const makeVisibleColumnsMethod = (key, getColumns) => {\n      return memo(() => [getColumns(), getColumns().filter(d => d.getIsVisible()).map(d => d.id).join('_')], columns => {\n        return columns.filter(d => d.getIsVisible == null ? void 0 : d.getIsVisible());\n      }, getMemoOptions(table.options, 'debugColumns', key));\n    };\n    table.getVisibleFlatColumns = makeVisibleColumnsMethod('getVisibleFlatColumns', () => table.getAllFlatColumns());\n    table.getVisibleLeafColumns = makeVisibleColumnsMethod('getVisibleLeafColumns', () => table.getAllLeafColumns());\n    table.getLeftVisibleLeafColumns = makeVisibleColumnsMethod('getLeftVisibleLeafColumns', () => table.getLeftLeafColumns());\n    table.getRightVisibleLeafColumns = makeVisibleColumnsMethod('getRightVisibleLeafColumns', () => table.getRightLeafColumns());\n    table.getCenterVisibleLeafColumns = makeVisibleColumnsMethod('getCenterVisibleLeafColumns', () => table.getCenterLeafColumns());\n    table.setColumnVisibility = updater => table.options.onColumnVisibilityChange == null ? void 0 : table.options.onColumnVisibilityChange(updater);\n    table.resetColumnVisibility = defaultState => {\n      var _table$initialState$c;\n      table.setColumnVisibility(defaultState ? {} : (_table$initialState$c = table.initialState.columnVisibility) != null ? _table$initialState$c : {});\n    };\n    table.toggleAllColumnsVisible = value => {\n      var _value;\n      value = (_value = value) != null ? _value : !table.getIsAllColumnsVisible();\n      table.setColumnVisibility(table.getAllLeafColumns().reduce((obj, column) => ({\n        ...obj,\n        [column.id]: !value ? !(column.getCanHide != null && column.getCanHide()) : value\n      }), {}));\n    };\n    table.getIsAllColumnsVisible = () => !table.getAllLeafColumns().some(column => !(column.getIsVisible != null && column.getIsVisible()));\n    table.getIsSomeColumnsVisible = () => table.getAllLeafColumns().some(column => column.getIsVisible == null ? void 0 : column.getIsVisible());\n    table.getToggleAllColumnsVisibilityHandler = () => {\n      return e => {\n        var _target;\n        table.toggleAllColumnsVisible((_target = e.target) == null ? void 0 : _target.checked);\n      };\n    };\n  }\n};\nfunction _getVisibleLeafColumns(table, position) {\n  return !position ? table.getVisibleLeafColumns() : position === 'center' ? table.getCenterVisibleLeafColumns() : position === 'left' ? table.getLeftVisibleLeafColumns() : table.getRightVisibleLeafColumns();\n}\n\n//\n\nconst GlobalFaceting = {\n  createTable: table => {\n    table._getGlobalFacetedRowModel = table.options.getFacetedRowModel && table.options.getFacetedRowModel(table, '__global__');\n    table.getGlobalFacetedRowModel = () => {\n      if (table.options.manualFiltering || !table._getGlobalFacetedRowModel) {\n        return table.getPreFilteredRowModel();\n      }\n      return table._getGlobalFacetedRowModel();\n    };\n    table._getGlobalFacetedUniqueValues = table.options.getFacetedUniqueValues && table.options.getFacetedUniqueValues(table, '__global__');\n    table.getGlobalFacetedUniqueValues = () => {\n      if (!table._getGlobalFacetedUniqueValues) {\n        return new Map();\n      }\n      return table._getGlobalFacetedUniqueValues();\n    };\n    table._getGlobalFacetedMinMaxValues = table.options.getFacetedMinMaxValues && table.options.getFacetedMinMaxValues(table, '__global__');\n    table.getGlobalFacetedMinMaxValues = () => {\n      if (!table._getGlobalFacetedMinMaxValues) {\n        return;\n      }\n      return table._getGlobalFacetedMinMaxValues();\n    };\n  }\n};\n\n//\n\nconst GlobalFiltering = {\n  getInitialState: state => {\n    return {\n      globalFilter: undefined,\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onGlobalFilterChange: makeStateUpdater('globalFilter', table),\n      globalFilterFn: 'auto',\n      getColumnCanGlobalFilter: column => {\n        var _table$getCoreRowMode;\n        const value = (_table$getCoreRowMode = table.getCoreRowModel().flatRows[0]) == null || (_table$getCoreRowMode = _table$getCoreRowMode._getAllCellsByColumnId()[column.id]) == null ? void 0 : _table$getCoreRowMode.getValue();\n        return typeof value === 'string' || typeof value === 'number';\n      }\n    };\n  },\n  createColumn: (column, table) => {\n    column.getCanGlobalFilter = () => {\n      var _column$columnDef$ena, _table$options$enable, _table$options$enable2, _table$options$getCol;\n      return ((_column$columnDef$ena = column.columnDef.enableGlobalFilter) != null ? _column$columnDef$ena : true) && ((_table$options$enable = table.options.enableGlobalFilter) != null ? _table$options$enable : true) && ((_table$options$enable2 = table.options.enableFilters) != null ? _table$options$enable2 : true) && ((_table$options$getCol = table.options.getColumnCanGlobalFilter == null ? void 0 : table.options.getColumnCanGlobalFilter(column)) != null ? _table$options$getCol : true) && !!column.accessorFn;\n    };\n  },\n  createTable: table => {\n    table.getGlobalAutoFilterFn = () => {\n      return filterFns.includesString;\n    };\n    table.getGlobalFilterFn = () => {\n      var _table$options$filter, _table$options$filter2;\n      const {\n        globalFilterFn: globalFilterFn\n      } = table.options;\n      return isFunction(globalFilterFn) ? globalFilterFn : globalFilterFn === 'auto' ? table.getGlobalAutoFilterFn() : (_table$options$filter = (_table$options$filter2 = table.options.filterFns) == null ? void 0 : _table$options$filter2[globalFilterFn]) != null ? _table$options$filter : filterFns[globalFilterFn];\n    };\n    table.setGlobalFilter = updater => {\n      table.options.onGlobalFilterChange == null || table.options.onGlobalFilterChange(updater);\n    };\n    table.resetGlobalFilter = defaultState => {\n      table.setGlobalFilter(defaultState ? undefined : table.initialState.globalFilter);\n    };\n  }\n};\n\n//\n\nconst RowExpanding = {\n  getInitialState: state => {\n    return {\n      expanded: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onExpandedChange: makeStateUpdater('expanded', table),\n      paginateExpandedRows: true\n    };\n  },\n  createTable: table => {\n    let registered = false;\n    let queued = false;\n    table._autoResetExpanded = () => {\n      var _ref, _table$options$autoRe;\n      if (!registered) {\n        table._queue(() => {\n          registered = true;\n        });\n        return;\n      }\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetExpanded) != null ? _ref : !table.options.manualExpanding) {\n        if (queued) return;\n        queued = true;\n        table._queue(() => {\n          table.resetExpanded();\n          queued = false;\n        });\n      }\n    };\n    table.setExpanded = updater => table.options.onExpandedChange == null ? void 0 : table.options.onExpandedChange(updater);\n    table.toggleAllRowsExpanded = expanded => {\n      if (expanded != null ? expanded : !table.getIsAllRowsExpanded()) {\n        table.setExpanded(true);\n      } else {\n        table.setExpanded({});\n      }\n    };\n    table.resetExpanded = defaultState => {\n      var _table$initialState$e, _table$initialState;\n      table.setExpanded(defaultState ? {} : (_table$initialState$e = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.expanded) != null ? _table$initialState$e : {});\n    };\n    table.getCanSomeRowsExpand = () => {\n      return table.getPrePaginationRowModel().flatRows.some(row => row.getCanExpand());\n    };\n    table.getToggleAllRowsExpandedHandler = () => {\n      return e => {\n        e.persist == null || e.persist();\n        table.toggleAllRowsExpanded();\n      };\n    };\n    table.getIsSomeRowsExpanded = () => {\n      const expanded = table.getState().expanded;\n      return expanded === true || Object.values(expanded).some(Boolean);\n    };\n    table.getIsAllRowsExpanded = () => {\n      const expanded = table.getState().expanded;\n\n      // If expanded is true, save some cycles and return true\n      if (typeof expanded === 'boolean') {\n        return expanded === true;\n      }\n      if (!Object.keys(expanded).length) {\n        return false;\n      }\n\n      // If any row is not expanded, return false\n      if (table.getRowModel().flatRows.some(row => !row.getIsExpanded())) {\n        return false;\n      }\n\n      // They must all be expanded :shrug:\n      return true;\n    };\n    table.getExpandedDepth = () => {\n      let maxDepth = 0;\n      const rowIds = table.getState().expanded === true ? Object.keys(table.getRowModel().rowsById) : Object.keys(table.getState().expanded);\n      rowIds.forEach(id => {\n        const splitId = id.split('.');\n        maxDepth = Math.max(maxDepth, splitId.length);\n      });\n      return maxDepth;\n    };\n    table.getPreExpandedRowModel = () => table.getSortedRowModel();\n    table.getExpandedRowModel = () => {\n      if (!table._getExpandedRowModel && table.options.getExpandedRowModel) {\n        table._getExpandedRowModel = table.options.getExpandedRowModel(table);\n      }\n      if (table.options.manualExpanding || !table._getExpandedRowModel) {\n        return table.getPreExpandedRowModel();\n      }\n      return table._getExpandedRowModel();\n    };\n  },\n  createRow: (row, table) => {\n    row.toggleExpanded = expanded => {\n      table.setExpanded(old => {\n        var _expanded;\n        const exists = old === true ? true : !!(old != null && old[row.id]);\n        let oldExpanded = {};\n        if (old === true) {\n          Object.keys(table.getRowModel().rowsById).forEach(rowId => {\n            oldExpanded[rowId] = true;\n          });\n        } else {\n          oldExpanded = old;\n        }\n        expanded = (_expanded = expanded) != null ? _expanded : !exists;\n        if (!exists && expanded) {\n          return {\n            ...oldExpanded,\n            [row.id]: true\n          };\n        }\n        if (exists && !expanded) {\n          const {\n            [row.id]: _,\n            ...rest\n          } = oldExpanded;\n          return rest;\n        }\n        return old;\n      });\n    };\n    row.getIsExpanded = () => {\n      var _table$options$getIsR;\n      const expanded = table.getState().expanded;\n      return !!((_table$options$getIsR = table.options.getIsRowExpanded == null ? void 0 : table.options.getIsRowExpanded(row)) != null ? _table$options$getIsR : expanded === true || (expanded == null ? void 0 : expanded[row.id]));\n    };\n    row.getCanExpand = () => {\n      var _table$options$getRow, _table$options$enable, _row$subRows;\n      return (_table$options$getRow = table.options.getRowCanExpand == null ? void 0 : table.options.getRowCanExpand(row)) != null ? _table$options$getRow : ((_table$options$enable = table.options.enableExpanding) != null ? _table$options$enable : true) && !!((_row$subRows = row.subRows) != null && _row$subRows.length);\n    };\n    row.getIsAllParentsExpanded = () => {\n      let isFullyExpanded = true;\n      let currentRow = row;\n      while (isFullyExpanded && currentRow.parentId) {\n        currentRow = table.getRow(currentRow.parentId, true);\n        isFullyExpanded = currentRow.getIsExpanded();\n      }\n      return isFullyExpanded;\n    };\n    row.getToggleExpandedHandler = () => {\n      const canExpand = row.getCanExpand();\n      return () => {\n        if (!canExpand) return;\n        row.toggleExpanded();\n      };\n    };\n  }\n};\n\n//\n\nconst defaultPageIndex = 0;\nconst defaultPageSize = 10;\nconst getDefaultPaginationState = () => ({\n  pageIndex: defaultPageIndex,\n  pageSize: defaultPageSize\n});\nconst RowPagination = {\n  getInitialState: state => {\n    return {\n      ...state,\n      pagination: {\n        ...getDefaultPaginationState(),\n        ...(state == null ? void 0 : state.pagination)\n      }\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onPaginationChange: makeStateUpdater('pagination', table)\n    };\n  },\n  createTable: table => {\n    let registered = false;\n    let queued = false;\n    table._autoResetPageIndex = () => {\n      var _ref, _table$options$autoRe;\n      if (!registered) {\n        table._queue(() => {\n          registered = true;\n        });\n        return;\n      }\n      if ((_ref = (_table$options$autoRe = table.options.autoResetAll) != null ? _table$options$autoRe : table.options.autoResetPageIndex) != null ? _ref : !table.options.manualPagination) {\n        if (queued) return;\n        queued = true;\n        table._queue(() => {\n          table.resetPageIndex();\n          queued = false;\n        });\n      }\n    };\n    table.setPagination = updater => {\n      const safeUpdater = old => {\n        let newState = functionalUpdate(updater, old);\n        return newState;\n      };\n      return table.options.onPaginationChange == null ? void 0 : table.options.onPaginationChange(safeUpdater);\n    };\n    table.resetPagination = defaultState => {\n      var _table$initialState$p;\n      table.setPagination(defaultState ? getDefaultPaginationState() : (_table$initialState$p = table.initialState.pagination) != null ? _table$initialState$p : getDefaultPaginationState());\n    };\n    table.setPageIndex = updater => {\n      table.setPagination(old => {\n        let pageIndex = functionalUpdate(updater, old.pageIndex);\n        const maxPageIndex = typeof table.options.pageCount === 'undefined' || table.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : table.options.pageCount - 1;\n        pageIndex = Math.max(0, Math.min(pageIndex, maxPageIndex));\n        return {\n          ...old,\n          pageIndex\n        };\n      });\n    };\n    table.resetPageIndex = defaultState => {\n      var _table$initialState$p2, _table$initialState;\n      table.setPageIndex(defaultState ? defaultPageIndex : (_table$initialState$p2 = (_table$initialState = table.initialState) == null || (_table$initialState = _table$initialState.pagination) == null ? void 0 : _table$initialState.pageIndex) != null ? _table$initialState$p2 : defaultPageIndex);\n    };\n    table.resetPageSize = defaultState => {\n      var _table$initialState$p3, _table$initialState2;\n      table.setPageSize(defaultState ? defaultPageSize : (_table$initialState$p3 = (_table$initialState2 = table.initialState) == null || (_table$initialState2 = _table$initialState2.pagination) == null ? void 0 : _table$initialState2.pageSize) != null ? _table$initialState$p3 : defaultPageSize);\n    };\n    table.setPageSize = updater => {\n      table.setPagination(old => {\n        const pageSize = Math.max(1, functionalUpdate(updater, old.pageSize));\n        const topRowIndex = old.pageSize * old.pageIndex;\n        const pageIndex = Math.floor(topRowIndex / pageSize);\n        return {\n          ...old,\n          pageIndex,\n          pageSize\n        };\n      });\n    };\n    //deprecated\n    table.setPageCount = updater => table.setPagination(old => {\n      var _table$options$pageCo;\n      let newPageCount = functionalUpdate(updater, (_table$options$pageCo = table.options.pageCount) != null ? _table$options$pageCo : -1);\n      if (typeof newPageCount === 'number') {\n        newPageCount = Math.max(-1, newPageCount);\n      }\n      return {\n        ...old,\n        pageCount: newPageCount\n      };\n    });\n    table.getPageOptions = memo(() => [table.getPageCount()], pageCount => {\n      let pageOptions = [];\n      if (pageCount && pageCount > 0) {\n        pageOptions = [...new Array(pageCount)].fill(null).map((_, i) => i);\n      }\n      return pageOptions;\n    }, getMemoOptions(table.options, 'debugTable', 'getPageOptions'));\n    table.getCanPreviousPage = () => table.getState().pagination.pageIndex > 0;\n    table.getCanNextPage = () => {\n      const {\n        pageIndex\n      } = table.getState().pagination;\n      const pageCount = table.getPageCount();\n      if (pageCount === -1) {\n        return true;\n      }\n      if (pageCount === 0) {\n        return false;\n      }\n      return pageIndex < pageCount - 1;\n    };\n    table.previousPage = () => {\n      return table.setPageIndex(old => old - 1);\n    };\n    table.nextPage = () => {\n      return table.setPageIndex(old => {\n        return old + 1;\n      });\n    };\n    table.firstPage = () => {\n      return table.setPageIndex(0);\n    };\n    table.lastPage = () => {\n      return table.setPageIndex(table.getPageCount() - 1);\n    };\n    table.getPrePaginationRowModel = () => table.getExpandedRowModel();\n    table.getPaginationRowModel = () => {\n      if (!table._getPaginationRowModel && table.options.getPaginationRowModel) {\n        table._getPaginationRowModel = table.options.getPaginationRowModel(table);\n      }\n      if (table.options.manualPagination || !table._getPaginationRowModel) {\n        return table.getPrePaginationRowModel();\n      }\n      return table._getPaginationRowModel();\n    };\n    table.getPageCount = () => {\n      var _table$options$pageCo2;\n      return (_table$options$pageCo2 = table.options.pageCount) != null ? _table$options$pageCo2 : Math.ceil(table.getRowCount() / table.getState().pagination.pageSize);\n    };\n    table.getRowCount = () => {\n      var _table$options$rowCou;\n      return (_table$options$rowCou = table.options.rowCount) != null ? _table$options$rowCou : table.getPrePaginationRowModel().rows.length;\n    };\n  }\n};\n\n//\n\nconst getDefaultRowPinningState = () => ({\n  top: [],\n  bottom: []\n});\nconst RowPinning = {\n  getInitialState: state => {\n    return {\n      rowPinning: getDefaultRowPinningState(),\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onRowPinningChange: makeStateUpdater('rowPinning', table)\n    };\n  },\n  createRow: (row, table) => {\n    row.pin = (position, includeLeafRows, includeParentRows) => {\n      const leafRowIds = includeLeafRows ? row.getLeafRows().map(_ref => {\n        let {\n          id\n        } = _ref;\n        return id;\n      }) : [];\n      const parentRowIds = includeParentRows ? row.getParentRows().map(_ref2 => {\n        let {\n          id\n        } = _ref2;\n        return id;\n      }) : [];\n      const rowIds = new Set([...parentRowIds, row.id, ...leafRowIds]);\n      table.setRowPinning(old => {\n        var _old$top3, _old$bottom3;\n        if (position === 'bottom') {\n          var _old$top, _old$bottom;\n          return {\n            top: ((_old$top = old == null ? void 0 : old.top) != null ? _old$top : []).filter(d => !(rowIds != null && rowIds.has(d))),\n            bottom: [...((_old$bottom = old == null ? void 0 : old.bottom) != null ? _old$bottom : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)]\n          };\n        }\n        if (position === 'top') {\n          var _old$top2, _old$bottom2;\n          return {\n            top: [...((_old$top2 = old == null ? void 0 : old.top) != null ? _old$top2 : []).filter(d => !(rowIds != null && rowIds.has(d))), ...Array.from(rowIds)],\n            bottom: ((_old$bottom2 = old == null ? void 0 : old.bottom) != null ? _old$bottom2 : []).filter(d => !(rowIds != null && rowIds.has(d)))\n          };\n        }\n        return {\n          top: ((_old$top3 = old == null ? void 0 : old.top) != null ? _old$top3 : []).filter(d => !(rowIds != null && rowIds.has(d))),\n          bottom: ((_old$bottom3 = old == null ? void 0 : old.bottom) != null ? _old$bottom3 : []).filter(d => !(rowIds != null && rowIds.has(d)))\n        };\n      });\n    };\n    row.getCanPin = () => {\n      var _ref3;\n      const {\n        enableRowPinning,\n        enablePinning\n      } = table.options;\n      if (typeof enableRowPinning === 'function') {\n        return enableRowPinning(row);\n      }\n      return (_ref3 = enableRowPinning != null ? enableRowPinning : enablePinning) != null ? _ref3 : true;\n    };\n    row.getIsPinned = () => {\n      const rowIds = [row.id];\n      const {\n        top,\n        bottom\n      } = table.getState().rowPinning;\n      const isTop = rowIds.some(d => top == null ? void 0 : top.includes(d));\n      const isBottom = rowIds.some(d => bottom == null ? void 0 : bottom.includes(d));\n      return isTop ? 'top' : isBottom ? 'bottom' : false;\n    };\n    row.getPinnedIndex = () => {\n      var _ref4, _visiblePinnedRowIds$;\n      const position = row.getIsPinned();\n      if (!position) return -1;\n      const visiblePinnedRowIds = (_ref4 = position === 'top' ? table.getTopRows() : table.getBottomRows()) == null ? void 0 : _ref4.map(_ref5 => {\n        let {\n          id\n        } = _ref5;\n        return id;\n      });\n      return (_visiblePinnedRowIds$ = visiblePinnedRowIds == null ? void 0 : visiblePinnedRowIds.indexOf(row.id)) != null ? _visiblePinnedRowIds$ : -1;\n    };\n  },\n  createTable: table => {\n    table.setRowPinning = updater => table.options.onRowPinningChange == null ? void 0 : table.options.onRowPinningChange(updater);\n    table.resetRowPinning = defaultState => {\n      var _table$initialState$r, _table$initialState;\n      return table.setRowPinning(defaultState ? getDefaultRowPinningState() : (_table$initialState$r = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.rowPinning) != null ? _table$initialState$r : getDefaultRowPinningState());\n    };\n    table.getIsSomeRowsPinned = position => {\n      var _pinningState$positio;\n      const pinningState = table.getState().rowPinning;\n      if (!position) {\n        var _pinningState$top, _pinningState$bottom;\n        return Boolean(((_pinningState$top = pinningState.top) == null ? void 0 : _pinningState$top.length) || ((_pinningState$bottom = pinningState.bottom) == null ? void 0 : _pinningState$bottom.length));\n      }\n      return Boolean((_pinningState$positio = pinningState[position]) == null ? void 0 : _pinningState$positio.length);\n    };\n    table._getPinnedRows = (visibleRows, pinnedRowIds, position) => {\n      var _table$options$keepPi;\n      const rows = ((_table$options$keepPi = table.options.keepPinnedRows) != null ? _table$options$keepPi : true) ?\n      //get all rows that are pinned even if they would not be otherwise visible\n      //account for expanded parent rows, but not pagination or filtering\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => {\n        const row = table.getRow(rowId, true);\n        return row.getIsAllParentsExpanded() ? row : null;\n      }) :\n      //else get only visible rows that are pinned\n      (pinnedRowIds != null ? pinnedRowIds : []).map(rowId => visibleRows.find(row => row.id === rowId));\n      return rows.filter(Boolean).map(d => ({\n        ...d,\n        position\n      }));\n    };\n    table.getTopRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top], (allRows, topPinnedRowIds) => table._getPinnedRows(allRows, topPinnedRowIds, 'top'), getMemoOptions(table.options, 'debugRows', 'getTopRows'));\n    table.getBottomRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.bottom], (allRows, bottomPinnedRowIds) => table._getPinnedRows(allRows, bottomPinnedRowIds, 'bottom'), getMemoOptions(table.options, 'debugRows', 'getBottomRows'));\n    table.getCenterRows = memo(() => [table.getRowModel().rows, table.getState().rowPinning.top, table.getState().rowPinning.bottom], (allRows, top, bottom) => {\n      const topAndBottom = new Set([...(top != null ? top : []), ...(bottom != null ? bottom : [])]);\n      return allRows.filter(d => !topAndBottom.has(d.id));\n    }, getMemoOptions(table.options, 'debugRows', 'getCenterRows'));\n  }\n};\n\n//\n\nconst RowSelection = {\n  getInitialState: state => {\n    return {\n      rowSelection: {},\n      ...state\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onRowSelectionChange: makeStateUpdater('rowSelection', table),\n      enableRowSelection: true,\n      enableMultiRowSelection: true,\n      enableSubRowSelection: true\n      // enableGroupingRowSelection: false,\n      // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,\n      // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,\n    };\n  },\n  createTable: table => {\n    table.setRowSelection = updater => table.options.onRowSelectionChange == null ? void 0 : table.options.onRowSelectionChange(updater);\n    table.resetRowSelection = defaultState => {\n      var _table$initialState$r;\n      return table.setRowSelection(defaultState ? {} : (_table$initialState$r = table.initialState.rowSelection) != null ? _table$initialState$r : {});\n    };\n    table.toggleAllRowsSelected = value => {\n      table.setRowSelection(old => {\n        value = typeof value !== 'undefined' ? value : !table.getIsAllRowsSelected();\n        const rowSelection = {\n          ...old\n        };\n        const preGroupedFlatRows = table.getPreGroupedRowModel().flatRows;\n\n        // We don't use `mutateRowIsSelected` here for performance reasons.\n        // All of the rows are flat already, so it wouldn't be worth it\n        if (value) {\n          preGroupedFlatRows.forEach(row => {\n            if (!row.getCanSelect()) {\n              return;\n            }\n            rowSelection[row.id] = true;\n          });\n        } else {\n          preGroupedFlatRows.forEach(row => {\n            delete rowSelection[row.id];\n          });\n        }\n        return rowSelection;\n      });\n    };\n    table.toggleAllPageRowsSelected = value => table.setRowSelection(old => {\n      const resolvedValue = typeof value !== 'undefined' ? value : !table.getIsAllPageRowsSelected();\n      const rowSelection = {\n        ...old\n      };\n      table.getRowModel().rows.forEach(row => {\n        mutateRowIsSelected(rowSelection, row.id, resolvedValue, true, table);\n      });\n      return rowSelection;\n    });\n\n    // addRowSelectionRange: rowId => {\n    //   const {\n    //     rows,\n    //     rowsById,\n    //     options: { selectGroupingRows, selectSubRows },\n    //   } = table\n\n    //   const findSelectedRow = (rows: Row[]) => {\n    //     let found\n    //     rows.find(d => {\n    //       if (d.getIsSelected()) {\n    //         found = d\n    //         return true\n    //       }\n    //       const subFound = findSelectedRow(d.subRows || [])\n    //       if (subFound) {\n    //         found = subFound\n    //         return true\n    //       }\n    //       return false\n    //     })\n    //     return found\n    //   }\n\n    //   const firstRow = findSelectedRow(rows) || rows[0]\n    //   const lastRow = rowsById[rowId]\n\n    //   let include = false\n    //   const selectedRowIds = {}\n\n    //   const addRow = (row: Row) => {\n    //     mutateRowIsSelected(selectedRowIds, row.id, true, {\n    //       rowsById,\n    //       selectGroupingRows: selectGroupingRows!,\n    //       selectSubRows: selectSubRows!,\n    //     })\n    //   }\n\n    //   table.rows.forEach(row => {\n    //     const isFirstRow = row.id === firstRow.id\n    //     const isLastRow = row.id === lastRow.id\n\n    //     if (isFirstRow || isLastRow) {\n    //       if (!include) {\n    //         include = true\n    //       } else if (include) {\n    //         addRow(row)\n    //         include = false\n    //       }\n    //     }\n\n    //     if (include) {\n    //       addRow(row)\n    //     }\n    //   })\n\n    //   table.setRowSelection(selectedRowIds)\n    // },\n    table.getPreSelectedRowModel = () => table.getCoreRowModel();\n    table.getSelectedRowModel = memo(() => [table.getState().rowSelection, table.getCoreRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getSelectedRowModel'));\n    table.getFilteredSelectedRowModel = memo(() => [table.getState().rowSelection, table.getFilteredRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getFilteredSelectedRowModel'));\n    table.getGroupedSelectedRowModel = memo(() => [table.getState().rowSelection, table.getSortedRowModel()], (rowSelection, rowModel) => {\n      if (!Object.keys(rowSelection).length) {\n        return {\n          rows: [],\n          flatRows: [],\n          rowsById: {}\n        };\n      }\n      return selectRowsFn(table, rowModel);\n    }, getMemoOptions(table.options, 'debugTable', 'getGroupedSelectedRowModel'));\n\n    ///\n\n    // getGroupingRowCanSelect: rowId => {\n    //   const row = table.getRow(rowId)\n\n    //   if (!row) {\n    //     throw new Error()\n    //   }\n\n    //   if (typeof table.options.enableGroupingRowSelection === 'function') {\n    //     return table.options.enableGroupingRowSelection(row)\n    //   }\n\n    //   return table.options.enableGroupingRowSelection ?? false\n    // },\n\n    table.getIsAllRowsSelected = () => {\n      const preGroupedFlatRows = table.getFilteredRowModel().flatRows;\n      const {\n        rowSelection\n      } = table.getState();\n      let isAllRowsSelected = Boolean(preGroupedFlatRows.length && Object.keys(rowSelection).length);\n      if (isAllRowsSelected) {\n        if (preGroupedFlatRows.some(row => row.getCanSelect() && !rowSelection[row.id])) {\n          isAllRowsSelected = false;\n        }\n      }\n      return isAllRowsSelected;\n    };\n    table.getIsAllPageRowsSelected = () => {\n      const paginationFlatRows = table.getPaginationRowModel().flatRows.filter(row => row.getCanSelect());\n      const {\n        rowSelection\n      } = table.getState();\n      let isAllPageRowsSelected = !!paginationFlatRows.length;\n      if (isAllPageRowsSelected && paginationFlatRows.some(row => !rowSelection[row.id])) {\n        isAllPageRowsSelected = false;\n      }\n      return isAllPageRowsSelected;\n    };\n    table.getIsSomeRowsSelected = () => {\n      var _table$getState$rowSe;\n      const totalSelected = Object.keys((_table$getState$rowSe = table.getState().rowSelection) != null ? _table$getState$rowSe : {}).length;\n      return totalSelected > 0 && totalSelected < table.getFilteredRowModel().flatRows.length;\n    };\n    table.getIsSomePageRowsSelected = () => {\n      const paginationFlatRows = table.getPaginationRowModel().flatRows;\n      return table.getIsAllPageRowsSelected() ? false : paginationFlatRows.filter(row => row.getCanSelect()).some(d => d.getIsSelected() || d.getIsSomeSelected());\n    };\n    table.getToggleAllRowsSelectedHandler = () => {\n      return e => {\n        table.toggleAllRowsSelected(e.target.checked);\n      };\n    };\n    table.getToggleAllPageRowsSelectedHandler = () => {\n      return e => {\n        table.toggleAllPageRowsSelected(e.target.checked);\n      };\n    };\n  },\n  createRow: (row, table) => {\n    row.toggleSelected = (value, opts) => {\n      const isSelected = row.getIsSelected();\n      table.setRowSelection(old => {\n        var _opts$selectChildren;\n        value = typeof value !== 'undefined' ? value : !isSelected;\n        if (row.getCanSelect() && isSelected === value) {\n          return old;\n        }\n        const selectedRowIds = {\n          ...old\n        };\n        mutateRowIsSelected(selectedRowIds, row.id, value, (_opts$selectChildren = opts == null ? void 0 : opts.selectChildren) != null ? _opts$selectChildren : true, table);\n        return selectedRowIds;\n      });\n    };\n    row.getIsSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isRowSelected(row, rowSelection);\n    };\n    row.getIsSomeSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isSubRowSelected(row, rowSelection) === 'some';\n    };\n    row.getIsAllSubRowsSelected = () => {\n      const {\n        rowSelection\n      } = table.getState();\n      return isSubRowSelected(row, rowSelection) === 'all';\n    };\n    row.getCanSelect = () => {\n      var _table$options$enable;\n      if (typeof table.options.enableRowSelection === 'function') {\n        return table.options.enableRowSelection(row);\n      }\n      return (_table$options$enable = table.options.enableRowSelection) != null ? _table$options$enable : true;\n    };\n    row.getCanSelectSubRows = () => {\n      var _table$options$enable2;\n      if (typeof table.options.enableSubRowSelection === 'function') {\n        return table.options.enableSubRowSelection(row);\n      }\n      return (_table$options$enable2 = table.options.enableSubRowSelection) != null ? _table$options$enable2 : true;\n    };\n    row.getCanMultiSelect = () => {\n      var _table$options$enable3;\n      if (typeof table.options.enableMultiRowSelection === 'function') {\n        return table.options.enableMultiRowSelection(row);\n      }\n      return (_table$options$enable3 = table.options.enableMultiRowSelection) != null ? _table$options$enable3 : true;\n    };\n    row.getToggleSelectedHandler = () => {\n      const canSelect = row.getCanSelect();\n      return e => {\n        var _target;\n        if (!canSelect) return;\n        row.toggleSelected((_target = e.target) == null ? void 0 : _target.checked);\n      };\n    };\n  }\n};\nconst mutateRowIsSelected = (selectedRowIds, id, value, includeChildren, table) => {\n  var _row$subRows;\n  const row = table.getRow(id, true);\n\n  // const isGrouped = row.getIsGrouped()\n\n  // if ( // TODO: enforce grouping row selection rules\n  //   !isGrouped ||\n  //   (isGrouped && table.options.enableGroupingRowSelection)\n  // ) {\n  if (value) {\n    if (!row.getCanMultiSelect()) {\n      Object.keys(selectedRowIds).forEach(key => delete selectedRowIds[key]);\n    }\n    if (row.getCanSelect()) {\n      selectedRowIds[id] = true;\n    }\n  } else {\n    delete selectedRowIds[id];\n  }\n  // }\n\n  if (includeChildren && (_row$subRows = row.subRows) != null && _row$subRows.length && row.getCanSelectSubRows()) {\n    row.subRows.forEach(row => mutateRowIsSelected(selectedRowIds, row.id, value, includeChildren, table));\n  }\n};\nfunction selectRowsFn(table, rowModel) {\n  const rowSelection = table.getState().rowSelection;\n  const newSelectedFlatRows = [];\n  const newSelectedRowsById = {};\n\n  // Filters top level and nested rows\n  const recurseRows = function (rows, depth) {\n    return rows.map(row => {\n      var _row$subRows2;\n      const isSelected = isRowSelected(row, rowSelection);\n      if (isSelected) {\n        newSelectedFlatRows.push(row);\n        newSelectedRowsById[row.id] = row;\n      }\n      if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length) {\n        row = {\n          ...row,\n          subRows: recurseRows(row.subRows)\n        };\n      }\n      if (isSelected) {\n        return row;\n      }\n    }).filter(Boolean);\n  };\n  return {\n    rows: recurseRows(rowModel.rows),\n    flatRows: newSelectedFlatRows,\n    rowsById: newSelectedRowsById\n  };\n}\nfunction isRowSelected(row, selection) {\n  var _selection$row$id;\n  return (_selection$row$id = selection[row.id]) != null ? _selection$row$id : false;\n}\nfunction isSubRowSelected(row, selection, table) {\n  var _row$subRows3;\n  if (!((_row$subRows3 = row.subRows) != null && _row$subRows3.length)) return false;\n  let allChildrenSelected = true;\n  let someSelected = false;\n  row.subRows.forEach(subRow => {\n    // Bail out early if we know both of these\n    if (someSelected && !allChildrenSelected) {\n      return;\n    }\n    if (subRow.getCanSelect()) {\n      if (isRowSelected(subRow, selection)) {\n        someSelected = true;\n      } else {\n        allChildrenSelected = false;\n      }\n    }\n\n    // Check row selection of nested subrows\n    if (subRow.subRows && subRow.subRows.length) {\n      const subRowChildrenSelected = isSubRowSelected(subRow, selection);\n      if (subRowChildrenSelected === 'all') {\n        someSelected = true;\n      } else if (subRowChildrenSelected === 'some') {\n        someSelected = true;\n        allChildrenSelected = false;\n      } else {\n        allChildrenSelected = false;\n      }\n    }\n  });\n  return allChildrenSelected ? 'all' : someSelected ? 'some' : false;\n}\n\nconst reSplitAlphaNumeric = /([0-9]+)/gm;\nconst alphanumeric = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\nconst alphanumericCaseSensitive = (rowA, rowB, columnId) => {\n  return compareAlphanumeric(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst text = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)).toLowerCase(), toString(rowB.getValue(columnId)).toLowerCase());\n};\n\n// The text filter is more basic (less numeric support)\n// but is much faster\nconst textCaseSensitive = (rowA, rowB, columnId) => {\n  return compareBasic(toString(rowA.getValue(columnId)), toString(rowB.getValue(columnId)));\n};\nconst datetime = (rowA, rowB, columnId) => {\n  const a = rowA.getValue(columnId);\n  const b = rowB.getValue(columnId);\n\n  // Can handle nullish values\n  // Use > and < because == (and ===) doesn't work with\n  // Date objects (would require calling getTime()).\n  return a > b ? 1 : a < b ? -1 : 0;\n};\nconst basic = (rowA, rowB, columnId) => {\n  return compareBasic(rowA.getValue(columnId), rowB.getValue(columnId));\n};\n\n// Utils\n\nfunction compareBasic(a, b) {\n  return a === b ? 0 : a > b ? 1 : -1;\n}\nfunction toString(a) {\n  if (typeof a === 'number') {\n    if (isNaN(a) || a === Infinity || a === -Infinity) {\n      return '';\n    }\n    return String(a);\n  }\n  if (typeof a === 'string') {\n    return a;\n  }\n  return '';\n}\n\n// Mixed sorting is slow, but very inclusive of many edge cases.\n// It handles numbers, mixed alphanumeric combinations, and even\n// null, undefined, and Infinity\nfunction compareAlphanumeric(aStr, bStr) {\n  // Split on number groups, but keep the delimiter\n  // Then remove falsey split values\n  const a = aStr.split(reSplitAlphaNumeric).filter(Boolean);\n  const b = bStr.split(reSplitAlphaNumeric).filter(Boolean);\n\n  // While\n  while (a.length && b.length) {\n    const aa = a.shift();\n    const bb = b.shift();\n    const an = parseInt(aa, 10);\n    const bn = parseInt(bb, 10);\n    const combo = [an, bn].sort();\n\n    // Both are string\n    if (isNaN(combo[0])) {\n      if (aa > bb) {\n        return 1;\n      }\n      if (bb > aa) {\n        return -1;\n      }\n      continue;\n    }\n\n    // One is a string, one is a number\n    if (isNaN(combo[1])) {\n      return isNaN(an) ? -1 : 1;\n    }\n\n    // Both are numbers\n    if (an > bn) {\n      return 1;\n    }\n    if (bn > an) {\n      return -1;\n    }\n  }\n  return a.length - b.length;\n}\n\n// Exports\n\nconst sortingFns = {\n  alphanumeric,\n  alphanumericCaseSensitive,\n  text,\n  textCaseSensitive,\n  datetime,\n  basic\n};\n\n//\n\nconst RowSorting = {\n  getInitialState: state => {\n    return {\n      sorting: [],\n      ...state\n    };\n  },\n  getDefaultColumnDef: () => {\n    return {\n      sortingFn: 'auto',\n      sortUndefined: 1\n    };\n  },\n  getDefaultOptions: table => {\n    return {\n      onSortingChange: makeStateUpdater('sorting', table),\n      isMultiSortEvent: e => {\n        return e.shiftKey;\n      }\n    };\n  },\n  createColumn: (column, table) => {\n    column.getAutoSortingFn = () => {\n      const firstRows = table.getFilteredRowModel().flatRows.slice(10);\n      let isString = false;\n      for (const row of firstRows) {\n        const value = row == null ? void 0 : row.getValue(column.id);\n        if (Object.prototype.toString.call(value) === '[object Date]') {\n          return sortingFns.datetime;\n        }\n        if (typeof value === 'string') {\n          isString = true;\n          if (value.split(reSplitAlphaNumeric).length > 1) {\n            return sortingFns.alphanumeric;\n          }\n        }\n      }\n      if (isString) {\n        return sortingFns.text;\n      }\n      return sortingFns.basic;\n    };\n    column.getAutoSortDir = () => {\n      const firstRow = table.getFilteredRowModel().flatRows[0];\n      const value = firstRow == null ? void 0 : firstRow.getValue(column.id);\n      if (typeof value === 'string') {\n        return 'asc';\n      }\n      return 'desc';\n    };\n    column.getSortingFn = () => {\n      var _table$options$sortin, _table$options$sortin2;\n      if (!column) {\n        throw new Error();\n      }\n      return isFunction(column.columnDef.sortingFn) ? column.columnDef.sortingFn : column.columnDef.sortingFn === 'auto' ? column.getAutoSortingFn() : (_table$options$sortin = (_table$options$sortin2 = table.options.sortingFns) == null ? void 0 : _table$options$sortin2[column.columnDef.sortingFn]) != null ? _table$options$sortin : sortingFns[column.columnDef.sortingFn];\n    };\n    column.toggleSorting = (desc, multi) => {\n      // if (column.columns.length) {\n      //   column.columns.forEach((c, i) => {\n      //     if (c.id) {\n      //       table.toggleColumnSorting(c.id, undefined, multi || !!i)\n      //     }\n      //   })\n      //   return\n      // }\n\n      // this needs to be outside of table.setSorting to be in sync with rerender\n      const nextSortingOrder = column.getNextSortingOrder();\n      const hasManualValue = typeof desc !== 'undefined' && desc !== null;\n      table.setSorting(old => {\n        // Find any existing sorting for this column\n        const existingSorting = old == null ? void 0 : old.find(d => d.id === column.id);\n        const existingIndex = old == null ? void 0 : old.findIndex(d => d.id === column.id);\n        let newSorting = [];\n\n        // What should we do with this sort action?\n        let sortAction;\n        let nextDesc = hasManualValue ? desc : nextSortingOrder === 'desc';\n\n        // Multi-mode\n        if (old != null && old.length && column.getCanMultiSort() && multi) {\n          if (existingSorting) {\n            sortAction = 'toggle';\n          } else {\n            sortAction = 'add';\n          }\n        } else {\n          // Normal mode\n          if (old != null && old.length && existingIndex !== old.length - 1) {\n            sortAction = 'replace';\n          } else if (existingSorting) {\n            sortAction = 'toggle';\n          } else {\n            sortAction = 'replace';\n          }\n        }\n\n        // Handle toggle states that will remove the sorting\n        if (sortAction === 'toggle') {\n          // If we are \"actually\" toggling (not a manual set value), should we remove the sorting?\n          if (!hasManualValue) {\n            // Is our intention to remove?\n            if (!nextSortingOrder) {\n              sortAction = 'remove';\n            }\n          }\n        }\n        if (sortAction === 'add') {\n          var _table$options$maxMul;\n          newSorting = [...old, {\n            id: column.id,\n            desc: nextDesc\n          }];\n          // Take latest n columns\n          newSorting.splice(0, newSorting.length - ((_table$options$maxMul = table.options.maxMultiSortColCount) != null ? _table$options$maxMul : Number.MAX_SAFE_INTEGER));\n        } else if (sortAction === 'toggle') {\n          // This flips (or sets) the\n          newSorting = old.map(d => {\n            if (d.id === column.id) {\n              return {\n                ...d,\n                desc: nextDesc\n              };\n            }\n            return d;\n          });\n        } else if (sortAction === 'remove') {\n          newSorting = old.filter(d => d.id !== column.id);\n        } else {\n          newSorting = [{\n            id: column.id,\n            desc: nextDesc\n          }];\n        }\n        return newSorting;\n      });\n    };\n    column.getFirstSortDir = () => {\n      var _ref, _column$columnDef$sor;\n      const sortDescFirst = (_ref = (_column$columnDef$sor = column.columnDef.sortDescFirst) != null ? _column$columnDef$sor : table.options.sortDescFirst) != null ? _ref : column.getAutoSortDir() === 'desc';\n      return sortDescFirst ? 'desc' : 'asc';\n    };\n    column.getNextSortingOrder = multi => {\n      var _table$options$enable, _table$options$enable2;\n      const firstSortDirection = column.getFirstSortDir();\n      const isSorted = column.getIsSorted();\n      if (!isSorted) {\n        return firstSortDirection;\n      }\n      if (isSorted !== firstSortDirection && ((_table$options$enable = table.options.enableSortingRemoval) != null ? _table$options$enable : true) && (\n      // If enableSortRemove, enable in general\n      multi ? (_table$options$enable2 = table.options.enableMultiRemove) != null ? _table$options$enable2 : true : true) // If multi, don't allow if enableMultiRemove))\n      ) {\n        return false;\n      }\n      return isSorted === 'desc' ? 'asc' : 'desc';\n    };\n    column.getCanSort = () => {\n      var _column$columnDef$ena, _table$options$enable3;\n      return ((_column$columnDef$ena = column.columnDef.enableSorting) != null ? _column$columnDef$ena : true) && ((_table$options$enable3 = table.options.enableSorting) != null ? _table$options$enable3 : true) && !!column.accessorFn;\n    };\n    column.getCanMultiSort = () => {\n      var _ref2, _column$columnDef$ena2;\n      return (_ref2 = (_column$columnDef$ena2 = column.columnDef.enableMultiSort) != null ? _column$columnDef$ena2 : table.options.enableMultiSort) != null ? _ref2 : !!column.accessorFn;\n    };\n    column.getIsSorted = () => {\n      var _table$getState$sorti;\n      const columnSort = (_table$getState$sorti = table.getState().sorting) == null ? void 0 : _table$getState$sorti.find(d => d.id === column.id);\n      return !columnSort ? false : columnSort.desc ? 'desc' : 'asc';\n    };\n    column.getSortIndex = () => {\n      var _table$getState$sorti2, _table$getState$sorti3;\n      return (_table$getState$sorti2 = (_table$getState$sorti3 = table.getState().sorting) == null ? void 0 : _table$getState$sorti3.findIndex(d => d.id === column.id)) != null ? _table$getState$sorti2 : -1;\n    };\n    column.clearSorting = () => {\n      //clear sorting for just 1 column\n      table.setSorting(old => old != null && old.length ? old.filter(d => d.id !== column.id) : []);\n    };\n    column.getToggleSortingHandler = () => {\n      const canSort = column.getCanSort();\n      return e => {\n        if (!canSort) return;\n        e.persist == null || e.persist();\n        column.toggleSorting == null || column.toggleSorting(undefined, column.getCanMultiSort() ? table.options.isMultiSortEvent == null ? void 0 : table.options.isMultiSortEvent(e) : false);\n      };\n    };\n  },\n  createTable: table => {\n    table.setSorting = updater => table.options.onSortingChange == null ? void 0 : table.options.onSortingChange(updater);\n    table.resetSorting = defaultState => {\n      var _table$initialState$s, _table$initialState;\n      table.setSorting(defaultState ? [] : (_table$initialState$s = (_table$initialState = table.initialState) == null ? void 0 : _table$initialState.sorting) != null ? _table$initialState$s : []);\n    };\n    table.getPreSortedRowModel = () => table.getGroupedRowModel();\n    table.getSortedRowModel = () => {\n      if (!table._getSortedRowModel && table.options.getSortedRowModel) {\n        table._getSortedRowModel = table.options.getSortedRowModel(table);\n      }\n      if (table.options.manualSorting || !table._getSortedRowModel) {\n        return table.getPreSortedRowModel();\n      }\n      return table._getSortedRowModel();\n    };\n  }\n};\n\nconst builtInFeatures = [Headers, ColumnVisibility, ColumnOrdering, ColumnPinning, ColumnFaceting, ColumnFiltering, GlobalFaceting,\n//depends on ColumnFaceting\nGlobalFiltering,\n//depends on ColumnFiltering\nRowSorting, ColumnGrouping,\n//depends on RowSorting\nRowExpanding, RowPagination, RowPinning, RowSelection, ColumnSizing];\n\n//\n\nfunction createTable(options) {\n  var _options$_features, _options$initialState;\n  if ( true && (options.debugAll || options.debugTable)) {\n    console.info('Creating Table Instance...');\n  }\n  const _features = [...builtInFeatures, ...((_options$_features = options._features) != null ? _options$_features : [])];\n  let table = {\n    _features\n  };\n  const defaultOptions = table._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.getDefaultOptions == null ? void 0 : feature.getDefaultOptions(table));\n  }, {});\n  const mergeOptions = options => {\n    if (table.options.mergeOptions) {\n      return table.options.mergeOptions(defaultOptions, options);\n    }\n    return {\n      ...defaultOptions,\n      ...options\n    };\n  };\n  const coreInitialState = {};\n  let initialState = {\n    ...coreInitialState,\n    ...((_options$initialState = options.initialState) != null ? _options$initialState : {})\n  };\n  table._features.forEach(feature => {\n    var _feature$getInitialSt;\n    initialState = (_feature$getInitialSt = feature.getInitialState == null ? void 0 : feature.getInitialState(initialState)) != null ? _feature$getInitialSt : initialState;\n  });\n  const queued = [];\n  let queuedTimeout = false;\n  const coreInstance = {\n    _features,\n    options: {\n      ...defaultOptions,\n      ...options\n    },\n    initialState,\n    _queue: cb => {\n      queued.push(cb);\n      if (!queuedTimeout) {\n        queuedTimeout = true;\n\n        // Schedule a microtask to run the queued callbacks after\n        // the current call stack (render, etc) has finished.\n        Promise.resolve().then(() => {\n          while (queued.length) {\n            queued.shift()();\n          }\n          queuedTimeout = false;\n        }).catch(error => setTimeout(() => {\n          throw error;\n        }));\n      }\n    },\n    reset: () => {\n      table.setState(table.initialState);\n    },\n    setOptions: updater => {\n      const newOptions = functionalUpdate(updater, table.options);\n      table.options = mergeOptions(newOptions);\n    },\n    getState: () => {\n      return table.options.state;\n    },\n    setState: updater => {\n      table.options.onStateChange == null || table.options.onStateChange(updater);\n    },\n    _getRowId: (row, index, parent) => {\n      var _table$options$getRow;\n      return (_table$options$getRow = table.options.getRowId == null ? void 0 : table.options.getRowId(row, index, parent)) != null ? _table$options$getRow : `${parent ? [parent.id, index].join('.') : index}`;\n    },\n    getCoreRowModel: () => {\n      if (!table._getCoreRowModel) {\n        table._getCoreRowModel = table.options.getCoreRowModel(table);\n      }\n      return table._getCoreRowModel();\n    },\n    // The final calls start at the bottom of the model,\n    // expanded rows, which then work their way up\n\n    getRowModel: () => {\n      return table.getPaginationRowModel();\n    },\n    //in next version, we should just pass in the row model as the optional 2nd arg\n    getRow: (id, searchAll) => {\n      let row = (searchAll ? table.getPrePaginationRowModel() : table.getRowModel()).rowsById[id];\n      if (!row) {\n        row = table.getCoreRowModel().rowsById[id];\n        if (!row) {\n          if (true) {\n            throw new Error(`getRow could not find row with ID: ${id}`);\n          }\n          throw new Error();\n        }\n      }\n      return row;\n    },\n    _getDefaultColumnDef: memo(() => [table.options.defaultColumn], defaultColumn => {\n      var _defaultColumn;\n      defaultColumn = (_defaultColumn = defaultColumn) != null ? _defaultColumn : {};\n      return {\n        header: props => {\n          const resolvedColumnDef = props.header.column.columnDef;\n          if (resolvedColumnDef.accessorKey) {\n            return resolvedColumnDef.accessorKey;\n          }\n          if (resolvedColumnDef.accessorFn) {\n            return resolvedColumnDef.id;\n          }\n          return null;\n        },\n        // footer: props => props.header.column.id,\n        cell: props => {\n          var _props$renderValue$to, _props$renderValue;\n          return (_props$renderValue$to = (_props$renderValue = props.renderValue()) == null || _props$renderValue.toString == null ? void 0 : _props$renderValue.toString()) != null ? _props$renderValue$to : null;\n        },\n        ...table._features.reduce((obj, feature) => {\n          return Object.assign(obj, feature.getDefaultColumnDef == null ? void 0 : feature.getDefaultColumnDef());\n        }, {}),\n        ...defaultColumn\n      };\n    }, getMemoOptions(options, 'debugColumns', '_getDefaultColumnDef')),\n    _getColumnDefs: () => table.options.columns,\n    getAllColumns: memo(() => [table._getColumnDefs()], columnDefs => {\n      const recurseColumns = function (columnDefs, parent, depth) {\n        if (depth === void 0) {\n          depth = 0;\n        }\n        return columnDefs.map(columnDef => {\n          const column = createColumn(table, columnDef, depth, parent);\n          const groupingColumnDef = columnDef;\n          column.columns = groupingColumnDef.columns ? recurseColumns(groupingColumnDef.columns, column, depth + 1) : [];\n          return column;\n        });\n      };\n      return recurseColumns(columnDefs);\n    }, getMemoOptions(options, 'debugColumns', 'getAllColumns')),\n    getAllFlatColumns: memo(() => [table.getAllColumns()], allColumns => {\n      return allColumns.flatMap(column => {\n        return column.getFlatColumns();\n      });\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumns')),\n    _getAllFlatColumnsById: memo(() => [table.getAllFlatColumns()], flatColumns => {\n      return flatColumns.reduce((acc, column) => {\n        acc[column.id] = column;\n        return acc;\n      }, {});\n    }, getMemoOptions(options, 'debugColumns', 'getAllFlatColumnsById')),\n    getAllLeafColumns: memo(() => [table.getAllColumns(), table._getOrderColumnsFn()], (allColumns, orderColumns) => {\n      let leafColumns = allColumns.flatMap(column => column.getLeafColumns());\n      return orderColumns(leafColumns);\n    }, getMemoOptions(options, 'debugColumns', 'getAllLeafColumns')),\n    getColumn: columnId => {\n      const column = table._getAllFlatColumnsById()[columnId];\n      if ( true && !column) {\n        console.error(`[Table] Column with id '${columnId}' does not exist.`);\n      }\n      return column;\n    }\n  };\n  Object.assign(table, coreInstance);\n  for (let index = 0; index < table._features.length; index++) {\n    const feature = table._features[index];\n    feature == null || feature.createTable == null || feature.createTable(table);\n  }\n  return table;\n}\n\nfunction getCoreRowModel() {\n  return table => memo(() => [table.options.data], data => {\n    const rowModel = {\n      rows: [],\n      flatRows: [],\n      rowsById: {}\n    };\n    const accessRows = function (originalRows, depth, parentRow) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n      const rows = [];\n      for (let i = 0; i < originalRows.length; i++) {\n        // This could be an expensive check at scale, so we should move it somewhere else, but where?\n        // if (!id) {\n        //   if (process.env.NODE_ENV !== 'production') {\n        //     throw new Error(`getRowId expected an ID, but got ${id}`)\n        //   }\n        // }\n\n        // Make the row\n        const row = createRow(table, table._getRowId(originalRows[i], i, parentRow), originalRows[i], i, depth, undefined, parentRow == null ? void 0 : parentRow.id);\n\n        // Keep track of every row in a flat array\n        rowModel.flatRows.push(row);\n        // Also keep track of every row by its ID\n        rowModel.rowsById[row.id] = row;\n        // Push table row into parent\n        rows.push(row);\n\n        // Get the original subrows\n        if (table.options.getSubRows) {\n          var _row$originalSubRows;\n          row.originalSubRows = table.options.getSubRows(originalRows[i], i);\n\n          // Then recursively access them\n          if ((_row$originalSubRows = row.originalSubRows) != null && _row$originalSubRows.length) {\n            row.subRows = accessRows(row.originalSubRows, depth + 1, row);\n          }\n        }\n      }\n      return rows;\n    };\n    rowModel.rows = accessRows(data);\n    return rowModel;\n  }, getMemoOptions(table.options, 'debugTable', 'getRowModel', () => table._autoResetPageIndex()));\n}\n\nfunction getExpandedRowModel() {\n  return table => memo(() => [table.getState().expanded, table.getPreExpandedRowModel(), table.options.paginateExpandedRows], (expanded, rowModel, paginateExpandedRows) => {\n    if (!rowModel.rows.length || expanded !== true && !Object.keys(expanded != null ? expanded : {}).length) {\n      return rowModel;\n    }\n    if (!paginateExpandedRows) {\n      // Only expand rows at this point if they are being paginated\n      return rowModel;\n    }\n    return expandRows(rowModel);\n  }, getMemoOptions(table.options, 'debugTable', 'getExpandedRowModel'));\n}\nfunction expandRows(rowModel) {\n  const expandedRows = [];\n  const handleRow = row => {\n    var _row$subRows;\n    expandedRows.push(row);\n    if ((_row$subRows = row.subRows) != null && _row$subRows.length && row.getIsExpanded()) {\n      row.subRows.forEach(handleRow);\n    }\n  };\n  rowModel.rows.forEach(handleRow);\n  return {\n    rows: expandedRows,\n    flatRows: rowModel.flatRows,\n    rowsById: rowModel.rowsById\n  };\n}\n\nfunction getFacetedMinMaxValues() {\n  return (table, columnId) => memo(() => {\n    var _table$getColumn;\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\n  }, facetedRowModel => {\n    if (!facetedRowModel) return undefined;\n    const uniqueValues = facetedRowModel.flatRows.flatMap(flatRow => {\n      var _flatRow$getUniqueVal;\n      return (_flatRow$getUniqueVal = flatRow.getUniqueValues(columnId)) != null ? _flatRow$getUniqueVal : [];\n    }).map(Number).filter(value => !Number.isNaN(value));\n    if (!uniqueValues.length) return;\n    let facetedMinValue = uniqueValues[0];\n    let facetedMaxValue = uniqueValues[uniqueValues.length - 1];\n    for (const value of uniqueValues) {\n      if (value < facetedMinValue) facetedMinValue = value;else if (value > facetedMaxValue) facetedMaxValue = value;\n    }\n    return [facetedMinValue, facetedMaxValue];\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedMinMaxValues'));\n}\n\nfunction filterRows(rows, filterRowImpl, table) {\n  if (table.options.filterFromLeafRows) {\n    return filterRowModelFromLeafs(rows, filterRowImpl, table);\n  }\n  return filterRowModelFromRoot(rows, filterRowImpl, table);\n}\nfunction filterRowModelFromLeafs(rowsToFilter, filterRow, table) {\n  var _table$options$maxLea;\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  const maxDepth = (_table$options$maxLea = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea : 100;\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n    const rows = [];\n\n    // Filter from children up first\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      var _row$subRows;\n      let row = rowsToFilter[i];\n      const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n      newRow.columnFilters = row.columnFilters;\n      if ((_row$subRows = row.subRows) != null && _row$subRows.length && depth < maxDepth) {\n        newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n        row = newRow;\n        if (filterRow(row) && !newRow.subRows.length) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n          continue;\n        }\n        if (filterRow(row) || newRow.subRows.length) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n          continue;\n        }\n      } else {\n        row = newRow;\n        if (filterRow(row)) {\n          rows.push(row);\n          newFilteredRowsById[row.id] = row;\n          newFilteredFlatRows.push(row);\n        }\n      }\n    }\n    return rows;\n  };\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\nfunction filterRowModelFromRoot(rowsToFilter, filterRow, table) {\n  var _table$options$maxLea2;\n  const newFilteredFlatRows = [];\n  const newFilteredRowsById = {};\n  const maxDepth = (_table$options$maxLea2 = table.options.maxLeafRowFilterDepth) != null ? _table$options$maxLea2 : 100;\n\n  // Filters top level and nested rows\n  const recurseFilterRows = function (rowsToFilter, depth) {\n    if (depth === void 0) {\n      depth = 0;\n    }\n    // Filter from parents downward first\n\n    const rows = [];\n\n    // Apply the filter to any subRows\n    for (let i = 0; i < rowsToFilter.length; i++) {\n      let row = rowsToFilter[i];\n      const pass = filterRow(row);\n      if (pass) {\n        var _row$subRows2;\n        if ((_row$subRows2 = row.subRows) != null && _row$subRows2.length && depth < maxDepth) {\n          const newRow = createRow(table, row.id, row.original, row.index, row.depth, undefined, row.parentId);\n          newRow.subRows = recurseFilterRows(row.subRows, depth + 1);\n          row = newRow;\n        }\n        rows.push(row);\n        newFilteredFlatRows.push(row);\n        newFilteredRowsById[row.id] = row;\n      }\n    }\n    return rows;\n  };\n  return {\n    rows: recurseFilterRows(rowsToFilter),\n    flatRows: newFilteredFlatRows,\n    rowsById: newFilteredRowsById\n  };\n}\n\nfunction getFacetedRowModel() {\n  return (table, columnId) => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter, table.getFilteredRowModel()], (preRowModel, columnFilters, globalFilter) => {\n    if (!preRowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      return preRowModel;\n    }\n    const filterableIds = [...columnFilters.map(d => d.id).filter(d => d !== columnId), globalFilter ? '__global__' : undefined].filter(Boolean);\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n    return filterRows(preRowModel.rows, filterRowsImpl, table);\n  }, getMemoOptions(table.options, 'debugTable', 'getFacetedRowModel'));\n}\n\nfunction getFacetedUniqueValues() {\n  return (table, columnId) => memo(() => {\n    var _table$getColumn;\n    return [(_table$getColumn = table.getColumn(columnId)) == null ? void 0 : _table$getColumn.getFacetedRowModel()];\n  }, facetedRowModel => {\n    if (!facetedRowModel) return new Map();\n    let facetedUniqueValues = new Map();\n    for (let i = 0; i < facetedRowModel.flatRows.length; i++) {\n      const values = facetedRowModel.flatRows[i].getUniqueValues(columnId);\n      for (let j = 0; j < values.length; j++) {\n        const value = values[j];\n        if (facetedUniqueValues.has(value)) {\n          var _facetedUniqueValues$;\n          facetedUniqueValues.set(value, ((_facetedUniqueValues$ = facetedUniqueValues.get(value)) != null ? _facetedUniqueValues$ : 0) + 1);\n        } else {\n          facetedUniqueValues.set(value, 1);\n        }\n      }\n    }\n    return facetedUniqueValues;\n  }, getMemoOptions(table.options, 'debugTable', `getFacetedUniqueValues_${columnId}`));\n}\n\nfunction getFilteredRowModel() {\n  return table => memo(() => [table.getPreFilteredRowModel(), table.getState().columnFilters, table.getState().globalFilter], (rowModel, columnFilters, globalFilter) => {\n    if (!rowModel.rows.length || !(columnFilters != null && columnFilters.length) && !globalFilter) {\n      for (let i = 0; i < rowModel.flatRows.length; i++) {\n        rowModel.flatRows[i].columnFilters = {};\n        rowModel.flatRows[i].columnFiltersMeta = {};\n      }\n      return rowModel;\n    }\n    const resolvedColumnFilters = [];\n    const resolvedGlobalFilters = [];\n    (columnFilters != null ? columnFilters : []).forEach(d => {\n      var _filterFn$resolveFilt;\n      const column = table.getColumn(d.id);\n      if (!column) {\n        return;\n      }\n      const filterFn = column.getFilterFn();\n      if (!filterFn) {\n        if (true) {\n          console.warn(`Could not find a valid 'column.filterFn' for column with the ID: ${column.id}.`);\n        }\n        return;\n      }\n      resolvedColumnFilters.push({\n        id: d.id,\n        filterFn,\n        resolvedValue: (_filterFn$resolveFilt = filterFn.resolveFilterValue == null ? void 0 : filterFn.resolveFilterValue(d.value)) != null ? _filterFn$resolveFilt : d.value\n      });\n    });\n    const filterableIds = (columnFilters != null ? columnFilters : []).map(d => d.id);\n    const globalFilterFn = table.getGlobalFilterFn();\n    const globallyFilterableColumns = table.getAllLeafColumns().filter(column => column.getCanGlobalFilter());\n    if (globalFilter && globalFilterFn && globallyFilterableColumns.length) {\n      filterableIds.push('__global__');\n      globallyFilterableColumns.forEach(column => {\n        var _globalFilterFn$resol;\n        resolvedGlobalFilters.push({\n          id: column.id,\n          filterFn: globalFilterFn,\n          resolvedValue: (_globalFilterFn$resol = globalFilterFn.resolveFilterValue == null ? void 0 : globalFilterFn.resolveFilterValue(globalFilter)) != null ? _globalFilterFn$resol : globalFilter\n        });\n      });\n    }\n    let currentColumnFilter;\n    let currentGlobalFilter;\n\n    // Flag the prefiltered row model with each filter state\n    for (let j = 0; j < rowModel.flatRows.length; j++) {\n      const row = rowModel.flatRows[j];\n      row.columnFilters = {};\n      if (resolvedColumnFilters.length) {\n        for (let i = 0; i < resolvedColumnFilters.length; i++) {\n          currentColumnFilter = resolvedColumnFilters[i];\n          const id = currentColumnFilter.id;\n\n          // Tag the row with the column filter state\n          row.columnFilters[id] = currentColumnFilter.filterFn(row, id, currentColumnFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          });\n        }\n      }\n      if (resolvedGlobalFilters.length) {\n        for (let i = 0; i < resolvedGlobalFilters.length; i++) {\n          currentGlobalFilter = resolvedGlobalFilters[i];\n          const id = currentGlobalFilter.id;\n          // Tag the row with the first truthy global filter state\n          if (currentGlobalFilter.filterFn(row, id, currentGlobalFilter.resolvedValue, filterMeta => {\n            row.columnFiltersMeta[id] = filterMeta;\n          })) {\n            row.columnFilters.__global__ = true;\n            break;\n          }\n        }\n        if (row.columnFilters.__global__ !== true) {\n          row.columnFilters.__global__ = false;\n        }\n      }\n    }\n    const filterRowsImpl = row => {\n      // Horizontally filter rows through each column\n      for (let i = 0; i < filterableIds.length; i++) {\n        if (row.columnFilters[filterableIds[i]] === false) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    // Filter final rows using all of the active filters\n    return filterRows(rowModel.rows, filterRowsImpl, table);\n  }, getMemoOptions(table.options, 'debugTable', 'getFilteredRowModel', () => table._autoResetPageIndex()));\n}\n\nfunction getGroupedRowModel() {\n  return table => memo(() => [table.getState().grouping, table.getPreGroupedRowModel()], (grouping, rowModel) => {\n    if (!rowModel.rows.length || !grouping.length) {\n      rowModel.rows.forEach(row => {\n        row.depth = 0;\n        row.parentId = undefined;\n      });\n      return rowModel;\n    }\n\n    // Filter the grouping list down to columns that exist\n    const existingGrouping = grouping.filter(columnId => table.getColumn(columnId));\n    const groupedFlatRows = [];\n    const groupedRowsById = {};\n    // const onlyGroupedFlatRows: Row[] = [];\n    // const onlyGroupedRowsById: Record<RowId, Row> = {};\n    // const nonGroupedFlatRows: Row[] = [];\n    // const nonGroupedRowsById: Record<RowId, Row> = {};\n\n    // Recursively group the data\n    const groupUpRecursively = function (rows, depth, parentId) {\n      if (depth === void 0) {\n        depth = 0;\n      }\n      // Grouping depth has been been met\n      // Stop grouping and simply rewrite thd depth and row relationships\n      if (depth >= existingGrouping.length) {\n        return rows.map(row => {\n          row.depth = depth;\n          groupedFlatRows.push(row);\n          groupedRowsById[row.id] = row;\n          if (row.subRows) {\n            row.subRows = groupUpRecursively(row.subRows, depth + 1, row.id);\n          }\n          return row;\n        });\n      }\n      const columnId = existingGrouping[depth];\n\n      // Group the rows together for this level\n      const rowGroupsMap = groupBy(rows, columnId);\n\n      // Perform aggregations for each group\n      const aggregatedGroupedRows = Array.from(rowGroupsMap.entries()).map((_ref, index) => {\n        let [groupingValue, groupedRows] = _ref;\n        let id = `${columnId}:${groupingValue}`;\n        id = parentId ? `${parentId}>${id}` : id;\n\n        // First, Recurse to group sub rows before aggregation\n        const subRows = groupUpRecursively(groupedRows, depth + 1, id);\n        subRows.forEach(subRow => {\n          subRow.parentId = id;\n        });\n\n        // Flatten the leaf rows of the rows in this group\n        const leafRows = depth ? flattenBy(groupedRows, row => row.subRows) : groupedRows;\n        const row = createRow(table, id, leafRows[0].original, index, depth, undefined, parentId);\n        Object.assign(row, {\n          groupingColumnId: columnId,\n          groupingValue,\n          subRows,\n          leafRows,\n          getValue: columnId => {\n            // Don't aggregate columns that are in the grouping\n            if (existingGrouping.includes(columnId)) {\n              if (row._valuesCache.hasOwnProperty(columnId)) {\n                return row._valuesCache[columnId];\n              }\n              if (groupedRows[0]) {\n                var _groupedRows$0$getVal;\n                row._valuesCache[columnId] = (_groupedRows$0$getVal = groupedRows[0].getValue(columnId)) != null ? _groupedRows$0$getVal : undefined;\n              }\n              return row._valuesCache[columnId];\n            }\n            if (row._groupingValuesCache.hasOwnProperty(columnId)) {\n              return row._groupingValuesCache[columnId];\n            }\n\n            // Aggregate the values\n            const column = table.getColumn(columnId);\n            const aggregateFn = column == null ? void 0 : column.getAggregationFn();\n            if (aggregateFn) {\n              row._groupingValuesCache[columnId] = aggregateFn(columnId, leafRows, groupedRows);\n              return row._groupingValuesCache[columnId];\n            }\n          }\n        });\n        subRows.forEach(subRow => {\n          groupedFlatRows.push(subRow);\n          groupedRowsById[subRow.id] = subRow;\n          // if (subRow.getIsGrouped?.()) {\n          //   onlyGroupedFlatRows.push(subRow);\n          //   onlyGroupedRowsById[subRow.id] = subRow;\n          // } else {\n          //   nonGroupedFlatRows.push(subRow);\n          //   nonGroupedRowsById[subRow.id] = subRow;\n          // }\n        });\n        return row;\n      });\n      return aggregatedGroupedRows;\n    };\n    const groupedRows = groupUpRecursively(rowModel.rows, 0);\n    groupedRows.forEach(subRow => {\n      groupedFlatRows.push(subRow);\n      groupedRowsById[subRow.id] = subRow;\n      // if (subRow.getIsGrouped?.()) {\n      //   onlyGroupedFlatRows.push(subRow);\n      //   onlyGroupedRowsById[subRow.id] = subRow;\n      // } else {\n      //   nonGroupedFlatRows.push(subRow);\n      //   nonGroupedRowsById[subRow.id] = subRow;\n      // }\n    });\n    return {\n      rows: groupedRows,\n      flatRows: groupedFlatRows,\n      rowsById: groupedRowsById\n    };\n  }, getMemoOptions(table.options, 'debugTable', 'getGroupedRowModel', () => {\n    table._queue(() => {\n      table._autoResetExpanded();\n      table._autoResetPageIndex();\n    });\n  }));\n}\nfunction groupBy(rows, columnId) {\n  const groupMap = new Map();\n  return rows.reduce((map, row) => {\n    const resKey = `${row.getGroupingValue(columnId)}`;\n    const previous = map.get(resKey);\n    if (!previous) {\n      map.set(resKey, [row]);\n    } else {\n      previous.push(row);\n    }\n    return map;\n  }, groupMap);\n}\n\nfunction getPaginationRowModel(opts) {\n  return table => memo(() => [table.getState().pagination, table.getPrePaginationRowModel(), table.options.paginateExpandedRows ? undefined : table.getState().expanded], (pagination, rowModel) => {\n    if (!rowModel.rows.length) {\n      return rowModel;\n    }\n    const {\n      pageSize,\n      pageIndex\n    } = pagination;\n    let {\n      rows,\n      flatRows,\n      rowsById\n    } = rowModel;\n    const pageStart = pageSize * pageIndex;\n    const pageEnd = pageStart + pageSize;\n    rows = rows.slice(pageStart, pageEnd);\n    let paginatedRowModel;\n    if (!table.options.paginateExpandedRows) {\n      paginatedRowModel = expandRows({\n        rows,\n        flatRows,\n        rowsById\n      });\n    } else {\n      paginatedRowModel = {\n        rows,\n        flatRows,\n        rowsById\n      };\n    }\n    paginatedRowModel.flatRows = [];\n    const handleRow = row => {\n      paginatedRowModel.flatRows.push(row);\n      if (row.subRows.length) {\n        row.subRows.forEach(handleRow);\n      }\n    };\n    paginatedRowModel.rows.forEach(handleRow);\n    return paginatedRowModel;\n  }, getMemoOptions(table.options, 'debugTable', 'getPaginationRowModel'));\n}\n\nfunction getSortedRowModel() {\n  return table => memo(() => [table.getState().sorting, table.getPreSortedRowModel()], (sorting, rowModel) => {\n    if (!rowModel.rows.length || !(sorting != null && sorting.length)) {\n      return rowModel;\n    }\n    const sortingState = table.getState().sorting;\n    const sortedFlatRows = [];\n\n    // Filter out sortings that correspond to non existing columns\n    const availableSorting = sortingState.filter(sort => {\n      var _table$getColumn;\n      return (_table$getColumn = table.getColumn(sort.id)) == null ? void 0 : _table$getColumn.getCanSort();\n    });\n    const columnInfoById = {};\n    availableSorting.forEach(sortEntry => {\n      const column = table.getColumn(sortEntry.id);\n      if (!column) return;\n      columnInfoById[sortEntry.id] = {\n        sortUndefined: column.columnDef.sortUndefined,\n        invertSorting: column.columnDef.invertSorting,\n        sortingFn: column.getSortingFn()\n      };\n    });\n    const sortData = rows => {\n      // This will also perform a stable sorting using the row index\n      // if needed.\n      const sortedData = rows.map(row => ({\n        ...row\n      }));\n      sortedData.sort((rowA, rowB) => {\n        for (let i = 0; i < availableSorting.length; i += 1) {\n          var _sortEntry$desc;\n          const sortEntry = availableSorting[i];\n          const columnInfo = columnInfoById[sortEntry.id];\n          const sortUndefined = columnInfo.sortUndefined;\n          const isDesc = (_sortEntry$desc = sortEntry == null ? void 0 : sortEntry.desc) != null ? _sortEntry$desc : false;\n          let sortInt = 0;\n\n          // All sorting ints should always return in ascending order\n          if (sortUndefined) {\n            const aValue = rowA.getValue(sortEntry.id);\n            const bValue = rowB.getValue(sortEntry.id);\n            const aUndefined = aValue === undefined;\n            const bUndefined = bValue === undefined;\n            if (aUndefined || bUndefined) {\n              if (sortUndefined === 'first') return aUndefined ? -1 : 1;\n              if (sortUndefined === 'last') return aUndefined ? 1 : -1;\n              sortInt = aUndefined && bUndefined ? 0 : aUndefined ? sortUndefined : -sortUndefined;\n            }\n          }\n          if (sortInt === 0) {\n            sortInt = columnInfo.sortingFn(rowA, rowB, sortEntry.id);\n          }\n\n          // If sorting is non-zero, take care of desc and inversion\n          if (sortInt !== 0) {\n            if (isDesc) {\n              sortInt *= -1;\n            }\n            if (columnInfo.invertSorting) {\n              sortInt *= -1;\n            }\n            return sortInt;\n          }\n        }\n        return rowA.index - rowB.index;\n      });\n\n      // If there are sub-rows, sort them\n      sortedData.forEach(row => {\n        var _row$subRows;\n        sortedFlatRows.push(row);\n        if ((_row$subRows = row.subRows) != null && _row$subRows.length) {\n          row.subRows = sortData(row.subRows);\n        }\n      });\n      return sortedData;\n    };\n    return {\n      rows: sortData(rowModel.rows),\n      flatRows: sortedFlatRows,\n      rowsById: rowModel.rowsById\n    };\n  }, getMemoOptions(table.options, 'debugTable', 'getSortedRowModel', () => table._autoResetPageIndex()));\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUIsR0FBRyxvQkFBb0I7QUFDMUU7QUFDQTtBQUNBLHlCQUF5Qiw0REFBNEQsY0FBYztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxTQUFTLEtBQXNDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU8sR0FBRyxVQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQXFDO0FBQ25ELDZCQUE2QixJQUFJLDBCQUEwQixZQUFZO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw2REFBNkQ7QUFDekc7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdHQUFnRztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9HQUFvRztBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sS0FBSztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJKQUEySjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsZ0dBQWdHO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1DQUFtQztBQUN6RCxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUtBQWlLLDhDQUE4QztBQUMvTSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxJQUFxQztBQUNuRCxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1gsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQyxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEdBQUc7QUFDdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdFQUF3RSxTQUFTO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCwyRkFBMkYsVUFBVTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQ0FBa0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxHQUFHLGNBQWM7QUFDOUMsMkJBQTJCLFNBQVMsR0FBRyxHQUFHOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVvMEI7QUFDcDBCIiwic291cmNlcyI6WyIvaG9tZS9hZGVzb2xhL0Vwb2NoTGFiL0Vwb2NoRGFzaGJvYXJkL2pzL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdGFibGUtY29yZS9idWlsZC9saWIvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICAgKiB0YWJsZS1jb3JlXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgVGFuU3RhY2tcbiAgICpcbiAgICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gICAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUXG4gICAqL1xuLy8gdHlwZSBQZXJzb24gPSB7XG4vLyAgIGZpcnN0TmFtZTogc3RyaW5nXG4vLyAgIGxhc3ROYW1lOiBzdHJpbmdcbi8vICAgYWdlOiBudW1iZXJcbi8vICAgdmlzaXRzOiBudW1iZXJcbi8vICAgc3RhdHVzOiBzdHJpbmdcbi8vICAgcHJvZ3Jlc3M6IG51bWJlclxuLy8gICBjcmVhdGVkQXQ6IERhdGVcbi8vICAgbmVzdGVkOiB7XG4vLyAgICAgZm9vOiBbXG4vLyAgICAgICB7XG4vLyAgICAgICAgIGJhcjogJ2Jhcidcbi8vICAgICAgIH1cbi8vICAgICBdXG4vLyAgICAgYmFyOiB7IHN1YkJhcjogYm9vbGVhbiB9W11cbi8vICAgICBiYXo6IHtcbi8vICAgICAgIGZvbzogJ2Zvbydcbi8vICAgICAgIGJhcjoge1xuLy8gICAgICAgICBiYXo6ICdiYXonXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbi8vIGNvbnN0IHRlc3Q6IERlZXBLZXlzPFBlcnNvbj4gPSAnbmVzdGVkLmZvby4wLmJhcidcbi8vIGNvbnN0IHRlc3QyOiBEZWVwS2V5czxQZXJzb24+ID0gJ25lc3RlZC5iYXInXG5cbi8vIGNvbnN0IGhlbHBlciA9IGNyZWF0ZUNvbHVtbkhlbHBlcjxQZXJzb24+KClcblxuLy8gaGVscGVyLmFjY2Vzc29yKCduZXN0ZWQuZm9vJywge1xuLy8gICBjZWxsOiBpbmZvID0+IGluZm8uZ2V0VmFsdWUoKSxcbi8vIH0pXG5cbi8vIGhlbHBlci5hY2Nlc3NvcignbmVzdGVkLmZvby4wLmJhcicsIHtcbi8vICAgY2VsbDogaW5mbyA9PiBpbmZvLmdldFZhbHVlKCksXG4vLyB9KVxuXG4vLyBoZWxwZXIuYWNjZXNzb3IoJ25lc3RlZC5iYXInLCB7XG4vLyAgIGNlbGw6IGluZm8gPT4gaW5mby5nZXRWYWx1ZSgpLFxuLy8gfSlcblxuZnVuY3Rpb24gY3JlYXRlQ29sdW1uSGVscGVyKCkge1xuICByZXR1cm4ge1xuICAgIGFjY2Vzc29yOiAoYWNjZXNzb3IsIGNvbHVtbikgPT4ge1xuICAgICAgcmV0dXJuIHR5cGVvZiBhY2Nlc3NvciA9PT0gJ2Z1bmN0aW9uJyA/IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvckZuOiBhY2Nlc3NvclxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY29sdW1uLFxuICAgICAgICBhY2Nlc3NvcktleTogYWNjZXNzb3JcbiAgICAgIH07XG4gICAgfSxcbiAgICBkaXNwbGF5OiBjb2x1bW4gPT4gY29sdW1uLFxuICAgIGdyb3VwOiBjb2x1bW4gPT4gY29sdW1uXG4gIH07XG59XG5cbi8vIElzIHRoaXMgdHlwZSBhIHR1cGxlP1xuXG4vLyBJZiB0aGlzIHR5cGUgaXMgYSB0dXBsZSwgd2hhdCBpbmRpY2VzIGFyZSBhbGxvd2VkP1xuXG4vLy9cblxuZnVuY3Rpb24gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBpbnB1dCkge1xuICByZXR1cm4gdHlwZW9mIHVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyB1cGRhdGVyKGlucHV0KSA6IHVwZGF0ZXI7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAvL1xufVxuZnVuY3Rpb24gbWFrZVN0YXRlVXBkYXRlcihrZXksIGluc3RhbmNlKSB7XG4gIHJldHVybiB1cGRhdGVyID0+IHtcbiAgICBpbnN0YW5jZS5zZXRTdGF0ZShvbGQgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ub2xkLFxuICAgICAgICBba2V5XTogZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGRba2V5XSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGQpIHtcbiAgcmV0dXJuIGQgaW5zdGFuY2VvZiBGdW5jdGlvbjtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyQXJyYXkoZCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkKSAmJiBkLmV2ZXJ5KHZhbCA9PiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyk7XG59XG5mdW5jdGlvbiBmbGF0dGVuQnkoYXJyLCBnZXRDaGlsZHJlbikge1xuICBjb25zdCBmbGF0ID0gW107XG4gIGNvbnN0IHJlY3Vyc2UgPSBzdWJBcnIgPT4ge1xuICAgIHN1YkFyci5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgZmxhdC5wdXNoKGl0ZW0pO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpdGVtKTtcbiAgICAgIGlmIChjaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICByZWN1cnNlKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZShhcnIpO1xuICByZXR1cm4gZmxhdDtcbn1cbmZ1bmN0aW9uIG1lbW8oZ2V0RGVwcywgZm4sIG9wdHMpIHtcbiAgbGV0IGRlcHMgPSBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgcmV0dXJuIGRlcEFyZ3MgPT4ge1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcyhkZXBBcmdzKTtcbiAgICBjb25zdCBkZXBzQ2hhbmdlZCA9IG5ld0RlcHMubGVuZ3RoICE9PSBkZXBzLmxlbmd0aCB8fCBuZXdEZXBzLnNvbWUoKGRlcCwgaW5kZXgpID0+IGRlcHNbaW5kZXhdICE9PSBkZXApO1xuICAgIGlmICghZGVwc0NoYW5nZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRlcHMgPSBuZXdEZXBzO1xuICAgIGxldCByZXN1bHRUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiBvcHRzLmRlYnVnKSByZXN1bHRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICByZXN1bHQgPSBmbiguLi5uZXdEZXBzKTtcbiAgICBvcHRzID09IG51bGwgfHwgb3B0cy5vbkNoYW5nZSA9PSBudWxsIHx8IG9wdHMub25DaGFuZ2UocmVzdWx0KTtcbiAgICBpZiAob3B0cy5rZXkgJiYgb3B0cy5kZWJ1Zykge1xuICAgICAgaWYgKG9wdHMgIT0gbnVsbCAmJiBvcHRzLmRlYnVnKCkpIHtcbiAgICAgICAgY29uc3QgZGVwRW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSBkZXBUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgICBjb25zdCBwYWQgPSAoc3RyLCBudW0pID0+IHtcbiAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgICAgc3RyID0gJyAnICsgc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmluZm8oYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCwgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KDAsIE1hdGgubWluKDEyMCAtIDEyMCAqIHJlc3VsdEZwc1BlcmNlbnRhZ2UsIDEyMCkpfWRlZyAxMDAlIDMxJSk7YCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0TWVtb09wdGlvbnModGFibGVPcHRpb25zLCBkZWJ1Z0xldmVsLCBrZXksIG9uQ2hhbmdlKSB7XG4gIHJldHVybiB7XG4gICAgZGVidWc6ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGVPcHRpb25zJGRlYnVnQWw7XG4gICAgICByZXR1cm4gKF90YWJsZU9wdGlvbnMkZGVidWdBbCA9IHRhYmxlT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogdGFibGVPcHRpb25zLmRlYnVnQWxsKSAhPSBudWxsID8gX3RhYmxlT3B0aW9ucyRkZWJ1Z0FsIDogdGFibGVPcHRpb25zW2RlYnVnTGV2ZWxdO1xuICAgIH0sXG4gICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiBrZXksXG4gICAgb25DaGFuZ2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ2VsbCh0YWJsZSwgcm93LCBjb2x1bW4sIGNvbHVtbklkKSB7XG4gIGNvbnN0IGdldFJlbmRlclZhbHVlID0gKCkgPT4ge1xuICAgIHZhciBfY2VsbCRnZXRWYWx1ZTtcbiAgICByZXR1cm4gKF9jZWxsJGdldFZhbHVlID0gY2VsbC5nZXRWYWx1ZSgpKSAhPSBudWxsID8gX2NlbGwkZ2V0VmFsdWUgOiB0YWJsZS5vcHRpb25zLnJlbmRlckZhbGxiYWNrVmFsdWU7XG4gIH07XG4gIGNvbnN0IGNlbGwgPSB7XG4gICAgaWQ6IGAke3Jvdy5pZH1fJHtjb2x1bW4uaWR9YCxcbiAgICByb3csXG4gICAgY29sdW1uLFxuICAgIGdldFZhbHVlOiAoKSA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpLFxuICAgIHJlbmRlclZhbHVlOiBnZXRSZW5kZXJWYWx1ZSxcbiAgICBnZXRDb250ZXh0OiBtZW1vKCgpID0+IFt0YWJsZSwgY29sdW1uLCByb3csIGNlbGxdLCAodGFibGUsIGNvbHVtbiwgcm93LCBjZWxsKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBjb2x1bW4sXG4gICAgICByb3csXG4gICAgICBjZWxsOiBjZWxsLFxuICAgICAgZ2V0VmFsdWU6IGNlbGwuZ2V0VmFsdWUsXG4gICAgICByZW5kZXJWYWx1ZTogY2VsbC5yZW5kZXJWYWx1ZVxuICAgIH0pLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDZWxscycsICdjZWxsLmdldENvbnRleHQnKSlcbiAgfTtcbiAgdGFibGUuX2ZlYXR1cmVzLmZvckVhY2goZmVhdHVyZSA9PiB7XG4gICAgZmVhdHVyZS5jcmVhdGVDZWxsID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVDZWxsKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSk7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbHVtbih0YWJsZSwgY29sdW1uRGVmLCBkZXB0aCwgcGFyZW50KSB7XG4gIHZhciBfcmVmLCBfcmVzb2x2ZWRDb2x1bW5EZWYkaWQ7XG4gIGNvbnN0IGRlZmF1bHRDb2x1bW4gPSB0YWJsZS5fZ2V0RGVmYXVsdENvbHVtbkRlZigpO1xuICBjb25zdCByZXNvbHZlZENvbHVtbkRlZiA9IHtcbiAgICAuLi5kZWZhdWx0Q29sdW1uLFxuICAgIC4uLmNvbHVtbkRlZlxuICB9O1xuICBjb25zdCBhY2Nlc3NvcktleSA9IHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5O1xuICBsZXQgaWQgPSAoX3JlZiA9IChfcmVzb2x2ZWRDb2x1bW5EZWYkaWQgPSByZXNvbHZlZENvbHVtbkRlZi5pZCkgIT0gbnVsbCA/IF9yZXNvbHZlZENvbHVtbkRlZiRpZCA6IGFjY2Vzc29yS2V5ID8gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZUFsbCA9PT0gJ2Z1bmN0aW9uJyA/IGFjY2Vzc29yS2V5LnJlcGxhY2VBbGwoJy4nLCAnXycpIDogYWNjZXNzb3JLZXkucmVwbGFjZSgvXFwuL2csICdfJykgOiB1bmRlZmluZWQpICE9IG51bGwgPyBfcmVmIDogdHlwZW9mIHJlc29sdmVkQ29sdW1uRGVmLmhlYWRlciA9PT0gJ3N0cmluZycgPyByZXNvbHZlZENvbHVtbkRlZi5oZWFkZXIgOiB1bmRlZmluZWQ7XG4gIGxldCBhY2Nlc3NvckZuO1xuICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbikge1xuICAgIGFjY2Vzc29yRm4gPSByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvckZuO1xuICB9IGVsc2UgaWYgKGFjY2Vzc29yS2V5KSB7XG4gICAgLy8gU3VwcG9ydCBkZWVwIGFjY2Vzc29yIGtleXNcbiAgICBpZiAoYWNjZXNzb3JLZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsUm93O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhY2Nlc3NvcktleS5zcGxpdCgnLicpKSB7XG4gICAgICAgICAgdmFyIF9yZXN1bHQ7XG4gICAgICAgICAgcmVzdWx0ID0gKF9yZXN1bHQgPSByZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVzdWx0W2tleV07XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgXCIke2tleX1cIiBpbiBkZWVwbHkgbmVzdGVkIGtleSBcIiR7YWNjZXNzb3JLZXl9XCIgcmV0dXJuZWQgdW5kZWZpbmVkLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjZXNzb3JGbiA9IG9yaWdpbmFsUm93ID0+IG9yaWdpbmFsUm93W3Jlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yS2V5XTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JGbiA/IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhbiBhY2Nlc3NvckZuYCA6IGBDb2x1bW5zIHJlcXVpcmUgYW4gaWQgd2hlbiB1c2luZyBhIG5vbi1zdHJpbmcgaGVhZGVyYCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigpO1xuICB9XG4gIGxldCBjb2x1bW4gPSB7XG4gICAgaWQ6IGAke1N0cmluZyhpZCl9YCxcbiAgICBhY2Nlc3NvckZuLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGRlcHRoLFxuICAgIGNvbHVtbkRlZjogcmVzb2x2ZWRDb2x1bW5EZWYsXG4gICAgY29sdW1uczogW10sXG4gICAgZ2V0RmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RydWVdLCAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5zO1xuICAgICAgcmV0dXJuIFtjb2x1bW4sIC4uLigoX2NvbHVtbiRjb2x1bW5zID0gY29sdW1uLmNvbHVtbnMpID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1uJGNvbHVtbnMuZmxhdE1hcChkID0+IGQuZ2V0RmxhdENvbHVtbnMoKSkpXTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2NvbHVtbi5nZXRGbGF0Q29sdW1ucycpKSxcbiAgICBnZXRMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuKCldLCBvcmRlckNvbHVtbnMgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uczI7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1uczIgPSBjb2x1bW4uY29sdW1ucykgIT0gbnVsbCAmJiBfY29sdW1uJGNvbHVtbnMyLmxlbmd0aCkge1xuICAgICAgICBsZXQgbGVhZkNvbHVtbnMgPSBjb2x1bW4uY29sdW1ucy5mbGF0TWFwKGNvbHVtbiA9PiBjb2x1bW4uZ2V0TGVhZkNvbHVtbnMoKSk7XG4gICAgICAgIHJldHVybiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5dO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnY29sdW1uLmdldExlYWZDb2x1bW5zJykpXG4gIH07XG4gIGZvciAoY29uc3QgZmVhdHVyZSBvZiB0YWJsZS5fZmVhdHVyZXMpIHtcbiAgICBmZWF0dXJlLmNyZWF0ZUNvbHVtbiA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlQ29sdW1uKGNvbHVtbiwgdGFibGUpO1xuICB9XG5cbiAgLy8gWWVzLCB3ZSBoYXZlIHRvIGNvbnZlcnQgdGFibGUgdG8gdW5rbm93biwgYmVjYXVzZSB3ZSBrbm93IG1vcmUgdGhhbiB0aGUgY29tcGlsZXIgaGVyZS5cbiAgcmV0dXJuIGNvbHVtbjtcbn1cblxuY29uc3QgZGVidWcgPSAnZGVidWdIZWFkZXJzJztcbi8vXG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRpZDtcbiAgY29uc3QgaWQgPSAoX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkKSAhPSBudWxsID8gX29wdGlvbnMkaWQgOiBjb2x1bW4uaWQ7XG4gIGxldCBoZWFkZXIgPSB7XG4gICAgaWQsXG4gICAgY29sdW1uLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGlzUGxhY2Vob2xkZXI6ICEhb3B0aW9ucy5pc1BsYWNlaG9sZGVyLFxuICAgIHBsYWNlaG9sZGVySWQ6IG9wdGlvbnMucGxhY2Vob2xkZXJJZCxcbiAgICBkZXB0aDogb3B0aW9ucy5kZXB0aCxcbiAgICBzdWJIZWFkZXJzOiBbXSxcbiAgICBjb2xTcGFuOiAwLFxuICAgIHJvd1NwYW46IDAsXG4gICAgaGVhZGVyR3JvdXA6IG51bGwsXG4gICAgZ2V0TGVhZkhlYWRlcnM6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZIZWFkZXJzID0gW107XG4gICAgICBjb25zdCByZWN1cnNlSGVhZGVyID0gaCA9PiB7XG4gICAgICAgIGlmIChoLnN1YkhlYWRlcnMgJiYgaC5zdWJIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGguc3ViSGVhZGVycy5tYXAocmVjdXJzZUhlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVhZkhlYWRlcnMucHVzaChoKTtcbiAgICAgIH07XG4gICAgICByZWN1cnNlSGVhZGVyKGhlYWRlcik7XG4gICAgICByZXR1cm4gbGVhZkhlYWRlcnM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiAoKSA9PiAoe1xuICAgICAgdGFibGUsXG4gICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgIGNvbHVtblxuICAgIH0pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIGZlYXR1cmUuY3JlYXRlSGVhZGVyID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVIZWFkZXIoaGVhZGVyLCB0YWJsZSk7XG4gIH0pO1xuICByZXR1cm4gaGVhZGVyO1xufVxuY29uc3QgSGVhZGVycyA9IHtcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICAvLyBIZWFkZXIgR3JvdXBzXG5cbiAgICB0YWJsZS5nZXRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JG1hcCRmaWx0ZXIsIF9yaWdodCRtYXAkZmlsdGVyO1xuICAgICAgY29uc3QgbGVmdENvbHVtbnMgPSAoX2xlZnQkbWFwJGZpbHRlciA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IHJpZ2h0Q29sdW1ucyA9IChfcmlnaHQkbWFwJGZpbHRlciA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIgOiBbXTtcbiAgICAgIGNvbnN0IGNlbnRlckNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIGNvbnN0IGhlYWRlckdyb3VwcyA9IGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIFsuLi5sZWZ0Q29sdW1ucywgLi4uY2VudGVyQ29sdW1ucywgLi4ucmlnaHRDb2x1bW5zXSwgdGFibGUpO1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3VwcztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcubGVmdCwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENvbHVtbnMsIGxlYWZDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgbGVhZkNvbHVtbnMgPSBsZWFmQ29sdW1ucy5maWx0ZXIoY29sdW1uID0+ICEobGVmdCAhPSBudWxsICYmIGxlZnQuaW5jbHVkZXMoY29sdW1uLmlkKSkgJiYgIShyaWdodCAhPSBudWxsICYmIHJpZ2h0LmluY2x1ZGVzKGNvbHVtbi5pZCkpKTtcbiAgICAgIHJldHVybiBidWlsZEhlYWRlckdyb3VwcyhhbGxDb2x1bW5zLCBsZWFmQ29sdW1ucywgdGFibGUsICdjZW50ZXInKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldENlbnRlckhlYWRlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRMZWZ0SGVhZGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHZhciBfbGVmdCRtYXAkZmlsdGVyMjtcbiAgICAgIGNvbnN0IG9yZGVyZWRMZWFmQ29sdW1ucyA9IChfbGVmdCRtYXAkZmlsdGVyMiA9IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQubWFwKGNvbHVtbklkID0+IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW5JZCkpLmZpbHRlcihCb29sZWFuKSkgIT0gbnVsbCA/IF9sZWZ0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ2xlZnQnKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldExlZnRIZWFkZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxDb2x1bW5zKCksIHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgbGVhZkNvbHVtbnMsIHJpZ2h0KSA9PiB7XG4gICAgICB2YXIgX3JpZ2h0JG1hcCRmaWx0ZXIyO1xuICAgICAgY29uc3Qgb3JkZXJlZExlYWZDb2x1bW5zID0gKF9yaWdodCRtYXAkZmlsdGVyMiA9IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5tYXAoY29sdW1uSWQgPT4gbGVhZkNvbHVtbnMuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pKSAhPSBudWxsID8gX3JpZ2h0JG1hcCRmaWx0ZXIyIDogW107XG4gICAgICByZXR1cm4gYnVpbGRIZWFkZXJHcm91cHMoYWxsQ29sdW1ucywgb3JkZXJlZExlYWZDb2x1bW5zLCB0YWJsZSwgJ3JpZ2h0Jyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEhlYWRlckdyb3VwcycpKTtcblxuICAgIC8vIEZvb3RlciBHcm91cHNcblxuICAgIHRhYmxlLmdldEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEhlYWRlckdyb3VwcygpXSwgaGVhZGVyR3JvdXBzID0+IHtcbiAgICAgIHJldHVybiBbLi4uaGVhZGVyR3JvdXBzXS5yZXZlcnNlKCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRGb290ZXJHcm91cHMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdEZvb3Rlckdyb3VwcyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdEZvb3Rlckdyb3VwcycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJGb290ZXJHcm91cHMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyRm9vdGVyR3JvdXBzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0Rm9vdGVyR3JvdXBzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGhlYWRlckdyb3VwcyA9PiB7XG4gICAgICByZXR1cm4gWy4uLmhlYWRlckdyb3Vwc10ucmV2ZXJzZSgpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRGb290ZXJHcm91cHMnKSk7XG5cbiAgICAvLyBGbGF0IEhlYWRlcnNcblxuICAgIHRhYmxlLmdldEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0SGVhZGVyR3JvdXBzKCldLCBoZWFkZXJHcm91cHMgPT4ge1xuICAgICAgcmV0dXJuIGhlYWRlckdyb3Vwcy5tYXAoaGVhZGVyR3JvdXAgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyR3JvdXAuaGVhZGVycztcbiAgICAgIH0pLmZsYXQoKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCBkZWJ1ZywgJ2dldEZsYXRIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldExlZnRGbGF0SGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWZ0RmxhdEhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0Q2VudGVyRmxhdEhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRDZW50ZXJIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRDZW50ZXJGbGF0SGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKV0sIGxlZnQgPT4ge1xuICAgICAgcmV0dXJuIGxlZnQubWFwKGhlYWRlckdyb3VwID0+IHtcbiAgICAgICAgcmV0dXJuIGhlYWRlckdyb3VwLmhlYWRlcnM7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRSaWdodEZsYXRIZWFkZXJzJykpO1xuXG4gICAgLy8gTGVhZiBIZWFkZXJzXG5cbiAgICB0YWJsZS5nZXRDZW50ZXJMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldENlbnRlckZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnM7XG4gICAgICAgIHJldHVybiAhKChfaGVhZGVyJHN1YkhlYWRlcnMgPSBoZWFkZXIuc3ViSGVhZGVycykgIT0gbnVsbCAmJiBfaGVhZGVyJHN1YkhlYWRlcnMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0Q2VudGVyTGVhZkhlYWRlcnMnKSk7XG4gICAgdGFibGUuZ2V0TGVmdExlYWZIZWFkZXJzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0TGVmdEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMyO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMiA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczIubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0TGVmdExlYWZIZWFkZXJzJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkhlYWRlcnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRSaWdodEZsYXRIZWFkZXJzKCldLCBmbGF0SGVhZGVycyA9PiB7XG4gICAgICByZXR1cm4gZmxhdEhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiB7XG4gICAgICAgIHZhciBfaGVhZGVyJHN1YkhlYWRlcnMzO1xuICAgICAgICByZXR1cm4gISgoX2hlYWRlciRzdWJIZWFkZXJzMyA9IGhlYWRlci5zdWJIZWFkZXJzKSAhPSBudWxsICYmIF9oZWFkZXIkc3ViSGVhZGVyczMubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsIGRlYnVnLCAnZ2V0UmlnaHRMZWFmSGVhZGVycycpKTtcbiAgICB0YWJsZS5nZXRMZWFmSGVhZGVycyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldExlZnRIZWFkZXJHcm91cHMoKSwgdGFibGUuZ2V0Q2VudGVySGVhZGVyR3JvdXBzKCksIHRhYmxlLmdldFJpZ2h0SGVhZGVyR3JvdXBzKCldLCAobGVmdCwgY2VudGVyLCByaWdodCkgPT4ge1xuICAgICAgdmFyIF9sZWZ0JDAkaGVhZGVycywgX2xlZnQkLCBfY2VudGVyJDAkaGVhZGVycywgX2NlbnRlciQsIF9yaWdodCQwJGhlYWRlcnMsIF9yaWdodCQ7XG4gICAgICByZXR1cm4gWy4uLigoX2xlZnQkMCRoZWFkZXJzID0gKF9sZWZ0JCA9IGxlZnRbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbGVmdCQuaGVhZGVycykgIT0gbnVsbCA/IF9sZWZ0JDAkaGVhZGVycyA6IFtdKSwgLi4uKChfY2VudGVyJDAkaGVhZGVycyA9IChfY2VudGVyJCA9IGNlbnRlclswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jZW50ZXIkLmhlYWRlcnMpICE9IG51bGwgPyBfY2VudGVyJDAkaGVhZGVycyA6IFtdKSwgLi4uKChfcmlnaHQkMCRoZWFkZXJzID0gKF9yaWdodCQgPSByaWdodFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yaWdodCQuaGVhZGVycykgIT0gbnVsbCA/IF9yaWdodCQwJGhlYWRlcnMgOiBbXSldLm1hcChoZWFkZXIgPT4ge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmdldExlYWZIZWFkZXJzKCk7XG4gICAgICB9KS5mbGF0KCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgZGVidWcsICdnZXRMZWFmSGVhZGVycycpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyR3JvdXBzKGFsbENvbHVtbnMsIGNvbHVtbnNUb0dyb3VwLCB0YWJsZSwgaGVhZGVyRmFtaWx5KSB7XG4gIHZhciBfaGVhZGVyR3JvdXBzJDAkaGVhZGUsIF9oZWFkZXJHcm91cHMkO1xuICAvLyBGaW5kIHRoZSBtYXggZGVwdGggb2YgdGhlIGNvbHVtbnM6XG4gIC8vIGJ1aWxkIHRoZSBsZWFmIGNvbHVtbiByb3dcbiAgLy8gYnVpbGQgZWFjaCBidWZmZXIgcm93IGdvaW5nIHVwXG4gIC8vICAgIHBsYWNlaG9sZGVyIGZvciBub24tZXhpc3RlbnQgbGV2ZWxcbiAgLy8gICAgcmVhbCBjb2x1bW4gZm9yIGV4aXN0aW5nIGxldmVsXG5cbiAgbGV0IG1heERlcHRoID0gMDtcbiAgY29uc3QgZmluZE1heERlcHRoID0gZnVuY3Rpb24gKGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMTtcbiAgICB9XG4gICAgbWF4RGVwdGggPSBNYXRoLm1heChtYXhEZXB0aCwgZGVwdGgpO1xuICAgIGNvbHVtbnMuZmlsdGVyKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpLmZvckVhY2goY29sdW1uID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbnM7XG4gICAgICBpZiAoKF9jb2x1bW4kY29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zKSAhPSBudWxsICYmIF9jb2x1bW4kY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgZmluZE1heERlcHRoKGNvbHVtbi5jb2x1bW5zLCBkZXB0aCArIDEpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuICBmaW5kTWF4RGVwdGgoYWxsQ29sdW1ucyk7XG4gIGxldCBoZWFkZXJHcm91cHMgPSBbXTtcbiAgY29uc3QgY3JlYXRlSGVhZGVyR3JvdXAgPSAoaGVhZGVyc1RvR3JvdXAsIGRlcHRoKSA9PiB7XG4gICAgLy8gVGhlIGhlYWRlciBncm91cCB3ZSBhcmUgY3JlYXRpbmdcbiAgICBjb25zdCBoZWFkZXJHcm91cCA9IHtcbiAgICAgIGRlcHRoLFxuICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGAke2RlcHRofWBdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICBoZWFkZXJzOiBbXVxuICAgIH07XG5cbiAgICAvLyBUaGUgcGFyZW50IGNvbHVtbnMgd2UncmUgZ29pbmcgdG8gc2NhbiBuZXh0XG4gICAgY29uc3QgcGVuZGluZ1BhcmVudEhlYWRlcnMgPSBbXTtcblxuICAgIC8vIFNjYW4gZWFjaCBjb2x1bW4gZm9yIHBhcmVudHNcbiAgICBoZWFkZXJzVG9Hcm91cC5mb3JFYWNoKGhlYWRlclRvR3JvdXAgPT4ge1xuICAgICAgLy8gV2hhdCBpcyB0aGUgbGF0ZXN0IChsYXN0KSBwYXJlbnQgY29sdW1uP1xuXG4gICAgICBjb25zdCBsYXRlc3RQZW5kaW5nUGFyZW50SGVhZGVyID0gWy4uLnBlbmRpbmdQYXJlbnRIZWFkZXJzXS5yZXZlcnNlKClbMF07XG4gICAgICBjb25zdCBpc0xlYWZIZWFkZXIgPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5kZXB0aCA9PT0gaGVhZGVyR3JvdXAuZGVwdGg7XG4gICAgICBsZXQgY29sdW1uO1xuICAgICAgbGV0IGlzUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgICAgIGlmIChpc0xlYWZIZWFkZXIgJiYgaGVhZGVyVG9Hcm91cC5jb2x1bW4ucGFyZW50KSB7XG4gICAgICAgIC8vIFRoZSBwYXJlbnQgaGVhZGVyIGlzIG5ld1xuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbi5wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcGFyZW50IGhlYWRlciBpcyByZXBlYXRlZFxuICAgICAgICBjb2x1bW4gPSBoZWFkZXJUb0dyb3VwLmNvbHVtbjtcbiAgICAgICAgaXNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciAmJiAobGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlciA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5jb2x1bW4pID09PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gVGhpcyBjb2x1bW4gaXMgcmVwZWF0ZWQuIEFkZCBpdCBhcyBhIHN1YiBoZWFkZXIgdG8gdGhlIG5leHQgYmF0Y2hcbiAgICAgICAgbGF0ZXN0UGVuZGluZ1BhcmVudEhlYWRlci5zdWJIZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IGhlYWRlci4gTGV0J3MgY3JlYXRlIGl0XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGNyZWF0ZUhlYWRlcih0YWJsZSwgY29sdW1uLCB7XG4gICAgICAgICAgaWQ6IFtoZWFkZXJGYW1pbHksIGRlcHRoLCBjb2x1bW4uaWQsIGhlYWRlclRvR3JvdXAgPT0gbnVsbCA/IHZvaWQgMCA6IGhlYWRlclRvR3JvdXAuaWRdLmZpbHRlcihCb29sZWFuKS5qb2luKCdfJyksXG4gICAgICAgICAgaXNQbGFjZWhvbGRlcixcbiAgICAgICAgICBwbGFjZWhvbGRlcklkOiBpc1BsYWNlaG9sZGVyID8gYCR7cGVuZGluZ1BhcmVudEhlYWRlcnMuZmlsdGVyKGQgPT4gZC5jb2x1bW4gPT09IGNvbHVtbikubGVuZ3RofWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgaW5kZXg6IHBlbmRpbmdQYXJlbnRIZWFkZXJzLmxlbmd0aFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBBZGQgdGhlIGhlYWRlclRvR3JvdXAgYXMgYSBzdWJIZWFkZXIgb2YgdGhlIG5ldyBoZWFkZXJcbiAgICAgICAgaGVhZGVyLnN1YkhlYWRlcnMucHVzaChoZWFkZXJUb0dyb3VwKTtcbiAgICAgICAgLy8gQWRkIHRoZSBuZXcgaGVhZGVyIHRvIHRoZSBwZW5kaW5nUGFyZW50SGVhZGVycyB0byBnZXQgZ3JvdXBlZFxuICAgICAgICAvLyBpbiB0aGUgbmV4dCBiYXRjaFxuICAgICAgICBwZW5kaW5nUGFyZW50SGVhZGVycy5wdXNoKGhlYWRlcik7XG4gICAgICB9XG4gICAgICBoZWFkZXJHcm91cC5oZWFkZXJzLnB1c2goaGVhZGVyVG9Hcm91cCk7XG4gICAgICBoZWFkZXJUb0dyb3VwLmhlYWRlckdyb3VwID0gaGVhZGVyR3JvdXA7XG4gICAgfSk7XG4gICAgaGVhZGVyR3JvdXBzLnB1c2goaGVhZGVyR3JvdXApO1xuICAgIGlmIChkZXB0aCA+IDApIHtcbiAgICAgIGNyZWF0ZUhlYWRlckdyb3VwKHBlbmRpbmdQYXJlbnRIZWFkZXJzLCBkZXB0aCAtIDEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgYm90dG9tSGVhZGVycyA9IGNvbHVtbnNUb0dyb3VwLm1hcCgoY29sdW1uLCBpbmRleCkgPT4gY3JlYXRlSGVhZGVyKHRhYmxlLCBjb2x1bW4sIHtcbiAgICBkZXB0aDogbWF4RGVwdGgsXG4gICAgaW5kZXhcbiAgfSkpO1xuICBjcmVhdGVIZWFkZXJHcm91cChib3R0b21IZWFkZXJzLCBtYXhEZXB0aCAtIDEpO1xuICBoZWFkZXJHcm91cHMucmV2ZXJzZSgpO1xuXG4gIC8vIGhlYWRlckdyb3VwcyA9IGhlYWRlckdyb3Vwcy5maWx0ZXIoaGVhZGVyR3JvdXAgPT4ge1xuICAvLyAgIHJldHVybiAhaGVhZGVyR3JvdXAuaGVhZGVycy5ldmVyeShoZWFkZXIgPT4gaGVhZGVyLmlzUGxhY2Vob2xkZXIpXG4gIC8vIH0pXG5cbiAgY29uc3QgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyA9IGhlYWRlcnMgPT4ge1xuICAgIGNvbnN0IGZpbHRlcmVkSGVhZGVycyA9IGhlYWRlcnMuZmlsdGVyKGhlYWRlciA9PiBoZWFkZXIuY29sdW1uLmdldElzVmlzaWJsZSgpKTtcbiAgICByZXR1cm4gZmlsdGVyZWRIZWFkZXJzLm1hcChoZWFkZXIgPT4ge1xuICAgICAgbGV0IGNvbFNwYW4gPSAwO1xuICAgICAgbGV0IHJvd1NwYW4gPSAwO1xuICAgICAgbGV0IGNoaWxkUm93U3BhbnMgPSBbMF07XG4gICAgICBpZiAoaGVhZGVyLnN1YkhlYWRlcnMgJiYgaGVhZGVyLnN1YkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNoaWxkUm93U3BhbnMgPSBbXTtcbiAgICAgICAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucyhoZWFkZXIuc3ViSGVhZGVycykuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY29sU3BhbjogY2hpbGRDb2xTcGFuLFxuICAgICAgICAgICAgcm93U3BhbjogY2hpbGRSb3dTcGFuXG4gICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgY29sU3BhbiArPSBjaGlsZENvbFNwYW47XG4gICAgICAgICAgY2hpbGRSb3dTcGFucy5wdXNoKGNoaWxkUm93U3Bhbik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sU3BhbiA9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBtaW5DaGlsZFJvd1NwYW4gPSBNYXRoLm1pbiguLi5jaGlsZFJvd1NwYW5zKTtcbiAgICAgIHJvd1NwYW4gPSByb3dTcGFuICsgbWluQ2hpbGRSb3dTcGFuO1xuICAgICAgaGVhZGVyLmNvbFNwYW4gPSBjb2xTcGFuO1xuICAgICAgaGVhZGVyLnJvd1NwYW4gPSByb3dTcGFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sU3BhbixcbiAgICAgICAgcm93U3BhblxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbiAgcmVjdXJzZUhlYWRlcnNGb3JTcGFucygoX2hlYWRlckdyb3VwcyQwJGhlYWRlID0gKF9oZWFkZXJHcm91cHMkID0gaGVhZGVyR3JvdXBzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRlckdyb3VwcyQuaGVhZGVycykgIT0gbnVsbCA/IF9oZWFkZXJHcm91cHMkMCRoZWFkZSA6IFtdKTtcbiAgcmV0dXJuIGhlYWRlckdyb3Vwcztcbn1cblxuY29uc3QgY3JlYXRlUm93ID0gKHRhYmxlLCBpZCwgb3JpZ2luYWwsIHJvd0luZGV4LCBkZXB0aCwgc3ViUm93cywgcGFyZW50SWQpID0+IHtcbiAgbGV0IHJvdyA9IHtcbiAgICBpZCxcbiAgICBpbmRleDogcm93SW5kZXgsXG4gICAgb3JpZ2luYWwsXG4gICAgZGVwdGgsXG4gICAgcGFyZW50SWQsXG4gICAgX3ZhbHVlc0NhY2hlOiB7fSxcbiAgICBfdW5pcXVlVmFsdWVzQ2FjaGU6IHt9LFxuICAgIGdldFZhbHVlOiBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll92YWx1ZXNDYWNoZS5oYXNPd25Qcm9wZXJ0eShjb2x1bW5JZCkpIHtcbiAgICAgICAgcmV0dXJuIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgfVxuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKTtcbiAgICAgIGlmICghKGNvbHVtbiAhPSBudWxsICYmIGNvbHVtbi5hY2Nlc3NvckZuKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBjb2x1bW4uYWNjZXNzb3JGbihyb3cub3JpZ2luYWwsIHJvd0luZGV4KTtcbiAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICB9LFxuICAgIGdldFVuaXF1ZVZhbHVlczogY29sdW1uSWQgPT4ge1xuICAgICAgaWYgKHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGUuaGFzT3duUHJvcGVydHkoY29sdW1uSWQpKSB7XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uYWNjZXNzb3JGbikpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICghY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMpIHtcbiAgICAgICAgcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF0gPSBbcm93LmdldFZhbHVlKGNvbHVtbklkKV07XG4gICAgICAgIHJldHVybiByb3cuX3VuaXF1ZVZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIHJvdy5fdW5pcXVlVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gY29sdW1uLmNvbHVtbkRlZi5nZXRVbmlxdWVWYWx1ZXMocm93Lm9yaWdpbmFsLCByb3dJbmRleCk7XG4gICAgICByZXR1cm4gcm93Ll91bmlxdWVWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfSxcbiAgICByZW5kZXJWYWx1ZTogY29sdW1uSWQgPT4ge1xuICAgICAgdmFyIF9yb3ckZ2V0VmFsdWU7XG4gICAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKSAhPSBudWxsID8gX3JvdyRnZXRWYWx1ZSA6IHRhYmxlLm9wdGlvbnMucmVuZGVyRmFsbGJhY2tWYWx1ZTtcbiAgICB9LFxuICAgIHN1YlJvd3M6IHN1YlJvd3MgIT0gbnVsbCA/IHN1YlJvd3MgOiBbXSxcbiAgICBnZXRMZWFmUm93czogKCkgPT4gZmxhdHRlbkJ5KHJvdy5zdWJSb3dzLCBkID0+IGQuc3ViUm93cyksXG4gICAgZ2V0UGFyZW50Um93OiAoKSA9PiByb3cucGFyZW50SWQgPyB0YWJsZS5nZXRSb3cocm93LnBhcmVudElkLCB0cnVlKSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQYXJlbnRSb3dzOiAoKSA9PiB7XG4gICAgICBsZXQgcGFyZW50Um93cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnRSb3cgPSByb3c7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRSb3cgPSBjdXJyZW50Um93LmdldFBhcmVudFJvdygpO1xuICAgICAgICBpZiAoIXBhcmVudFJvdykgYnJlYWs7XG4gICAgICAgIHBhcmVudFJvd3MucHVzaChwYXJlbnRSb3cpO1xuICAgICAgICBjdXJyZW50Um93ID0gcGFyZW50Um93O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFJvd3MucmV2ZXJzZSgpO1xuICAgIH0sXG4gICAgZ2V0QWxsQ2VsbHM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCldLCBsZWFmQ29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMubWFwKGNvbHVtbiA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHRhYmxlLCByb3csIGNvbHVtbiwgY29sdW1uLmlkKTtcbiAgICAgIH0pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0QWxsQ2VsbHMnKSksXG4gICAgX2dldEFsbENlbGxzQnlDb2x1bW5JZDogbWVtbygoKSA9PiBbcm93LmdldEFsbENlbGxzKCldLCBhbGxDZWxscyA9PiB7XG4gICAgICByZXR1cm4gYWxsQ2VsbHMucmVkdWNlKChhY2MsIGNlbGwpID0+IHtcbiAgICAgICAgYWNjW2NlbGwuY29sdW1uLmlkXSA9IGNlbGw7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LCB7fSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRBbGxDZWxsc0J5Q29sdW1uSWQnKSlcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZS5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBmZWF0dXJlID0gdGFibGUuX2ZlYXR1cmVzW2ldO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVJvdyA9PSBudWxsIHx8IGZlYXR1cmUuY3JlYXRlUm93KHJvdywgdGFibGUpO1xuICB9XG4gIHJldHVybiByb3c7XG59O1xuXG4vL1xuXG5jb25zdCBDb2x1bW5GYWNldGluZyA9IHtcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5fZ2V0RmFjZXRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkUm93TW9kZWwodGFibGUsIGNvbHVtbi5pZCk7XG4gICAgY29sdW1uLmdldEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gICAgY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgY29sdW1uLmlkKTtcbiAgICBjb2x1bW4uZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1uLl9nZXRGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgPSB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMgJiYgdGFibGUub3B0aW9ucy5nZXRGYWNldGVkTWluTWF4VmFsdWVzKHRhYmxlLCBjb2x1bW4uaWQpO1xuICAgIGNvbHVtbi5nZXRGYWNldGVkTWluTWF4VmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCFjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW4uX2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBpbmNsdWRlc1N0cmluZyA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX2ZpbHRlclZhbHVlJHRvU3RyaW5nLCBfcm93JGdldFZhbHVlO1xuICBjb25zdCBzZWFyY2ggPSBmaWx0ZXJWYWx1ZSA9PSBudWxsIHx8IChfZmlsdGVyVmFsdWUkdG9TdHJpbmcgPSBmaWx0ZXJWYWx1ZS50b1N0cmluZygpKSA9PSBudWxsID8gdm9pZCAwIDogX2ZpbHRlclZhbHVlJHRvU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9TdHJpbmcoKSkgPT0gbnVsbCB8fCAoX3JvdyRnZXRWYWx1ZSA9IF9yb3ckZ2V0VmFsdWUudG9Mb3dlckNhc2UoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUuaW5jbHVkZXMoc2VhcmNoKSk7XG59O1xuaW5jbHVkZXNTdHJpbmcuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbmNsdWRlc1N0cmluZ1NlbnNpdGl2ZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICB2YXIgX3JvdyRnZXRWYWx1ZTI7XG4gIHJldHVybiBCb29sZWFuKChfcm93JGdldFZhbHVlMiA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUyID0gX3JvdyRnZXRWYWx1ZTIudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUyLmluY2x1ZGVzKGZpbHRlclZhbHVlKSk7XG59O1xuaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBlcXVhbHNTdHJpbmcgPSAocm93LCBjb2x1bW5JZCwgZmlsdGVyVmFsdWUpID0+IHtcbiAgdmFyIF9yb3ckZ2V0VmFsdWUzO1xuICByZXR1cm4gKChfcm93JGdldFZhbHVlMyA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgfHwgKF9yb3ckZ2V0VmFsdWUzID0gX3JvdyRnZXRWYWx1ZTMudG9TdHJpbmcoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWUzLnRvTG93ZXJDYXNlKCkpID09PSAoZmlsdGVyVmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IGZpbHRlclZhbHVlLnRvTG93ZXJDYXNlKCkpO1xufTtcbmVxdWFsc1N0cmluZy5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKTtcbmNvbnN0IGFyckluY2x1ZGVzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHZhciBfcm93JGdldFZhbHVlNDtcbiAgcmV0dXJuIChfcm93JGdldFZhbHVlNCA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCkpID09IG51bGwgPyB2b2lkIDAgOiBfcm93JGdldFZhbHVlNC5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSk7XG59O1xuYXJySW5jbHVkZXMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBhcnJJbmNsdWRlc0FsbCA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gIWZpbHRlclZhbHVlLnNvbWUodmFsID0+IHtcbiAgICB2YXIgX3JvdyRnZXRWYWx1ZTU7XG4gICAgcmV0dXJuICEoKF9yb3ckZ2V0VmFsdWU1ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCAmJiBfcm93JGdldFZhbHVlNS5pbmNsdWRlcyh2YWwpKTtcbiAgfSk7XG59O1xuYXJySW5jbHVkZXNBbGwuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCkgfHwgISh2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoKTtcbmNvbnN0IGFyckluY2x1ZGVzU29tZSA9IChyb3csIGNvbHVtbklkLCBmaWx0ZXJWYWx1ZSkgPT4ge1xuICByZXR1cm4gZmlsdGVyVmFsdWUuc29tZSh2YWwgPT4ge1xuICAgIHZhciBfcm93JGdldFZhbHVlNjtcbiAgICByZXR1cm4gKF9yb3ckZ2V0VmFsdWU2ID0gcm93LmdldFZhbHVlKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3ckZ2V0VmFsdWU2LmluY2x1ZGVzKHZhbCk7XG4gIH0pO1xufTtcbmFyckluY2x1ZGVzU29tZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCAhKHZhbCAhPSBudWxsICYmIHZhbC5sZW5ndGgpO1xuY29uc3QgZXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09PSBmaWx0ZXJWYWx1ZTtcbn07XG5lcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCB3ZWFrRXF1YWxzID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpID09IGZpbHRlclZhbHVlO1xufTtcbndlYWtFcXVhbHMuYXV0b1JlbW92ZSA9IHZhbCA9PiB0ZXN0RmFsc2V5KHZhbCk7XG5jb25zdCBpbk51bWJlclJhbmdlID0gKHJvdywgY29sdW1uSWQsIGZpbHRlclZhbHVlKSA9PiB7XG4gIGxldCBbbWluLCBtYXhdID0gZmlsdGVyVmFsdWU7XG4gIGNvbnN0IHJvd1ZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgcmV0dXJuIHJvd1ZhbHVlID49IG1pbiAmJiByb3dWYWx1ZSA8PSBtYXg7XG59O1xuaW5OdW1iZXJSYW5nZS5yZXNvbHZlRmlsdGVyVmFsdWUgPSB2YWwgPT4ge1xuICBsZXQgW3Vuc2FmZU1pbiwgdW5zYWZlTWF4XSA9IHZhbDtcbiAgbGV0IHBhcnNlZE1pbiA9IHR5cGVvZiB1bnNhZmVNaW4gIT09ICdudW1iZXInID8gcGFyc2VGbG9hdCh1bnNhZmVNaW4pIDogdW5zYWZlTWluO1xuICBsZXQgcGFyc2VkTWF4ID0gdHlwZW9mIHVuc2FmZU1heCAhPT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHVuc2FmZU1heCkgOiB1bnNhZmVNYXg7XG4gIGxldCBtaW4gPSB1bnNhZmVNaW4gPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1pbikgPyAtSW5maW5pdHkgOiBwYXJzZWRNaW47XG4gIGxldCBtYXggPSB1bnNhZmVNYXggPT09IG51bGwgfHwgTnVtYmVyLmlzTmFOKHBhcnNlZE1heCkgPyBJbmZpbml0eSA6IHBhcnNlZE1heDtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIGNvbnN0IHRlbXAgPSBtaW47XG4gICAgbWluID0gbWF4O1xuICAgIG1heCA9IHRlbXA7XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuaW5OdW1iZXJSYW5nZS5hdXRvUmVtb3ZlID0gdmFsID0+IHRlc3RGYWxzZXkodmFsKSB8fCB0ZXN0RmFsc2V5KHZhbFswXSkgJiYgdGVzdEZhbHNleSh2YWxbMV0pO1xuXG4vLyBFeHBvcnRcblxuY29uc3QgZmlsdGVyRm5zID0ge1xuICBpbmNsdWRlc1N0cmluZyxcbiAgaW5jbHVkZXNTdHJpbmdTZW5zaXRpdmUsXG4gIGVxdWFsc1N0cmluZyxcbiAgYXJySW5jbHVkZXMsXG4gIGFyckluY2x1ZGVzQWxsLFxuICBhcnJJbmNsdWRlc1NvbWUsXG4gIGVxdWFscyxcbiAgd2Vha0VxdWFscyxcbiAgaW5OdW1iZXJSYW5nZVxufTtcbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIHRlc3RGYWxzZXkodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwgfHwgdmFsID09PSAnJztcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uRmlsdGVyaW5nID0ge1xuICBnZXREZWZhdWx0Q29sdW1uRGVmOiAoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlckZuOiAnYXV0bydcbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uRmlsdGVyczogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ29sdW1uRmlsdGVyc0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uRmlsdGVycycsIHRhYmxlKSxcbiAgICAgIGZpbHRlckZyb21MZWFmUm93czogZmFsc2UsXG4gICAgICBtYXhMZWFmUm93RmlsdGVyRGVwdGg6IDEwMFxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZmlyc3RSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGZpcnN0Um93LmdldFZhbHVlKGNvbHVtbi5pZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyRm5zLmluY2x1ZGVzU3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5pbk51bWJlclJhbmdlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBmaWx0ZXJGbnMuZXF1YWxzO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5lcXVhbHM7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZpbHRlckZucy5hcnJJbmNsdWRlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJGbnMud2Vha0VxdWFscztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuKSA/IGNvbHVtbi5jb2x1bW5EZWYuZmlsdGVyRm4gOiBjb2x1bW4uY29sdW1uRGVmLmZpbHRlckZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b0ZpbHRlckZuKCkgOiAvLyBAdHMtaWdub3JlXG4gICAgICAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyID0gKF90YWJsZSRvcHRpb25zJGZpbHRlcjIgPSB0YWJsZS5vcHRpb25zLmZpbHRlckZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGZpbHRlcjJbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbY29sdW1uLmNvbHVtbkRlZi5maWx0ZXJGbl07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuRmlsdGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlLCBfdGFibGUkb3B0aW9ucyRlbmFibGUyO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVDb2x1bW5GaWx0ZXIpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzRmlsdGVyZWQgPSAoKSA9PiBjb2x1bW4uZ2V0RmlsdGVySW5kZXgoKSA+IC0xO1xuICAgIGNvbHVtbi5nZXRGaWx0ZXJWYWx1ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW07XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCB8fCAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtLnZhbHVlO1xuICAgIH07XG4gICAgY29sdW1uLmdldEZpbHRlckluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTM7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgPSAoX3RhYmxlJGdldFN0YXRlJGNvbHVtMyA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uRmlsdGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTMuZmluZEluZGV4KGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bTIgOiAtMTtcbiAgICB9O1xuICAgIGNvbHVtbi5zZXRGaWx0ZXJWYWx1ZSA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldENvbHVtbkZpbHRlcnMob2xkID0+IHtcbiAgICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNGaWx0ZXIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kKGQgPT4gZC5pZCA9PT0gY29sdW1uLmlkKTtcbiAgICAgICAgY29uc3QgbmV3RmlsdGVyID0gZnVuY3Rpb25hbFVwZGF0ZSh2YWx1ZSwgcHJldmlvdXNGaWx0ZXIgPyBwcmV2aW91c0ZpbHRlci52YWx1ZSA6IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHNob3VsZEF1dG9SZW1vdmVGaWx0ZXIoZmlsdGVyRm4sIG5ld0ZpbHRlciwgY29sdW1uKSkge1xuICAgICAgICAgIHZhciBfb2xkJGZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gKF9vbGQkZmlsdGVyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmlsdGVyKGQgPT4gZC5pZCAhPT0gY29sdW1uLmlkKSkgIT0gbnVsbCA/IF9vbGQkZmlsdGVyIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RmlsdGVyT2JqID0ge1xuICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgdmFsdWU6IG5ld0ZpbHRlclxuICAgICAgICB9O1xuICAgICAgICBpZiAocHJldmlvdXNGaWx0ZXIpIHtcbiAgICAgICAgICB2YXIgX29sZCRtYXA7XG4gICAgICAgICAgcmV0dXJuIChfb2xkJG1hcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLm1hcChkID0+IHtcbiAgICAgICAgICAgIGlmIChkLmlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld0ZpbHRlck9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pKSAhPSBudWxsID8gX29sZCRtYXAgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBbLi4ub2xkLCBuZXdGaWx0ZXJPYmpdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3RmlsdGVyT2JqXTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgX3RhYmxlKSA9PiB7XG4gICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICByb3cuY29sdW1uRmlsdGVyc01ldGEgPSB7fTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzID0gdXBkYXRlciA9PiB7XG4gICAgICBjb25zdCBsZWFmQ29sdW1ucyA9IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCk7XG4gICAgICBjb25zdCB1cGRhdGVGbiA9IG9sZCA9PiB7XG4gICAgICAgIHZhciBfZnVuY3Rpb25hbFVwZGF0ZTtcbiAgICAgICAgcmV0dXJuIChfZnVuY3Rpb25hbFVwZGF0ZSA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgb2xkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mdW5jdGlvbmFsVXBkYXRlLmZpbHRlcihmaWx0ZXIgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGxlYWZDb2x1bW5zLmZpbmQoZCA9PiBkLmlkID09PSBmaWx0ZXIuaWQpO1xuICAgICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZuID0gY29sdW1uLmdldEZpbHRlckZuKCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgZmlsdGVyLnZhbHVlLCBjb2x1bW4pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRhYmxlLm9wdGlvbnMub25Db2x1bW5GaWx0ZXJzQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vbkNvbHVtbkZpbHRlcnNDaGFuZ2UodXBkYXRlRm4pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRDb2x1bW5GaWx0ZXJzID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5GaWx0ZXJzKGRlZmF1bHRTdGF0ZSA/IFtdIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYyA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5jb2x1bW5GaWx0ZXJzKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0RmlsdGVyZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmlsdGVyZWRSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICBpZiAodGFibGUub3B0aW9ucy5tYW51YWxGaWx0ZXJpbmcgfHwgIXRhYmxlLl9nZXRGaWx0ZXJlZFJvd01vZGVsKSB7XG4gICAgICAgIHJldHVybiB0YWJsZS5nZXRQcmVGaWx0ZXJlZFJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldEZpbHRlcmVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gc2hvdWxkQXV0b1JlbW92ZUZpbHRlcihmaWx0ZXJGbiwgdmFsdWUsIGNvbHVtbikge1xuICByZXR1cm4gKGZpbHRlckZuICYmIGZpbHRlckZuLmF1dG9SZW1vdmUgPyBmaWx0ZXJGbi5hdXRvUmVtb3ZlKHZhbHVlLCBjb2x1bW4pIDogZmFsc2UpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhdmFsdWU7XG59XG5cbmNvbnN0IHN1bSA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgLy8gSXQncyBmYXN0ZXIgdG8ganVzdCBhZGQgdGhlIGFnZ3JlZ2F0aW9ucyB0b2dldGhlciBpbnN0ZWFkIG9mXG4gIC8vIHByb2Nlc3MgbGVhZiBub2RlcyBpbmRpdmlkdWFsbHlcbiAgcmV0dXJuIGNoaWxkUm93cy5yZWR1Y2UoKHN1bSwgbmV4dCkgPT4ge1xuICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHQuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIHJldHVybiBzdW0gKyAodHlwZW9mIG5leHRWYWx1ZSA9PT0gJ251bWJlcicgPyBuZXh0VmFsdWUgOiAwKTtcbiAgfSwgMCk7XG59O1xuY29uc3QgbWluID0gKGNvbHVtbklkLCBfbGVhZlJvd3MsIGNoaWxkUm93cykgPT4ge1xuICBsZXQgbWluO1xuICBjaGlsZFJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcm93LmdldFZhbHVlKGNvbHVtbklkKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiAobWluID4gdmFsdWUgfHwgbWluID09PSB1bmRlZmluZWQgJiYgdmFsdWUgPj0gdmFsdWUpKSB7XG4gICAgICBtaW4gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWluO1xufTtcbmNvbnN0IG1heCA9IChjb2x1bW5JZCwgX2xlYWZSb3dzLCBjaGlsZFJvd3MpID0+IHtcbiAgbGV0IG1heDtcbiAgY2hpbGRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHJvdy5nZXRWYWx1ZShjb2x1bW5JZCk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgKG1heCA8IHZhbHVlIHx8IG1heCA9PT0gdW5kZWZpbmVkICYmIHZhbHVlID49IHZhbHVlKSkge1xuICAgICAgbWF4ID0gdmFsdWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1heDtcbn07XG5jb25zdCBleHRlbnQgPSAoY29sdW1uSWQsIF9sZWFmUm93cywgY2hpbGRSb3dzKSA9PiB7XG4gIGxldCBtaW47XG4gIGxldCBtYXg7XG4gIGNoaWxkUm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBpZiAobWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtaW4gPiB2YWx1ZSkgbWluID0gdmFsdWU7XG4gICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuY29uc3QgbWVhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IHN1bSA9IDA7XG4gIGxlYWZSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBsZXQgdmFsdWUgPSByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmICh2YWx1ZSA9ICt2YWx1ZSkgPj0gdmFsdWUpIHtcbiAgICAgICsrY291bnQsIHN1bSArPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICBpZiAoY291bnQpIHJldHVybiBzdW0gLyBjb3VudDtcbiAgcmV0dXJuO1xufTtcbmNvbnN0IG1lZGlhbiA9IChjb2x1bW5JZCwgbGVhZlJvd3MpID0+IHtcbiAgaWYgKCFsZWFmUm93cy5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmFsdWVzID0gbGVhZlJvd3MubWFwKHJvdyA9PiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbiAgaWYgKCFpc051bWJlckFycmF5KHZhbHVlcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdmFsdWVzWzBdO1xuICB9XG4gIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuICBjb25zdCBudW1zID0gdmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggJSAyICE9PSAwID8gbnVtc1ttaWRdIDogKG51bXNbbWlkIC0gMV0gKyBudW1zW21pZF0pIC8gMjtcbn07XG5jb25zdCB1bmlxdWUgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobGVhZlJvd3MubWFwKGQgPT4gZC5nZXRWYWx1ZShjb2x1bW5JZCkpKS52YWx1ZXMoKSk7XG59O1xuY29uc3QgdW5pcXVlQ291bnQgPSAoY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBuZXcgU2V0KGxlYWZSb3dzLm1hcChkID0+IGQuZ2V0VmFsdWUoY29sdW1uSWQpKSkuc2l6ZTtcbn07XG5jb25zdCBjb3VudCA9IChfY29sdW1uSWQsIGxlYWZSb3dzKSA9PiB7XG4gIHJldHVybiBsZWFmUm93cy5sZW5ndGg7XG59O1xuY29uc3QgYWdncmVnYXRpb25GbnMgPSB7XG4gIHN1bSxcbiAgbWluLFxuICBtYXgsXG4gIGV4dGVudCxcbiAgbWVhbixcbiAgbWVkaWFuLFxuICB1bmlxdWUsXG4gIHVuaXF1ZUNvdW50LFxuICBjb3VudFxufTtcblxuLy9cblxuY29uc3QgQ29sdW1uR3JvdXBpbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgYWdncmVnYXRlZENlbGw6IHByb3BzID0+IHtcbiAgICAgICAgdmFyIF90b1N0cmluZywgX3Byb3BzJGdldFZhbHVlO1xuICAgICAgICByZXR1cm4gKF90b1N0cmluZyA9IChfcHJvcHMkZ2V0VmFsdWUgPSBwcm9wcy5nZXRWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRnZXRWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJGdldFZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfdG9TdHJpbmcgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGFnZ3JlZ2F0aW9uRm46ICdhdXRvJ1xuICAgIH07XG4gIH0sXG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBncm91cGluZzogW10sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uR3JvdXBpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2dyb3VwaW5nJywgdGFibGUpLFxuICAgICAgZ3JvdXBlZENvbHVtbk1vZGU6ICdyZW9yZGVyJ1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcgPSAoKSA9PiB7XG4gICAgICB0YWJsZS5zZXRHcm91cGluZyhvbGQgPT4ge1xuICAgICAgICAvLyBGaW5kIGFueSBleGlzdGluZyBncm91cGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgaWYgKG9sZCAhPSBudWxsICYmIG9sZC5pbmNsdWRlcyhjb2x1bW4uaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZC5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4uKG9sZCAhPSBudWxsID8gb2xkIDogW10pLCBjb2x1bW4uaWRdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0Q2FuR3JvdXAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSkgJiYgKCEhY29sdW1uLmFjY2Vzc29yRm4gfHwgISFjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzR3JvdXBlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkZ3JvdXA7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRTdGF0ZSRncm91cCA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAuaW5jbHVkZXMoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRHcm91cGVkSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJGdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJGdyb3VwMiA9IHRhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkZ3JvdXAyLmluZGV4T2YoY29sdW1uLmlkKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRUb2dnbGVHcm91cGluZ0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5Hcm91cCA9IGNvbHVtbi5nZXRDYW5Hcm91cCgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW5Hcm91cCkgcmV0dXJuO1xuICAgICAgICBjb2x1bW4udG9nZ2xlR3JvdXBpbmcoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QXV0b0FnZ3JlZ2F0aW9uRm4gPSAoKSA9PiB7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLmZsYXRSb3dzWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBmaXJzdFJvdyA9PSBudWxsID8gdm9pZCAwIDogZmlyc3RSb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5zdW07XG4gICAgICB9XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nKSB7XG4gICAgICAgIHJldHVybiBhZ2dyZWdhdGlvbkZucy5leHRlbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0QWdncmVnYXRpb25GbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRhZ2dyZWcsIF90YWJsZSRvcHRpb25zJGFnZ3JlZzI7XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25GbikgPyBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gOiBjb2x1bW4uY29sdW1uRGVmLmFnZ3JlZ2F0aW9uRm4gPT09ICdhdXRvJyA/IGNvbHVtbi5nZXRBdXRvQWdncmVnYXRpb25GbigpIDogKF90YWJsZSRvcHRpb25zJGFnZ3JlZyA9IChfdGFibGUkb3B0aW9ucyRhZ2dyZWcyID0gdGFibGUub3B0aW9ucy5hZ2dyZWdhdGlvbkZucykgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRvcHRpb25zJGFnZ3JlZzJbY29sdW1uLmNvbHVtbkRlZi5hZ2dyZWdhdGlvbkZuXSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGFnZ3JlZyA6IGFnZ3JlZ2F0aW9uRm5zW2NvbHVtbi5jb2x1bW5EZWYuYWdncmVnYXRpb25Gbl07XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRHcm91cGluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkdyb3VwaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uR3JvdXBpbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRHcm91cGluZyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRnLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0R3JvdXBpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRnID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmdyb3VwaW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRnIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlR3JvdXBlZFJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdyb3VwZWRSb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldEdyb3VwZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0R3JvdXBlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRHcm91cGVkUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsR3JvdXBpbmcgfHwgIXRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHcm91cGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldElzR3JvdXBlZCA9ICgpID0+ICEhcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgcm93LmdldEdyb3VwaW5nVmFsdWUgPSBjb2x1bW5JZCA9PiB7XG4gICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICBpZiAoIShjb2x1bW4gIT0gbnVsbCAmJiBjb2x1bW4uY29sdW1uRGVmLmdldEdyb3VwaW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiByb3cuZ2V0VmFsdWUoY29sdW1uSWQpO1xuICAgICAgfVxuICAgICAgcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXSA9IGNvbHVtbi5jb2x1bW5EZWYuZ2V0R3JvdXBpbmdWYWx1ZShyb3cub3JpZ2luYWwpO1xuICAgICAgcmV0dXJuIHJvdy5fZ3JvdXBpbmdWYWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgfTtcbiAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGUgPSB7fTtcbiAgfSxcbiAgY3JlYXRlQ2VsbDogKGNlbGwsIGNvbHVtbiwgcm93LCB0YWJsZSkgPT4ge1xuICAgIGNlbGwuZ2V0SXNHcm91cGVkID0gKCkgPT4gY29sdW1uLmdldElzR3JvdXBlZCgpICYmIGNvbHVtbi5pZCA9PT0gcm93Lmdyb3VwaW5nQ29sdW1uSWQ7XG4gICAgY2VsbC5nZXRJc1BsYWNlaG9sZGVyID0gKCkgPT4gIWNlbGwuZ2V0SXNHcm91cGVkKCkgJiYgY29sdW1uLmdldElzR3JvdXBlZCgpO1xuICAgIGNlbGwuZ2V0SXNBZ2dyZWdhdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIHJldHVybiAhY2VsbC5nZXRJc0dyb3VwZWQoKSAmJiAhY2VsbC5nZXRJc1BsYWNlaG9sZGVyKCkgJiYgISEoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpO1xuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBvcmRlckNvbHVtbnMobGVhZkNvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSkge1xuICBpZiAoIShncm91cGluZyAhPSBudWxsICYmIGdyb3VwaW5nLmxlbmd0aCkgfHwgIWdyb3VwZWRDb2x1bW5Nb2RlKSB7XG4gICAgcmV0dXJuIGxlYWZDb2x1bW5zO1xuICB9XG4gIGNvbnN0IG5vbkdyb3VwaW5nQ29sdW1ucyA9IGxlYWZDb2x1bW5zLmZpbHRlcihjb2wgPT4gIWdyb3VwaW5nLmluY2x1ZGVzKGNvbC5pZCkpO1xuICBpZiAoZ3JvdXBlZENvbHVtbk1vZGUgPT09ICdyZW1vdmUnKSB7XG4gICAgcmV0dXJuIG5vbkdyb3VwaW5nQ29sdW1ucztcbiAgfVxuICBjb25zdCBncm91cGluZ0NvbHVtbnMgPSBncm91cGluZy5tYXAoZyA9PiBsZWFmQ29sdW1ucy5maW5kKGNvbCA9PiBjb2wuaWQgPT09IGcpKS5maWx0ZXIoQm9vbGVhbik7XG4gIHJldHVybiBbLi4uZ3JvdXBpbmdDb2x1bW5zLCAuLi5ub25Hcm91cGluZ0NvbHVtbnNdO1xufVxuXG4vL1xuXG5jb25zdCBDb2x1bW5PcmRlcmluZyA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbk9yZGVyOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Db2x1bW5PcmRlckNoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uT3JkZXInLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLmdldEluZGV4ID0gbWVtbyhwb3NpdGlvbiA9PiBbX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pXSwgY29sdW1ucyA9PiBjb2x1bW5zLmZpbmRJbmRleChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0SW5kZXgnKSk7XG4gICAgY29sdW1uLmdldElzRmlyc3RDb2x1bW4gPSBwb3NpdGlvbiA9PiB7XG4gICAgICB2YXIgX2NvbHVtbnMkO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zJCA9IGNvbHVtbnNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfY29sdW1ucyQuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNMYXN0Q29sdW1uID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9jb2x1bW5zO1xuICAgICAgY29uc3QgY29sdW1ucyA9IF9nZXRWaXNpYmxlTGVhZkNvbHVtbnModGFibGUsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiAoKF9jb2x1bW5zID0gY29sdW1uc1tjb2x1bW5zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbHVtbnMuaWQpID09PSBjb2x1bW4uaWQ7XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5PcmRlciA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtbk9yZGVyQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uT3JkZXJDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5PcmRlciA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjO1xuICAgICAgdGFibGUuc2V0Q29sdW1uT3JkZXIoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtbk9yZGVyKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDogW10pO1xuICAgIH07XG4gICAgdGFibGUuX2dldE9yZGVyQ29sdW1uc0ZuID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5PcmRlciwgdGFibGUuZ2V0U3RhdGUoKS5ncm91cGluZywgdGFibGUub3B0aW9ucy5ncm91cGVkQ29sdW1uTW9kZV0sIChjb2x1bW5PcmRlciwgZ3JvdXBpbmcsIGdyb3VwZWRDb2x1bW5Nb2RlKSA9PiBjb2x1bW5zID0+IHtcbiAgICAgIC8vIFNvcnQgZ3JvdXBlZCBjb2x1bW5zIHRvIHRoZSBzdGFydCBvZiB0aGUgY29sdW1uIGxpc3RcbiAgICAgIC8vIGJlZm9yZSB0aGUgaGVhZGVycyBhcmUgYnVpbHRcbiAgICAgIGxldCBvcmRlcmVkQ29sdW1ucyA9IFtdO1xuXG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBvcmRlciwgcmV0dXJuIHRoZSBub3JtYWwgY29sdW1uc1xuICAgICAgaWYgKCEoY29sdW1uT3JkZXIgIT0gbnVsbCAmJiBjb2x1bW5PcmRlci5sZW5ndGgpKSB7XG4gICAgICAgIG9yZGVyZWRDb2x1bW5zID0gY29sdW1ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbk9yZGVyQ29weSA9IFsuLi5jb2x1bW5PcmRlcl07XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYW4gb3JkZXIsIG1ha2UgYSBjb3B5IG9mIHRoZSBjb2x1bW5zXG4gICAgICAgIGNvbnN0IGNvbHVtbnNDb3B5ID0gWy4uLmNvbHVtbnNdO1xuXG4gICAgICAgIC8vIEFuZCBtYWtlIGEgbmV3IG9yZGVyZWQgYXJyYXkgb2YgdGhlIGNvbHVtbnNcblxuICAgICAgICAvLyBMb29wIG92ZXIgdGhlIGNvbHVtbnMgYW5kIHBsYWNlIHRoZW0gaW4gb3JkZXIgaW50byB0aGUgbmV3IGFycmF5XG4gICAgICAgIHdoaWxlIChjb2x1bW5zQ29weS5sZW5ndGggJiYgY29sdW1uT3JkZXJDb3B5Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldENvbHVtbklkID0gY29sdW1uT3JkZXJDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgY29uc3QgZm91bmRJbmRleCA9IGNvbHVtbnNDb3B5LmZpbmRJbmRleChkID0+IGQuaWQgPT09IHRhcmdldENvbHVtbklkKTtcbiAgICAgICAgICBpZiAoZm91bmRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBvcmRlcmVkQ29sdW1ucy5wdXNoKGNvbHVtbnNDb3B5LnNwbGljZShmb3VuZEluZGV4LCAxKVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBjb2x1bW5zIGxlZnQsIGFkZCB0aGVtIHRvIHRoZSBlbmRcbiAgICAgICAgb3JkZXJlZENvbHVtbnMgPSBbLi4ub3JkZXJlZENvbHVtbnMsIC4uLmNvbHVtbnNDb3B5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmRlckNvbHVtbnMob3JkZXJlZENvbHVtbnMsIGdyb3VwaW5nLCBncm91cGVkQ29sdW1uTW9kZSk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnX2dldE9yZGVyQ29sdW1uc0ZuJykpO1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgbGVmdDogW10sXG4gIHJpZ2h0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5QaW5uaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29sdW1uUGlubmluZzogZ2V0RGVmYXVsdENvbHVtblBpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblBpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblBpbm5pbmcnLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnBpbiA9IHBvc2l0aW9uID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIHRhYmxlLnNldENvbHVtblBpbm5pbmcob2xkID0+IHtcbiAgICAgICAgdmFyIF9vbGQkbGVmdDMsIF9vbGQkcmlnaHQzO1xuICAgICAgICBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICB2YXIgX29sZCRsZWZ0LCBfb2xkJHJpZ2h0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiAoKF9vbGQkbGVmdCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSxcbiAgICAgICAgICAgIHJpZ2h0OiBbLi4uKChfb2xkJHJpZ2h0ID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0IDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksIC4uLmNvbHVtbklkc11cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkbGVmdDIsIF9vbGQkcmlnaHQyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBbLi4uKChfb2xkJGxlZnQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQubGVmdCkgIT0gbnVsbCA/IF9vbGQkbGVmdDIgOiBbXSkuZmlsdGVyKGQgPT4gIShjb2x1bW5JZHMgIT0gbnVsbCAmJiBjb2x1bW5JZHMuaW5jbHVkZXMoZCkpKSwgLi4uY29sdW1uSWRzXSxcbiAgICAgICAgICAgIHJpZ2h0OiAoKF9vbGQkcmlnaHQyID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQucmlnaHQpICE9IG51bGwgPyBfb2xkJHJpZ2h0MiA6IFtdKS5maWx0ZXIoZCA9PiAhKGNvbHVtbklkcyAhPSBudWxsICYmIGNvbHVtbklkcy5pbmNsdWRlcyhkKSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxlZnQ6ICgoX29sZCRsZWZ0MyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmxlZnQpICE9IG51bGwgPyBfb2xkJGxlZnQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSksXG4gICAgICAgICAgcmlnaHQ6ICgoX29sZCRyaWdodDMgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5yaWdodCkgIT0gbnVsbCA/IF9vbGQkcmlnaHQzIDogW10pLmZpbHRlcihkID0+ICEoY29sdW1uSWRzICE9IG51bGwgJiYgY29sdW1uSWRzLmluY2x1ZGVzKGQpKSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhblBpbiA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGxlYWZDb2x1bW5zID0gY29sdW1uLmdldExlYWZDb2x1bW5zKCk7XG4gICAgICByZXR1cm4gbGVhZkNvbHVtbnMuc29tZShkID0+IHtcbiAgICAgICAgdmFyIF9kJGNvbHVtbkRlZiRlbmFibGVQaSwgX3JlZiwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgICByZXR1cm4gKChfZCRjb2x1bW5EZWYkZW5hYmxlUGkgPSBkLmNvbHVtbkRlZi5lbmFibGVQaW5uaW5nKSAhPSBudWxsID8gX2QkY29sdW1uRGVmJGVuYWJsZVBpIDogdHJ1ZSkgJiYgKChfcmVmID0gKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlQ29sdW1uUGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlUGlubmluZykgIT0gbnVsbCA/IF9yZWYgOiB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzUGlubmVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgbGVhZkNvbHVtbklkcyA9IGNvbHVtbi5nZXRMZWFmQ29sdW1ucygpLm1hcChkID0+IGQuaWQpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZztcbiAgICAgIGNvbnN0IGlzTGVmdCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IGxlZnQgPT0gbnVsbCA/IHZvaWQgMCA6IGxlZnQuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNSaWdodCA9IGxlYWZDb2x1bW5JZHMuc29tZShkID0+IHJpZ2h0ID09IG51bGwgPyB2b2lkIDAgOiByaWdodC5pbmNsdWRlcyhkKSk7XG4gICAgICByZXR1cm4gaXNMZWZ0ID8gJ2xlZnQnIDogaXNSaWdodCA/ICdyaWdodCcgOiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRQaW5uZWRJbmRleCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0U3RhdGUkY29sdW0sIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTI7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGNvbHVtbi5nZXRJc1Bpbm5lZCgpO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID8gKF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA9IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nKSA9PSBudWxsIHx8IChfdGFibGUkZ2V0U3RhdGUkY29sdW0yID0gX3RhYmxlJGdldFN0YXRlJGNvbHVtMltwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0U3RhdGUkY29sdW0yLmluZGV4T2YoY29sdW1uLmlkKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRjb2x1bSA6IC0xIDogMDtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LmdldENlbnRlclZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0LCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ2VsbHMsIGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBjb25zdCBsZWZ0QW5kUmlnaHQgPSBbLi4uKGxlZnQgIT0gbnVsbCA/IGxlZnQgOiBbXSksIC4uLihyaWdodCAhPSBudWxsID8gcmlnaHQgOiBbXSldO1xuICAgICAgcmV0dXJuIGFsbENlbGxzLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5jb2x1bW4uaWQpKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldENlbnRlclZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0TGVmdFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5fZ2V0QWxsVmlzaWJsZUNlbGxzKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKGFsbENlbGxzLCBsZWZ0KSA9PiB7XG4gICAgICBjb25zdCBjZWxscyA9IChsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAnbGVmdCdcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBjZWxscztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdSb3dzJywgJ2dldExlZnRWaXNpYmxlQ2VsbHMnKSk7XG4gICAgcm93LmdldFJpZ2h0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93Ll9nZXRBbGxWaXNpYmxlQ2VsbHMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLnJpZ2h0XSwgKGFsbENlbGxzLCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgY2VsbHMgPSAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDZWxscy5maW5kKGNlbGwgPT4gY2VsbC5jb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uOiAncmlnaHQnXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gY2VsbHM7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnUm93cycsICdnZXRSaWdodFZpc2libGVDZWxscycpKTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRDb2x1bW5QaW5uaW5nID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uUGlubmluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblBpbm5pbmdDaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5QaW5uaW5nID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJGMsIF90YWJsZSRpbml0aWFsU3RhdGU7XG4gICAgICByZXR1cm4gdGFibGUuc2V0Q29sdW1uUGlubmluZyhkZWZhdWx0U3RhdGUgPyBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkgOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLmNvbHVtblBpbm5pbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiBnZXREZWZhdWx0Q29sdW1uUGlubmluZ1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lQ29sdW1uc1Bpbm5lZCA9IHBvc2l0aW9uID0+IHtcbiAgICAgIHZhciBfcGlubmluZ1N0YXRlJHBvc2l0aW87XG4gICAgICBjb25zdCBwaW5uaW5nU3RhdGUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmc7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHZhciBfcGlubmluZ1N0YXRlJGxlZnQsIF9waW5uaW5nU3RhdGUkcmlnaHQ7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCgoX3Bpbm5pbmdTdGF0ZSRsZWZ0ID0gcGlubmluZ1N0YXRlLmxlZnQpID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJGxlZnQubGVuZ3RoKSB8fCAoKF9waW5uaW5nU3RhdGUkcmlnaHQgPSBwaW5uaW5nU3RhdGUucmlnaHQpID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHJpZ2h0Lmxlbmd0aCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEJvb2xlYW4oKF9waW5uaW5nU3RhdGUkcG9zaXRpbyA9IHBpbm5pbmdTdGF0ZVtwb3NpdGlvbl0pID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHBvc2l0aW8ubGVuZ3RoKTtcbiAgICB9O1xuICAgIHRhYmxlLmdldExlZnRMZWFmQ29sdW1ucyA9IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbExlYWZDb2x1bW5zKCksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5sZWZ0XSwgKGFsbENvbHVtbnMsIGxlZnQpID0+IHtcbiAgICAgIHJldHVybiAobGVmdCAhPSBudWxsID8gbGVmdCA6IFtdKS5tYXAoY29sdW1uSWQgPT4gYWxsQ29sdW1ucy5maW5kKGNvbHVtbiA9PiBjb2x1bW4uaWQgPT09IGNvbHVtbklkKSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0TGVmdExlYWZDb2x1bW5zJykpO1xuICAgIHRhYmxlLmdldFJpZ2h0TGVhZkNvbHVtbnMgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblBpbm5pbmcucmlnaHRdLCAoYWxsQ29sdW1ucywgcmlnaHQpID0+IHtcbiAgICAgIHJldHVybiAocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pLm1hcChjb2x1bW5JZCA9PiBhbGxDb2x1bW5zLmZpbmQoY29sdW1uID0+IGNvbHVtbi5pZCA9PT0gY29sdW1uSWQpKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRSaWdodExlYWZDb2x1bW5zJykpO1xuICAgIHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5QaW5uaW5nLmxlZnQsIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uUGlubmluZy5yaWdodF0sIChhbGxDb2x1bW5zLCBsZWZ0LCByaWdodCkgPT4ge1xuICAgICAgY29uc3QgbGVmdEFuZFJpZ2h0ID0gWy4uLihsZWZ0ICE9IG51bGwgPyBsZWZ0IDogW10pLCAuLi4ocmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogW10pXTtcbiAgICAgIHJldHVybiBhbGxDb2x1bW5zLmZpbHRlcihkID0+ICFsZWZ0QW5kUmlnaHQuaW5jbHVkZXMoZC5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z0NvbHVtbnMnLCAnZ2V0Q2VudGVyTGVhZkNvbHVtbnMnKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNhZmVseUFjY2Vzc0RvY3VtZW50KF9kb2N1bWVudCkge1xuICByZXR1cm4gX2RvY3VtZW50IHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiBudWxsKTtcbn1cblxuLy9cblxuLy9cblxuY29uc3QgZGVmYXVsdENvbHVtblNpemluZyA9IHtcbiAgc2l6ZTogMTUwLFxuICBtaW5TaXplOiAyMCxcbiAgbWF4U2l6ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbn07XG5jb25zdCBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlID0gKCkgPT4gKHtcbiAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gIHN0YXJ0U2l6ZTogbnVsbCxcbiAgZGVsdGFPZmZzZXQ6IG51bGwsXG4gIGRlbHRhUGVyY2VudGFnZTogbnVsbCxcbiAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gIGNvbHVtblNpemluZ1N0YXJ0OiBbXVxufSk7XG5jb25zdCBDb2x1bW5TaXppbmcgPSB7XG4gIGdldERlZmF1bHRDb2x1bW5EZWY6ICgpID0+IHtcbiAgICByZXR1cm4gZGVmYXVsdENvbHVtblNpemluZztcbiAgfSxcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblNpemluZzoge30sXG4gICAgICBjb2x1bW5TaXppbmdJbmZvOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCksXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblJlc2l6ZU1vZGU6ICdvbkVuZCcsXG4gICAgICBjb2x1bW5SZXNpemVEaXJlY3Rpb246ICdsdHInLFxuICAgICAgb25Db2x1bW5TaXppbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblNpemluZycsIHRhYmxlKSxcbiAgICAgIG9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZTogbWFrZVN0YXRlVXBkYXRlcignY29sdW1uU2l6aW5nSW5mbycsIHRhYmxlKVxuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUNvbHVtbjogKGNvbHVtbiwgdGFibGUpID0+IHtcbiAgICBjb2x1bW4uZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfY29sdW1uJGNvbHVtbkRlZiRtaW4sIF9yZWYsIF9jb2x1bW4kY29sdW1uRGVmJG1heDtcbiAgICAgIGNvbnN0IGNvbHVtblNpemUgPSB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ1tjb2x1bW4uaWRdO1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KChfY29sdW1uJGNvbHVtbkRlZiRtaW4gPSBjb2x1bW4uY29sdW1uRGVmLm1pblNpemUpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRtaW4gOiBkZWZhdWx0Q29sdW1uU2l6aW5nLm1pblNpemUsIChfcmVmID0gY29sdW1uU2l6ZSAhPSBudWxsID8gY29sdW1uU2l6ZSA6IGNvbHVtbi5jb2x1bW5EZWYuc2l6ZSkgIT0gbnVsbCA/IF9yZWYgOiBkZWZhdWx0Q29sdW1uU2l6aW5nLnNpemUpLCAoX2NvbHVtbiRjb2x1bW5EZWYkbWF4ID0gY29sdW1uLmNvbHVtbkRlZi5tYXhTaXplKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkbWF4IDogZGVmYXVsdENvbHVtblNpemluZy5tYXhTaXplKTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTdGFydCA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKDAsIGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikpLnJlZHVjZSgoc3VtLCBjb2x1bW4pID0+IHN1bSArIGNvbHVtbi5nZXRTaXplKCksIDApLCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldFN0YXJ0JykpO1xuICAgIGNvbHVtbi5nZXRBZnRlciA9IG1lbW8ocG9zaXRpb24gPT4gW3Bvc2l0aW9uLCBfZ2V0VmlzaWJsZUxlYWZDb2x1bW5zKHRhYmxlLCBwb3NpdGlvbiksIHRhYmxlLmdldFN0YXRlKCkuY29sdW1uU2l6aW5nXSwgKHBvc2l0aW9uLCBjb2x1bW5zKSA9PiBjb2x1bW5zLnNsaWNlKGNvbHVtbi5nZXRJbmRleChwb3NpdGlvbikgKyAxKS5yZWR1Y2UoKHN1bSwgY29sdW1uKSA9PiBzdW0gKyBjb2x1bW4uZ2V0U2l6ZSgpLCAwKSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBZnRlcicpKTtcbiAgICBjb2x1bW4ucmVzZXRTaXplID0gKCkgPT4ge1xuICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBbY29sdW1uLmlkXTogXyxcbiAgICAgICAgICAuLi5yZXN0XG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5SZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGU7XG4gICAgICByZXR1cm4gKChfY29sdW1uJGNvbHVtbkRlZiRlbmEgPSBjb2x1bW4uY29sdW1uRGVmLmVuYWJsZVJlc2l6aW5nKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUNvbHVtblJlc2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNSZXNpemluZyA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblNpemluZ0luZm8uaXNSZXNpemluZ0NvbHVtbiA9PT0gY29sdW1uLmlkO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZUhlYWRlcjogKGhlYWRlciwgdGFibGUpID0+IHtcbiAgICBoZWFkZXIuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgY29uc3QgcmVjdXJzZSA9IGhlYWRlciA9PiB7XG4gICAgICAgIGlmIChoZWFkZXIuc3ViSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICBoZWFkZXIuc3ViSGVhZGVycy5mb3JFYWNoKHJlY3Vyc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfaGVhZGVyJGNvbHVtbiRnZXRTaXo7XG4gICAgICAgICAgc3VtICs9IChfaGVhZGVyJGNvbHVtbiRnZXRTaXogPSBoZWFkZXIuY29sdW1uLmdldFNpemUoKSkgIT0gbnVsbCA/IF9oZWFkZXIkY29sdW1uJGdldFNpeiA6IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWN1cnNlKGhlYWRlcik7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gICAgaGVhZGVyLmdldFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgaWYgKGhlYWRlci5pbmRleCA+IDApIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmdIZWFkZXIgPSBoZWFkZXIuaGVhZGVyR3JvdXAuaGVhZGVyc1toZWFkZXIuaW5kZXggLSAxXTtcbiAgICAgICAgcmV0dXJuIHByZXZTaWJsaW5nSGVhZGVyLmdldFN0YXJ0KCkgKyBwcmV2U2libGluZ0hlYWRlci5nZXRTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIGhlYWRlci5nZXRSZXNpemVIYW5kbGVyID0gX2NvbnRleHREb2N1bWVudCA9PiB7XG4gICAgICBjb25zdCBjb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oaGVhZGVyLmNvbHVtbi5pZCk7XG4gICAgICBjb25zdCBjYW5SZXNpemUgPSBjb2x1bW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbHVtbi5nZXRDYW5SZXNpemUoKTtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgaWYgKCFjb2x1bW4gfHwgIWNhblJlc2l6ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgLy8gbGV0cyBub3QgcmVzcG9uZCB0byBtdWx0aXBsZSB0b3VjaGVzIChlLmcuIDIgb3IgMyBmaW5nZXJzKVxuICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTaXplID0gaGVhZGVyLmdldFNpemUoKTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6aW5nU3RhcnQgPSBoZWFkZXIgPyBoZWFkZXIuZ2V0TGVhZkhlYWRlcnMoKS5tYXAoZCA9PiBbZC5jb2x1bW4uaWQsIGQuY29sdW1uLmdldFNpemUoKV0pIDogW1tjb2x1bW4uaWQsIGNvbHVtbi5nZXRTaXplKCldXTtcbiAgICAgICAgY29uc3QgY2xpZW50WCA9IGlzVG91Y2hTdGFydEV2ZW50KGUpID8gTWF0aC5yb3VuZChlLnRvdWNoZXNbMF0uY2xpZW50WCkgOiBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IG5ld0NvbHVtblNpemluZyA9IHt9O1xuICAgICAgICBjb25zdCB1cGRhdGVPZmZzZXQgPSAoZXZlbnRUeXBlLCBjbGllbnRYUG9zKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRYUG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiB7XG4gICAgICAgICAgICB2YXIgX29sZCRzdGFydE9mZnNldCwgX29sZCRzdGFydFNpemU7XG4gICAgICAgICAgICBjb25zdCBkZWx0YURpcmVjdGlvbiA9IHRhYmxlLm9wdGlvbnMuY29sdW1uUmVzaXplRGlyZWN0aW9uID09PSAncnRsJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKGNsaWVudFhQb3MgLSAoKF9vbGQkc3RhcnRPZmZzZXQgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5zdGFydE9mZnNldCkgIT0gbnVsbCA/IF9vbGQkc3RhcnRPZmZzZXQgOiAwKSkgKiBkZWx0YURpcmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhUGVyY2VudGFnZSA9IE1hdGgubWF4KGRlbHRhT2Zmc2V0IC8gKChfb2xkJHN0YXJ0U2l6ZSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnN0YXJ0U2l6ZSkgIT0gbnVsbCA/IF9vbGQkc3RhcnRTaXplIDogMCksIC0wLjk5OTk5OSk7XG4gICAgICAgICAgICBvbGQuY29sdW1uU2l6aW5nU3RhcnQuZm9yRWFjaChfcmVmMyA9PiB7XG4gICAgICAgICAgICAgIGxldCBbY29sdW1uSWQsIGhlYWRlclNpemVdID0gX3JlZjM7XG4gICAgICAgICAgICAgIG5ld0NvbHVtblNpemluZ1tjb2x1bW5JZF0gPSBNYXRoLnJvdW5kKE1hdGgubWF4KGhlYWRlclNpemUgKyBoZWFkZXJTaXplICogZGVsdGFQZXJjZW50YWdlLCAwKSAqIDEwMCkgLyAxMDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICAgICAgZGVsdGFPZmZzZXQsXG4gICAgICAgICAgICAgIGRlbHRhUGVyY2VudGFnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAodGFibGUub3B0aW9ucy5jb2x1bW5SZXNpemVNb2RlID09PSAnb25DaGFuZ2UnIHx8IGV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhvbGQgPT4gKHtcbiAgICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgICAuLi5uZXdDb2x1bW5TaXppbmdcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IGNsaWVudFhQb3MgPT4gdXBkYXRlT2Zmc2V0KCdtb3ZlJywgY2xpZW50WFBvcyk7XG4gICAgICAgIGNvbnN0IG9uRW5kID0gY2xpZW50WFBvcyA9PiB7XG4gICAgICAgICAgdXBkYXRlT2Zmc2V0KCdlbmQnLCBjbGllbnRYUG9zKTtcbiAgICAgICAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvKG9sZCA9PiAoe1xuICAgICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgICAgaXNSZXNpemluZ0NvbHVtbjogZmFsc2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogbnVsbCxcbiAgICAgICAgICAgIHN0YXJ0U2l6ZTogbnVsbCxcbiAgICAgICAgICAgIGRlbHRhT2Zmc2V0OiBudWxsLFxuICAgICAgICAgICAgZGVsdGFQZXJjZW50YWdlOiBudWxsLFxuICAgICAgICAgICAgY29sdW1uU2l6aW5nU3RhcnQ6IFtdXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0RG9jdW1lbnQgPSBzYWZlbHlBY2Nlc3NEb2N1bWVudChfY29udGV4dERvY3VtZW50KTtcbiAgICAgICAgY29uc3QgbW91c2VFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4gb25Nb3ZlKGUuY2xpZW50WCksXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZUV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNlRXZlbnRzLnVwSGFuZGxlcik7XG4gICAgICAgICAgICBvbkVuZChlLmNsaWVudFgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG91Y2hFdmVudHMgPSB7XG4gICAgICAgICAgbW92ZUhhbmRsZXI6IGUgPT4ge1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUoZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBIYW5kbGVyOiBlID0+IHtcbiAgICAgICAgICAgIHZhciBfZSR0b3VjaGVzJDtcbiAgICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0b3VjaEV2ZW50cy5tb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0b3VjaEV2ZW50cy51cEhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkVuZCgoX2UkdG91Y2hlcyQgPSBlLnRvdWNoZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZSR0b3VjaGVzJC5jbGllbnRYKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhc3NpdmVJZlN1cHBvcnRlZCA9IHBhc3NpdmVFdmVudFN1cHBvcnRlZCgpID8ge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGlzVG91Y2hTdGFydEV2ZW50KGUpKSB7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRvdWNoRXZlbnRzLm1vdmVIYW5kbGVyLCBwYXNzaXZlSWZTdXBwb3J0ZWQpO1xuICAgICAgICAgIGNvbnRleHREb2N1bWVudCA9PSBudWxsIHx8IGNvbnRleHREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRvdWNoRXZlbnRzLnVwSGFuZGxlciwgcGFzc2l2ZUlmU3VwcG9ydGVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0RG9jdW1lbnQgPT0gbnVsbCB8fCBjb250ZXh0RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VFdmVudHMubW92ZUhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgICAgY29udGV4dERvY3VtZW50ID09IG51bGwgfHwgY29udGV4dERvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBtb3VzZUV2ZW50cy51cEhhbmRsZXIsIHBhc3NpdmVJZlN1cHBvcnRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGFibGUuc2V0Q29sdW1uU2l6aW5nSW5mbyhvbGQgPT4gKHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgc3RhcnRPZmZzZXQ6IGNsaWVudFgsXG4gICAgICAgICAgc3RhcnRTaXplLFxuICAgICAgICAgIGRlbHRhT2Zmc2V0OiAwLFxuICAgICAgICAgIGRlbHRhUGVyY2VudGFnZTogMCxcbiAgICAgICAgICBjb2x1bW5TaXppbmdTdGFydCxcbiAgICAgICAgICBpc1Jlc2l6aW5nQ29sdW1uOiBjb2x1bW4uaWRcbiAgICAgICAgfSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldENvbHVtblNpemluZyA9IHVwZGF0ZXIgPT4gdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5zZXRDb2x1bW5TaXppbmdJbmZvID0gdXBkYXRlciA9PiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uU2l6aW5nSW5mb0NoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkNvbHVtblNpemluZ0luZm9DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRDb2x1bW5TaXppbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZyhkZWZhdWx0U3RhdGUgPyB7fSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJGMgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRjIDoge30pO1xuICAgIH07XG4gICAgdGFibGUucmVzZXRIZWFkZXJTaXplSW5mbyA9IGRlZmF1bHRTdGF0ZSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGluaXRpYWxTdGF0ZSRjMjtcbiAgICAgIHRhYmxlLnNldENvbHVtblNpemluZ0luZm8oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdENvbHVtblNpemluZ0luZm9TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkYzIgPSB0YWJsZS5pbml0aWFsU3RhdGUuY29sdW1uU2l6aW5nSW5mbykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkYzIgOiBnZXREZWZhdWx0Q29sdW1uU2l6aW5nSW5mb1N0YXRlKCkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG90YWxTaXplID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRIZWFkZXJHcm91cCwgX3RhYmxlJGdldEhlYWRlckdyb3VwMjtcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldEhlYWRlckdyb3VwID0gKF90YWJsZSRnZXRIZWFkZXJHcm91cDIgPSB0YWJsZS5nZXRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRIZWFkZXJHcm91cDIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0SGVhZGVyR3JvdXAgOiAwO1xuICAgIH07XG4gICAgdGFibGUuZ2V0TGVmdFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0TGVmdEhlYWRlckcsIF90YWJsZSRnZXRMZWZ0SGVhZGVyRzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA9IChfdGFibGUkZ2V0TGVmdEhlYWRlckcyID0gdGFibGUuZ2V0TGVmdEhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldExlZnRIZWFkZXJHMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRMZWZ0SGVhZGVyRyA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRDZW50ZXJUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldENlbnRlckhlYWRlLCBfdGFibGUkZ2V0Q2VudGVySGVhZGUyO1xuICAgICAgcmV0dXJuIChfdGFibGUkZ2V0Q2VudGVySGVhZGUgPSAoX3RhYmxlJGdldENlbnRlckhlYWRlMiA9IHRhYmxlLmdldENlbnRlckhlYWRlckdyb3VwcygpWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENlbnRlckhlYWRlMi5oZWFkZXJzLnJlZHVjZSgoc3VtLCBoZWFkZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1bSArIGhlYWRlci5nZXRTaXplKCk7XG4gICAgICB9LCAwKSkgIT0gbnVsbCA/IF90YWJsZSRnZXRDZW50ZXJIZWFkZSA6IDA7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRSaWdodFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkZ2V0UmlnaHRIZWFkZXIsIF90YWJsZSRnZXRSaWdodEhlYWRlcjI7XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRSaWdodEhlYWRlciA9IChfdGFibGUkZ2V0UmlnaHRIZWFkZXIyID0gdGFibGUuZ2V0UmlnaHRIZWFkZXJHcm91cHMoKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRSaWdodEhlYWRlcjIuaGVhZGVycy5yZWR1Y2UoKHN1bSwgaGVhZGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyBoZWFkZXIuZ2V0U2l6ZSgpO1xuICAgICAgfSwgMCkpICE9IG51bGwgPyBfdGFibGUkZ2V0UmlnaHRIZWFkZXIgOiAwO1xuICAgIH07XG4gIH1cbn07XG5sZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IG51bGw7XG5mdW5jdGlvbiBwYXNzaXZlRXZlbnRTdXBwb3J0ZWQoKSB7XG4gIGlmICh0eXBlb2YgcGFzc2l2ZVN1cHBvcnRlZCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgbm9vcCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBub29wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gIH1cbiAgcGFzc2l2ZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoU3RhcnRFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0Jztcbn1cblxuLy9cblxuY29uc3QgQ29sdW1uVmlzaWJpbGl0eSA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtblZpc2liaWxpdHk6IHt9LFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvbkNvbHVtblZpc2liaWxpdHlDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2NvbHVtblZpc2liaWxpdHknLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVDb2x1bW46IChjb2x1bW4sIHRhYmxlKSA9PiB7XG4gICAgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkgPSB2YWx1ZSA9PiB7XG4gICAgICBpZiAoY29sdW1uLmdldENhbkhpZGUoKSkge1xuICAgICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KG9sZCA9PiAoe1xuICAgICAgICAgIC4uLm9sZCxcbiAgICAgICAgICBbY29sdW1uLmlkXTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogIWNvbHVtbi5nZXRJc1Zpc2libGUoKVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0SXNWaXNpYmxlID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWYsIF90YWJsZSRnZXRTdGF0ZSRjb2x1bTtcbiAgICAgIGNvbnN0IGNoaWxkQ29sdW1ucyA9IGNvbHVtbi5jb2x1bW5zO1xuICAgICAgcmV0dXJuIChfcmVmID0gY2hpbGRDb2x1bW5zLmxlbmd0aCA/IGNoaWxkQ29sdW1ucy5zb21lKGMgPT4gYy5nZXRJc1Zpc2libGUoKSkgOiAoX3RhYmxlJGdldFN0YXRlJGNvbHVtID0gdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5WaXNpYmlsaXR5KSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJGNvbHVtW2NvbHVtbi5pZF0pICE9IG51bGwgPyBfcmVmIDogdHJ1ZTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5IaWRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgcmV0dXJuICgoX2NvbHVtbiRjb2x1bW5EZWYkZW5hID0gY29sdW1uLmNvbHVtbkRlZi5lbmFibGVIaWRpbmcpICE9IG51bGwgPyBfY29sdW1uJGNvbHVtbkRlZiRlbmEgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlSGlkaW5nKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZW5hYmxlIDogdHJ1ZSk7XG4gICAgfTtcbiAgICBjb2x1bW4uZ2V0VG9nZ2xlVmlzaWJpbGl0eUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGNvbHVtbi50b2dnbGVWaXNpYmlsaXR5ID09IG51bGwgfHwgY29sdW1uLnRvZ2dsZVZpc2liaWxpdHkoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cuX2dldEFsbFZpc2libGVDZWxscyA9IG1lbW8oKCkgPT4gW3Jvdy5nZXRBbGxDZWxscygpLCB0YWJsZS5nZXRTdGF0ZSgpLmNvbHVtblZpc2liaWxpdHldLCBjZWxscyA9PiB7XG4gICAgICByZXR1cm4gY2VsbHMuZmlsdGVyKGNlbGwgPT4gY2VsbC5jb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnX2dldEFsbFZpc2libGVDZWxscycpKTtcbiAgICByb3cuZ2V0VmlzaWJsZUNlbGxzID0gbWVtbygoKSA9PiBbcm93LmdldExlZnRWaXNpYmxlQ2VsbHMoKSwgcm93LmdldENlbnRlclZpc2libGVDZWxscygpLCByb3cuZ2V0UmlnaHRWaXNpYmxlQ2VsbHMoKV0sIChsZWZ0LCBjZW50ZXIsIHJpZ2h0KSA9PiBbLi4ubGVmdCwgLi4uY2VudGVyLCAuLi5yaWdodF0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0VmlzaWJsZUNlbGxzJykpO1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGNvbnN0IG1ha2VWaXNpYmxlQ29sdW1uc01ldGhvZCA9IChrZXksIGdldENvbHVtbnMpID0+IHtcbiAgICAgIHJldHVybiBtZW1vKCgpID0+IFtnZXRDb2x1bW5zKCksIGdldENvbHVtbnMoKS5maWx0ZXIoZCA9PiBkLmdldElzVmlzaWJsZSgpKS5tYXAoZCA9PiBkLmlkKS5qb2luKCdfJyldLCBjb2x1bW5zID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMuZmlsdGVyKGQgPT4gZC5nZXRJc1Zpc2libGUgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZ2V0SXNWaXNpYmxlKCkpO1xuICAgICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsIGtleSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0VmlzaWJsZUZsYXRDb2x1bW5zID0gbWFrZVZpc2libGVDb2x1bW5zTWV0aG9kKCdnZXRWaXNpYmxlRmxhdENvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRBbGxGbGF0Q29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLmdldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldExlZnRWaXNpYmxlTGVhZkNvbHVtbnMnLCAoKSA9PiB0YWJsZS5nZXRMZWZ0TGVhZkNvbHVtbnMoKSk7XG4gICAgdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldFJpZ2h0VmlzaWJsZUxlYWZDb2x1bW5zJywgKCkgPT4gdGFibGUuZ2V0UmlnaHRMZWFmQ29sdW1ucygpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJWaXNpYmxlTGVhZkNvbHVtbnMgPSBtYWtlVmlzaWJsZUNvbHVtbnNNZXRob2QoJ2dldENlbnRlclZpc2libGVMZWFmQ29sdW1ucycsICgpID0+IHRhYmxlLmdldENlbnRlckxlYWZDb2x1bW5zKCkpO1xuICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Db2x1bW5WaXNpYmlsaXR5Q2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uQ29sdW1uVmlzaWJpbGl0eUNoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldENvbHVtblZpc2liaWxpdHkgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkYztcbiAgICAgIHRhYmxlLnNldENvbHVtblZpc2liaWxpdHkoZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRjID0gdGFibGUuaW5pdGlhbFN0YXRlLmNvbHVtblZpc2liaWxpdHkpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJGMgOiB7fSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxDb2x1bW5zVmlzaWJsZSA9IHZhbHVlID0+IHtcbiAgICAgIHZhciBfdmFsdWU7XG4gICAgICB2YWx1ZSA9IChfdmFsdWUgPSB2YWx1ZSkgIT0gbnVsbCA/IF92YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbENvbHVtbnNWaXNpYmxlKCk7XG4gICAgICB0YWJsZS5zZXRDb2x1bW5WaXNpYmlsaXR5KHRhYmxlLmdldEFsbExlYWZDb2x1bW5zKCkucmVkdWNlKChvYmosIGNvbHVtbikgPT4gKHtcbiAgICAgICAgLi4ub2JqLFxuICAgICAgICBbY29sdW1uLmlkXTogIXZhbHVlID8gIShjb2x1bW4uZ2V0Q2FuSGlkZSAhPSBudWxsICYmIGNvbHVtbi5nZXRDYW5IaWRlKCkpIDogdmFsdWVcbiAgICAgIH0pLCB7fSkpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNBbGxDb2x1bW5zVmlzaWJsZSA9ICgpID0+ICF0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLnNvbWUoY29sdW1uID0+ICEoY29sdW1uLmdldElzVmlzaWJsZSAhPSBudWxsICYmIGNvbHVtbi5nZXRJc1Zpc2libGUoKSkpO1xuICAgIHRhYmxlLmdldElzU29tZUNvbHVtbnNWaXNpYmxlID0gKCkgPT4gdGFibGUuZ2V0QWxsTGVhZkNvbHVtbnMoKS5zb21lKGNvbHVtbiA9PiBjb2x1bW4uZ2V0SXNWaXNpYmxlID09IG51bGwgPyB2b2lkIDAgOiBjb2x1bW4uZ2V0SXNWaXNpYmxlKCkpO1xuICAgIHRhYmxlLmdldFRvZ2dsZUFsbENvbHVtbnNWaXNpYmlsaXR5SGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgdmFyIF90YXJnZXQ7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbENvbHVtbnNWaXNpYmxlKChfdGFyZ2V0ID0gZS50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gX2dldFZpc2libGVMZWFmQ29sdW1ucyh0YWJsZSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuICFwb3NpdGlvbiA/IHRhYmxlLmdldFZpc2libGVMZWFmQ29sdW1ucygpIDogcG9zaXRpb24gPT09ICdjZW50ZXInID8gdGFibGUuZ2V0Q2VudGVyVmlzaWJsZUxlYWZDb2x1bW5zKCkgOiBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gdGFibGUuZ2V0TGVmdFZpc2libGVMZWFmQ29sdW1ucygpIDogdGFibGUuZ2V0UmlnaHRWaXNpYmxlTGVhZkNvbHVtbnMoKTtcbn1cblxuLy9cblxuY29uc3QgR2xvYmFsRmFjZXRpbmcgPSB7XG4gIGNyZWF0ZVRhYmxlOiB0YWJsZSA9PiB7XG4gICAgdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFJvd01vZGVsKHRhYmxlLCAnX19nbG9iYWxfXycpO1xuICAgIHRhYmxlLmdldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEZpbHRlcmluZyB8fCAhdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlRmlsdGVyZWRSb3dNb2RlbCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICAgIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gdGFibGUub3B0aW9ucy5nZXRGYWNldGVkVW5pcXVlVmFsdWVzICYmIHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlcyh0YWJsZSwgJ19fZ2xvYmFsX18nKTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZFVuaXF1ZVZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkVW5pcXVlVmFsdWVzKCk7XG4gICAgfTtcbiAgICB0YWJsZS5fZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9IHRhYmxlLm9wdGlvbnMuZ2V0RmFjZXRlZE1pbk1heFZhbHVlcyAmJiB0YWJsZS5vcHRpb25zLmdldEZhY2V0ZWRNaW5NYXhWYWx1ZXModGFibGUsICdfX2dsb2JhbF9fJyk7XG4gICAgdGFibGUuZ2V0R2xvYmFsRmFjZXRlZE1pbk1heFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEdsb2JhbEZhY2V0ZWRNaW5NYXhWYWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhYmxlLl9nZXRHbG9iYWxGYWNldGVkTWluTWF4VmFsdWVzKCk7XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgR2xvYmFsRmlsdGVyaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2xvYmFsRmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uR2xvYmFsRmlsdGVyQ2hhbmdlOiBtYWtlU3RhdGVVcGRhdGVyKCdnbG9iYWxGaWx0ZXInLCB0YWJsZSksXG4gICAgICBnbG9iYWxGaWx0ZXJGbjogJ2F1dG8nLFxuICAgICAgZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyOiBjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX3RhYmxlJGdldENvcmVSb3dNb2RlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChfdGFibGUkZ2V0Q29yZVJvd01vZGUgPSB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKS5mbGF0Um93c1swXSkgPT0gbnVsbCB8fCAoX3RhYmxlJGdldENvcmVSb3dNb2RlID0gX3RhYmxlJGdldENvcmVSb3dNb2RlLl9nZXRBbGxDZWxsc0J5Q29sdW1uSWQoKVtjb2x1bW4uaWRdKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldENvcmVSb3dNb2RlLmdldFZhbHVlKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRDYW5HbG9iYWxGaWx0ZXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NvbHVtbiRjb2x1bW5EZWYkZW5hLCBfdGFibGUkb3B0aW9ucyRlbmFibGUsIF90YWJsZSRvcHRpb25zJGVuYWJsZTIsIF90YWJsZSRvcHRpb25zJGdldENvbDtcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlR2xvYmFsRmlsdGVyKSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hIDogdHJ1ZSkgJiYgKChfdGFibGUkb3B0aW9ucyRlbmFibGUgPSB0YWJsZS5vcHRpb25zLmVuYWJsZUdsb2JhbEZpbHRlcikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlRmlsdGVycykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlKSAmJiAoKF90YWJsZSRvcHRpb25zJGdldENvbCA9IHRhYmxlLm9wdGlvbnMuZ2V0Q29sdW1uQ2FuR2xvYmFsRmlsdGVyID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldENvbHVtbkNhbkdsb2JhbEZpbHRlcihjb2x1bW4pKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkZ2V0Q29sIDogdHJ1ZSkgJiYgISFjb2x1bW4uYWNjZXNzb3JGbjtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLmdldEdsb2JhbEF1dG9GaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBmaWx0ZXJGbnMuaW5jbHVkZXNTdHJpbmc7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbiA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRmaWx0ZXIsIF90YWJsZSRvcHRpb25zJGZpbHRlcjI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGdsb2JhbEZpbHRlckZuOiBnbG9iYWxGaWx0ZXJGblxuICAgICAgfSA9IHRhYmxlLm9wdGlvbnM7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihnbG9iYWxGaWx0ZXJGbikgPyBnbG9iYWxGaWx0ZXJGbiA6IGdsb2JhbEZpbHRlckZuID09PSAnYXV0bycgPyB0YWJsZS5nZXRHbG9iYWxBdXRvRmlsdGVyRm4oKSA6IChfdGFibGUkb3B0aW9ucyRmaWx0ZXIgPSAoX3RhYmxlJG9wdGlvbnMkZmlsdGVyMiA9IHRhYmxlLm9wdGlvbnMuZmlsdGVyRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkZmlsdGVyMltnbG9iYWxGaWx0ZXJGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRmaWx0ZXIgOiBmaWx0ZXJGbnNbZ2xvYmFsRmlsdGVyRm5dO1xuICAgIH07XG4gICAgdGFibGUuc2V0R2xvYmFsRmlsdGVyID0gdXBkYXRlciA9PiB7XG4gICAgICB0YWJsZS5vcHRpb25zLm9uR2xvYmFsRmlsdGVyQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vbkdsb2JhbEZpbHRlckNoYW5nZSh1cGRhdGVyKTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0R2xvYmFsRmlsdGVyID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHRhYmxlLnNldEdsb2JhbEZpbHRlcihkZWZhdWx0U3RhdGUgPyB1bmRlZmluZWQgOiB0YWJsZS5pbml0aWFsU3RhdGUuZ2xvYmFsRmlsdGVyKTtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBSb3dFeHBhbmRpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBleHBhbmRlZDoge30sXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH0sXG4gIGdldERlZmF1bHRPcHRpb25zOiB0YWJsZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhwYW5kZWRDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ2V4cGFuZGVkJywgdGFibGUpLFxuICAgICAgcGFnaW5hdGVFeHBhbmRlZFJvd3M6IHRydWVcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgbGV0IHF1ZXVlZCA9IGZhbHNlO1xuICAgIHRhYmxlLl9hdXRvUmVzZXRFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmLCBfdGFibGUkb3B0aW9ucyRhdXRvUmU7XG4gICAgICBpZiAoIXJlZ2lzdGVyZWQpIHtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICByZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoX3JlZiA9IChfdGFibGUkb3B0aW9ucyRhdXRvUmUgPSB0YWJsZS5vcHRpb25zLmF1dG9SZXNldEFsbCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGF1dG9SZSA6IHRhYmxlLm9wdGlvbnMuYXV0b1Jlc2V0RXhwYW5kZWQpICE9IG51bGwgPyBfcmVmIDogIXRhYmxlLm9wdGlvbnMubWFudWFsRXhwYW5kaW5nKSB7XG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldEV4cGFuZGVkKCk7XG4gICAgICAgICAgcXVldWVkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGUuc2V0RXhwYW5kZWQgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25FeHBhbmRlZENoYW5nZSA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5vbkV4cGFuZGVkQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NFeHBhbmRlZCA9IGV4cGFuZGVkID0+IHtcbiAgICAgIGlmIChleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiAhdGFibGUuZ2V0SXNBbGxSb3dzRXhwYW5kZWQoKSkge1xuICAgICAgICB0YWJsZS5zZXRFeHBhbmRlZCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlLnNldEV4cGFuZGVkKHt9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0RXhwYW5kZWQgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkZSwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldEV4cGFuZGVkKGRlZmF1bHRTdGF0ZSA/IHt9IDogKF90YWJsZSRpbml0aWFsU3RhdGUkZSA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5leHBhbmRlZCkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkZSA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLmdldENhblNvbWVSb3dzRXhwYW5kID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLmdldFByZVBhZ2luYXRpb25Sb3dNb2RlbCgpLmZsYXRSb3dzLnNvbWUocm93ID0+IHJvdy5nZXRDYW5FeHBhbmQoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzRXhwYW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgdGFibGUudG9nZ2xlQWxsUm93c0V4cGFuZGVkKCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGFibGUuZ2V0SXNTb21lUm93c0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgZXhwYW5kZWQgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkO1xuICAgICAgcmV0dXJuIGV4cGFuZGVkID09PSB0cnVlIHx8IE9iamVjdC52YWx1ZXMoZXhwYW5kZWQpLnNvbWUoQm9vbGVhbik7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbFJvd3NFeHBhbmRlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcblxuICAgICAgLy8gSWYgZXhwYW5kZWQgaXMgdHJ1ZSwgc2F2ZSBzb21lIGN5Y2xlcyBhbmQgcmV0dXJuIHRydWVcbiAgICAgIGlmICh0eXBlb2YgZXhwYW5kZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZXhwYW5kZWQgPT09IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGV4cGFuZGVkKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhbnkgcm93IGlzIG5vdCBleHBhbmRlZCwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAodGFibGUuZ2V0Um93TW9kZWwoKS5mbGF0Um93cy5zb21lKHJvdyA9PiAhcm93LmdldElzRXhwYW5kZWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGV5IG11c3QgYWxsIGJlIGV4cGFuZGVkIDpzaHJ1ZzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgdGFibGUuZ2V0RXhwYW5kZWREZXB0aCA9ICgpID0+IHtcbiAgICAgIGxldCBtYXhEZXB0aCA9IDA7XG4gICAgICBjb25zdCByb3dJZHMgPSB0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkID09PSB0cnVlID8gT2JqZWN0LmtleXModGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzQnlJZCkgOiBPYmplY3Qua2V5cyh0YWJsZS5nZXRTdGF0ZSgpLmV4cGFuZGVkKTtcbiAgICAgIHJvd0lkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgY29uc3Qgc3BsaXRJZCA9IGlkLnNwbGl0KCcuJyk7XG4gICAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIHNwbGl0SWQubGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1heERlcHRoO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldFNvcnRlZFJvd01vZGVsKCk7XG4gICAgdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRFeHBhbmRlZFJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRFeHBhbmRlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbEV4cGFuZGluZyB8fCAhdGFibGUuX2dldEV4cGFuZGVkUm93TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLmdldFByZUV4cGFuZGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cudG9nZ2xlRXhwYW5kZWQgPSBleHBhbmRlZCA9PiB7XG4gICAgICB0YWJsZS5zZXRFeHBhbmRlZChvbGQgPT4ge1xuICAgICAgICB2YXIgX2V4cGFuZGVkO1xuICAgICAgICBjb25zdCBleGlzdHMgPSBvbGQgPT09IHRydWUgPyB0cnVlIDogISEob2xkICE9IG51bGwgJiYgb2xkW3Jvdy5pZF0pO1xuICAgICAgICBsZXQgb2xkRXhwYW5kZWQgPSB7fTtcbiAgICAgICAgaWYgKG9sZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRhYmxlLmdldFJvd01vZGVsKCkucm93c0J5SWQpLmZvckVhY2gocm93SWQgPT4ge1xuICAgICAgICAgICAgb2xkRXhwYW5kZWRbcm93SWRdID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbGRFeHBhbmRlZCA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICBleHBhbmRlZCA9IChfZXhwYW5kZWQgPSBleHBhbmRlZCkgIT0gbnVsbCA/IF9leHBhbmRlZCA6ICFleGlzdHM7XG4gICAgICAgIGlmICghZXhpc3RzICYmIGV4cGFuZGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9sZEV4cGFuZGVkLFxuICAgICAgICAgICAgW3Jvdy5pZF06IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleGlzdHMgJiYgIWV4cGFuZGVkKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgW3Jvdy5pZF06IF8sXG4gICAgICAgICAgICAuLi5yZXN0XG4gICAgICAgICAgfSA9IG9sZEV4cGFuZGVkO1xuICAgICAgICAgIHJldHVybiByZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvbGQ7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc0V4cGFuZGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGdldElzUjtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZDtcbiAgICAgIHJldHVybiAhISgoX3RhYmxlJG9wdGlvbnMkZ2V0SXNSID0gdGFibGUub3B0aW9ucy5nZXRJc1Jvd0V4cGFuZGVkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldElzUm93RXhwYW5kZWQocm93KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldElzUiA6IGV4cGFuZGVkID09PSB0cnVlIHx8IChleHBhbmRlZCA9PSBudWxsID8gdm9pZCAwIDogZXhwYW5kZWRbcm93LmlkXSkpO1xuICAgIH07XG4gICAgcm93LmdldENhbkV4cGFuZCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRnZXRSb3csIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3JvdyRzdWJSb3dzO1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRnZXRSb3cgPSB0YWJsZS5vcHRpb25zLmdldFJvd0NhbkV4cGFuZCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5nZXRSb3dDYW5FeHBhbmQocm93KSkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGdldFJvdyA6ICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVFeHBhbmRpbmcpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAhISgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNBbGxQYXJlbnRzRXhwYW5kZWQgPSAoKSA9PiB7XG4gICAgICBsZXQgaXNGdWxseUV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgIGxldCBjdXJyZW50Um93ID0gcm93O1xuICAgICAgd2hpbGUgKGlzRnVsbHlFeHBhbmRlZCAmJiBjdXJyZW50Um93LnBhcmVudElkKSB7XG4gICAgICAgIGN1cnJlbnRSb3cgPSB0YWJsZS5nZXRSb3coY3VycmVudFJvdy5wYXJlbnRJZCwgdHJ1ZSk7XG4gICAgICAgIGlzRnVsbHlFeHBhbmRlZCA9IGN1cnJlbnRSb3cuZ2V0SXNFeHBhbmRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzRnVsbHlFeHBhbmRlZDtcbiAgICB9O1xuICAgIHJvdy5nZXRUb2dnbGVFeHBhbmRlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5FeHBhbmQgPSByb3cuZ2V0Q2FuRXhwYW5kKCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbkV4cGFuZCkgcmV0dXJuO1xuICAgICAgICByb3cudG9nZ2xlRXhwYW5kZWQoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgZGVmYXVsdFBhZ2VJbmRleCA9IDA7XG5jb25zdCBkZWZhdWx0UGFnZVNpemUgPSAxMDtcbmNvbnN0IGdldERlZmF1bHRQYWdpbmF0aW9uU3RhdGUgPSAoKSA9PiAoe1xuICBwYWdlSW5kZXg6IGRlZmF1bHRQYWdlSW5kZXgsXG4gIHBhZ2VTaXplOiBkZWZhdWx0UGFnZVNpemVcbn0pO1xuY29uc3QgUm93UGFnaW5hdGlvbiA9IHtcbiAgZ2V0SW5pdGlhbFN0YXRlOiBzdGF0ZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAuLi5nZXREZWZhdWx0UGFnaW5hdGlvblN0YXRlKCksXG4gICAgICAgIC4uLihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUucGFnaW5hdGlvbilcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblBhZ2luYXRpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3BhZ2luYXRpb24nLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIGxldCByZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgbGV0IHF1ZXVlZCA9IGZhbHNlO1xuICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX3RhYmxlJG9wdGlvbnMkYXV0b1JlO1xuICAgICAgaWYgKCFyZWdpc3RlcmVkKSB7XG4gICAgICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICAgICAgcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKF9yZWYgPSAoX3RhYmxlJG9wdGlvbnMkYXV0b1JlID0gdGFibGUub3B0aW9ucy5hdXRvUmVzZXRBbGwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRhdXRvUmUgOiB0YWJsZS5vcHRpb25zLmF1dG9SZXNldFBhZ2VJbmRleCkgIT0gbnVsbCA/IF9yZWYgOiAhdGFibGUub3B0aW9ucy5tYW51YWxQYWdpbmF0aW9uKSB7XG4gICAgICAgIGlmIChxdWV1ZWQpIHJldHVybjtcbiAgICAgICAgcXVldWVkID0gdHJ1ZTtcbiAgICAgICAgdGFibGUuX3F1ZXVlKCgpID0+IHtcbiAgICAgICAgICB0YWJsZS5yZXNldFBhZ2VJbmRleCgpO1xuICAgICAgICAgIHF1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2luYXRpb24gPSB1cGRhdGVyID0+IHtcbiAgICAgIGNvbnN0IHNhZmVVcGRhdGVyID0gb2xkID0+IHtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQpO1xuICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMub25QYWdpbmF0aW9uQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUGFnaW5hdGlvbkNoYW5nZShzYWZlVXBkYXRlcik7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2luYXRpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcDtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24oZGVmYXVsdFN0YXRlID8gZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpIDogKF90YWJsZSRpbml0aWFsU3RhdGUkcCA9IHRhYmxlLmluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSAhPSBudWxsID8gX3RhYmxlJGluaXRpYWxTdGF0ZSRwIDogZ2V0RGVmYXVsdFBhZ2luYXRpb25TdGF0ZSgpKTtcbiAgICB9O1xuICAgIHRhYmxlLnNldFBhZ2VJbmRleCA9IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUuc2V0UGFnaW5hdGlvbihvbGQgPT4ge1xuICAgICAgICBsZXQgcGFnZUluZGV4ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCBvbGQucGFnZUluZGV4KTtcbiAgICAgICAgY29uc3QgbWF4UGFnZUluZGV4ID0gdHlwZW9mIHRhYmxlLm9wdGlvbnMucGFnZUNvdW50ID09PSAndW5kZWZpbmVkJyB8fCB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCA9PT0gLTEgPyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA6IHRhYmxlLm9wdGlvbnMucGFnZUNvdW50IC0gMTtcbiAgICAgICAgcGFnZUluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUluZGV4LCBtYXhQYWdlSW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5vbGQsXG4gICAgICAgICAgcGFnZUluZGV4XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRhYmxlLnJlc2V0UGFnZUluZGV4ID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAyLCBfdGFibGUkaW5pdGlhbFN0YXRlO1xuICAgICAgdGFibGUuc2V0UGFnZUluZGV4KGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlSW5kZXggOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRwMiA9IChfdGFibGUkaW5pdGlhbFN0YXRlID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlID0gX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdpbmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGluaXRpYWxTdGF0ZS5wYWdlSW5kZXgpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHAyIDogZGVmYXVsdFBhZ2VJbmRleCk7XG4gICAgfTtcbiAgICB0YWJsZS5yZXNldFBhZ2VTaXplID0gZGVmYXVsdFN0YXRlID0+IHtcbiAgICAgIHZhciBfdGFibGUkaW5pdGlhbFN0YXRlJHAzLCBfdGFibGUkaW5pdGlhbFN0YXRlMjtcbiAgICAgIHRhYmxlLnNldFBhZ2VTaXplKGRlZmF1bHRTdGF0ZSA/IGRlZmF1bHRQYWdlU2l6ZSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHAzID0gKF90YWJsZSRpbml0aWFsU3RhdGUyID0gdGFibGUuaW5pdGlhbFN0YXRlKSA9PSBudWxsIHx8IChfdGFibGUkaW5pdGlhbFN0YXRlMiA9IF90YWJsZSRpbml0aWFsU3RhdGUyLnBhZ2luYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlMi5wYWdlU2l6ZSkgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkcDMgOiBkZWZhdWx0UGFnZVNpemUpO1xuICAgIH07XG4gICAgdGFibGUuc2V0UGFnZVNpemUgPSB1cGRhdGVyID0+IHtcbiAgICAgIHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgICAgY29uc3QgcGFnZVNpemUgPSBNYXRoLm1heCgxLCBmdW5jdGlvbmFsVXBkYXRlKHVwZGF0ZXIsIG9sZC5wYWdlU2l6ZSkpO1xuICAgICAgICBjb25zdCB0b3BSb3dJbmRleCA9IG9sZC5wYWdlU2l6ZSAqIG9sZC5wYWdlSW5kZXg7XG4gICAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IE1hdGguZmxvb3IodG9wUm93SW5kZXggLyBwYWdlU2l6ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4ub2xkLFxuICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICBwYWdlU2l6ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvL2RlcHJlY2F0ZWRcbiAgICB0YWJsZS5zZXRQYWdlQ291bnQgPSB1cGRhdGVyID0+IHRhYmxlLnNldFBhZ2luYXRpb24ob2xkID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRwYWdlQ287XG4gICAgICBsZXQgbmV3UGFnZUNvdW50ID0gZnVuY3Rpb25hbFVwZGF0ZSh1cGRhdGVyLCAoX3RhYmxlJG9wdGlvbnMkcGFnZUNvID0gdGFibGUub3B0aW9ucy5wYWdlQ291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRwYWdlQ28gOiAtMSk7XG4gICAgICBpZiAodHlwZW9mIG5ld1BhZ2VDb3VudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbmV3UGFnZUNvdW50ID0gTWF0aC5tYXgoLTEsIG5ld1BhZ2VDb3VudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5vbGQsXG4gICAgICAgIHBhZ2VDb3VudDogbmV3UGFnZUNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRhYmxlLmdldFBhZ2VPcHRpb25zID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0UGFnZUNvdW50KCldLCBwYWdlQ291bnQgPT4ge1xuICAgICAgbGV0IHBhZ2VPcHRpb25zID0gW107XG4gICAgICBpZiAocGFnZUNvdW50ICYmIHBhZ2VDb3VudCA+IDApIHtcbiAgICAgICAgcGFnZU9wdGlvbnMgPSBbLi4ubmV3IEFycmF5KHBhZ2VDb3VudCldLmZpbGwobnVsbCkubWFwKChfLCBpKSA9PiBpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYWdlT3B0aW9ucztcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdlT3B0aW9ucycpKTtcbiAgICB0YWJsZS5nZXRDYW5QcmV2aW91c1BhZ2UgPSAoKSA9PiB0YWJsZS5nZXRTdGF0ZSgpLnBhZ2luYXRpb24ucGFnZUluZGV4ID4gMDtcbiAgICB0YWJsZS5nZXRDYW5OZXh0UGFnZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZUluZGV4XG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uO1xuICAgICAgY29uc3QgcGFnZUNvdW50ID0gdGFibGUuZ2V0UGFnZUNvdW50KCk7XG4gICAgICBpZiAocGFnZUNvdW50ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VJbmRleCA8IHBhZ2VDb3VudCAtIDE7XG4gICAgfTtcbiAgICB0YWJsZS5wcmV2aW91c1BhZ2UgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuc2V0UGFnZUluZGV4KG9sZCA9PiBvbGQgLSAxKTtcbiAgICB9O1xuICAgIHRhYmxlLm5leHRQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleChvbGQgPT4ge1xuICAgICAgICByZXR1cm4gb2xkICsgMTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGFibGUuZmlyc3RQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleCgwKTtcbiAgICB9O1xuICAgIHRhYmxlLmxhc3RQYWdlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRhYmxlLnNldFBhZ2VJbmRleCh0YWJsZS5nZXRQYWdlQ291bnQoKSAtIDEpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsID0gKCkgPT4gdGFibGUuZ2V0RXhwYW5kZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFBhZ2luYXRpb25Sb3dNb2RlbCA9ICgpID0+IHtcbiAgICAgIGlmICghdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCAmJiB0YWJsZS5vcHRpb25zLmdldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0UGFnaW5hdGlvblJvd01vZGVsID0gdGFibGUub3B0aW9ucy5nZXRQYWdpbmF0aW9uUm93TW9kZWwodGFibGUpO1xuICAgICAgfVxuICAgICAgaWYgKHRhYmxlLm9wdGlvbnMubWFudWFsUGFnaW5hdGlvbiB8fCAhdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlUGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldFBhZ2luYXRpb25Sb3dNb2RlbCgpO1xuICAgIH07XG4gICAgdGFibGUuZ2V0UGFnZUNvdW50ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJHBhZ2VDbzI7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgPSB0YWJsZS5vcHRpb25zLnBhZ2VDb3VudCkgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJHBhZ2VDbzIgOiBNYXRoLmNlaWwodGFibGUuZ2V0Um93Q291bnQoKSAvIHRhYmxlLmdldFN0YXRlKCkucGFnaW5hdGlvbi5wYWdlU2l6ZSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRSb3dDb3VudCA9ICgpID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRyb3dDb3U7XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJHJvd0NvdSA9IHRhYmxlLm9wdGlvbnMucm93Q291bnQpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRyb3dDb3UgOiB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKS5yb3dzLmxlbmd0aDtcbiAgICB9O1xuICB9XG59O1xuXG4vL1xuXG5jb25zdCBnZXREZWZhdWx0Um93UGlubmluZ1N0YXRlID0gKCkgPT4gKHtcbiAgdG9wOiBbXSxcbiAgYm90dG9tOiBbXVxufSk7XG5jb25zdCBSb3dQaW5uaW5nID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm93UGlubmluZzogZ2V0RGVmYXVsdFJvd1Bpbm5pbmdTdGF0ZSgpLFxuICAgICAgLi4uc3RhdGVcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblJvd1Bpbm5pbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1Bpbm5pbmcnLCB0YWJsZSlcbiAgICB9O1xuICB9LFxuICBjcmVhdGVSb3c6IChyb3csIHRhYmxlKSA9PiB7XG4gICAgcm93LnBpbiA9IChwb3NpdGlvbiwgaW5jbHVkZUxlYWZSb3dzLCBpbmNsdWRlUGFyZW50Um93cykgPT4ge1xuICAgICAgY29uc3QgbGVhZlJvd0lkcyA9IGluY2x1ZGVMZWFmUm93cyA/IHJvdy5nZXRMZWFmUm93cygpLm1hcChfcmVmID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGNvbnN0IHBhcmVudFJvd0lkcyA9IGluY2x1ZGVQYXJlbnRSb3dzID8gcm93LmdldFBhcmVudFJvd3MoKS5tYXAoX3JlZjIgPT4ge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSkgOiBbXTtcbiAgICAgIGNvbnN0IHJvd0lkcyA9IG5ldyBTZXQoWy4uLnBhcmVudFJvd0lkcywgcm93LmlkLCAuLi5sZWFmUm93SWRzXSk7XG4gICAgICB0YWJsZS5zZXRSb3dQaW5uaW5nKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb2xkJHRvcDMsIF9vbGQkYm90dG9tMztcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHZhciBfb2xkJHRvcCwgX29sZCRib3R0b207XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogKChfb2xkJHRvcCA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLFxuICAgICAgICAgICAgYm90dG9tOiBbLi4uKChfb2xkJGJvdHRvbSA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLmJvdHRvbSkgIT0gbnVsbCA/IF9vbGQkYm90dG9tIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpLCAuLi5BcnJheS5mcm9tKHJvd0lkcyldXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgdmFyIF9vbGQkdG9wMiwgX29sZCRib3R0b20yO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IFsuLi4oKF9vbGQkdG9wMiA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wMiA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSwgLi4uQXJyYXkuZnJvbShyb3dJZHMpXSxcbiAgICAgICAgICAgIGJvdHRvbTogKChfb2xkJGJvdHRvbTIgPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5ib3R0b20pICE9IG51bGwgPyBfb2xkJGJvdHRvbTIgOiBbXSkuZmlsdGVyKGQgPT4gIShyb3dJZHMgIT0gbnVsbCAmJiByb3dJZHMuaGFzKGQpKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdG9wOiAoKF9vbGQkdG9wMyA9IG9sZCA9PSBudWxsID8gdm9pZCAwIDogb2xkLnRvcCkgIT0gbnVsbCA/IF9vbGQkdG9wMyA6IFtdKS5maWx0ZXIoZCA9PiAhKHJvd0lkcyAhPSBudWxsICYmIHJvd0lkcy5oYXMoZCkpKSxcbiAgICAgICAgICBib3R0b206ICgoX29sZCRib3R0b20zID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuYm90dG9tKSAhPSBudWxsID8gX29sZCRib3R0b20zIDogW10pLmZpbHRlcihkID0+ICEocm93SWRzICE9IG51bGwgJiYgcm93SWRzLmhhcyhkKSkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5QaW4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZjM7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVuYWJsZVJvd1Bpbm5pbmcsXG4gICAgICAgIGVuYWJsZVBpbm5pbmdcbiAgICAgIH0gPSB0YWJsZS5vcHRpb25zO1xuICAgICAgaWYgKHR5cGVvZiBlbmFibGVSb3dQaW5uaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBlbmFibGVSb3dQaW5uaW5nKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF9yZWYzID0gZW5hYmxlUm93UGlubmluZyAhPSBudWxsID8gZW5hYmxlUm93UGlubmluZyA6IGVuYWJsZVBpbm5pbmcpICE9IG51bGwgPyBfcmVmMyA6IHRydWU7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNQaW5uZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCByb3dJZHMgPSBbcm93LmlkXTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b21cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmc7XG4gICAgICBjb25zdCBpc1RvcCA9IHJvd0lkcy5zb21lKGQgPT4gdG9wID09IG51bGwgPyB2b2lkIDAgOiB0b3AuaW5jbHVkZXMoZCkpO1xuICAgICAgY29uc3QgaXNCb3R0b20gPSByb3dJZHMuc29tZShkID0+IGJvdHRvbSA9PSBudWxsID8gdm9pZCAwIDogYm90dG9tLmluY2x1ZGVzKGQpKTtcbiAgICAgIHJldHVybiBpc1RvcCA/ICd0b3AnIDogaXNCb3R0b20gPyAnYm90dG9tJyA6IGZhbHNlO1xuICAgIH07XG4gICAgcm93LmdldFBpbm5lZEluZGV4ID0gKCkgPT4ge1xuICAgICAgdmFyIF9yZWY0LCBfdmlzaWJsZVBpbm5lZFJvd0lkcyQ7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHJvdy5nZXRJc1Bpbm5lZCgpO1xuICAgICAgaWYgKCFwb3NpdGlvbikgcmV0dXJuIC0xO1xuICAgICAgY29uc3QgdmlzaWJsZVBpbm5lZFJvd0lkcyA9IChfcmVmNCA9IHBvc2l0aW9uID09PSAndG9wJyA/IHRhYmxlLmdldFRvcFJvd3MoKSA6IHRhYmxlLmdldEJvdHRvbVJvd3MoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWY0Lm1hcChfcmVmNSA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoX3Zpc2libGVQaW5uZWRSb3dJZHMkID0gdmlzaWJsZVBpbm5lZFJvd0lkcyA9PSBudWxsID8gdm9pZCAwIDogdmlzaWJsZVBpbm5lZFJvd0lkcy5pbmRleE9mKHJvdy5pZCkpICE9IG51bGwgPyBfdmlzaWJsZVBpbm5lZFJvd0lkcyQgOiAtMTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFJvd1Bpbm5pbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dQaW5uaW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uUm93UGlubmluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFJvd1Bpbm5pbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkciwgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRSb3dQaW5uaW5nKGRlZmF1bHRTdGF0ZSA/IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSA6IChfdGFibGUkaW5pdGlhbFN0YXRlJHIgPSAoX3RhYmxlJGluaXRpYWxTdGF0ZSA9IHRhYmxlLmluaXRpYWxTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRpbml0aWFsU3RhdGUucm93UGlubmluZykgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IGdldERlZmF1bHRSb3dQaW5uaW5nU3RhdGUoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzUGlubmVkID0gcG9zaXRpb24gPT4ge1xuICAgICAgdmFyIF9waW5uaW5nU3RhdGUkcG9zaXRpbztcbiAgICAgIGNvbnN0IHBpbm5pbmdTdGF0ZSA9IHRhYmxlLmdldFN0YXRlKCkucm93UGlubmluZztcbiAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9waW5uaW5nU3RhdGUkdG9wLCBfcGlubmluZ1N0YXRlJGJvdHRvbTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKChfcGlubmluZ1N0YXRlJHRvcCA9IHBpbm5pbmdTdGF0ZS50b3ApID09IG51bGwgPyB2b2lkIDAgOiBfcGlubmluZ1N0YXRlJHRvcC5sZW5ndGgpIHx8ICgoX3Bpbm5pbmdTdGF0ZSRib3R0b20gPSBwaW5uaW5nU3RhdGUuYm90dG9tKSA9PSBudWxsID8gdm9pZCAwIDogX3Bpbm5pbmdTdGF0ZSRib3R0b20ubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQm9vbGVhbigoX3Bpbm5pbmdTdGF0ZSRwb3NpdGlvID0gcGlubmluZ1N0YXRlW3Bvc2l0aW9uXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9waW5uaW5nU3RhdGUkcG9zaXRpby5sZW5ndGgpO1xuICAgIH07XG4gICAgdGFibGUuX2dldFBpbm5lZFJvd3MgPSAodmlzaWJsZVJvd3MsIHBpbm5lZFJvd0lkcywgcG9zaXRpb24pID0+IHtcbiAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRrZWVwUGk7XG4gICAgICBjb25zdCByb3dzID0gKChfdGFibGUkb3B0aW9ucyRrZWVwUGkgPSB0YWJsZS5vcHRpb25zLmtlZXBQaW5uZWRSb3dzKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMka2VlcFBpIDogdHJ1ZSkgP1xuICAgICAgLy9nZXQgYWxsIHJvd3MgdGhhdCBhcmUgcGlubmVkIGV2ZW4gaWYgdGhleSB3b3VsZCBub3QgYmUgb3RoZXJ3aXNlIHZpc2libGVcbiAgICAgIC8vYWNjb3VudCBmb3IgZXhwYW5kZWQgcGFyZW50IHJvd3MsIGJ1dCBub3QgcGFnaW5hdGlvbiBvciBmaWx0ZXJpbmdcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4ge1xuICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5nZXRSb3cocm93SWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gcm93LmdldElzQWxsUGFyZW50c0V4cGFuZGVkKCkgPyByb3cgOiBudWxsO1xuICAgICAgfSkgOlxuICAgICAgLy9lbHNlIGdldCBvbmx5IHZpc2libGUgcm93cyB0aGF0IGFyZSBwaW5uZWRcbiAgICAgIChwaW5uZWRSb3dJZHMgIT0gbnVsbCA/IHBpbm5lZFJvd0lkcyA6IFtdKS5tYXAocm93SWQgPT4gdmlzaWJsZVJvd3MuZmluZChyb3cgPT4gcm93LmlkID09PSByb3dJZCkpO1xuICAgICAgcmV0dXJuIHJvd3MuZmlsdGVyKEJvb2xlYW4pLm1hcChkID0+ICh7XG4gICAgICAgIC4uLmQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb3BSb3dzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcudG9wXSwgKGFsbFJvd3MsIHRvcFBpbm5lZFJvd0lkcykgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoYWxsUm93cywgdG9wUGlubmVkUm93SWRzLCAndG9wJyksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0VG9wUm93cycpKTtcbiAgICB0YWJsZS5nZXRCb3R0b21Sb3dzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcuYm90dG9tXSwgKGFsbFJvd3MsIGJvdHRvbVBpbm5lZFJvd0lkcykgPT4gdGFibGUuX2dldFBpbm5lZFJvd3MoYWxsUm93cywgYm90dG9tUGlubmVkUm93SWRzLCAnYm90dG9tJyksIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Qm90dG9tUm93cycpKTtcbiAgICB0YWJsZS5nZXRDZW50ZXJSb3dzID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0Um93TW9kZWwoKS5yb3dzLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcudG9wLCB0YWJsZS5nZXRTdGF0ZSgpLnJvd1Bpbm5pbmcuYm90dG9tXSwgKGFsbFJvd3MsIHRvcCwgYm90dG9tKSA9PiB7XG4gICAgICBjb25zdCB0b3BBbmRCb3R0b20gPSBuZXcgU2V0KFsuLi4odG9wICE9IG51bGwgPyB0b3AgOiBbXSksIC4uLihib3R0b20gIT0gbnVsbCA/IGJvdHRvbSA6IFtdKV0pO1xuICAgICAgcmV0dXJuIGFsbFJvd3MuZmlsdGVyKGQgPT4gIXRvcEFuZEJvdHRvbS5oYXMoZC5pZCkpO1xuICAgIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1Jvd3MnLCAnZ2V0Q2VudGVyUm93cycpKTtcbiAgfVxufTtcblxuLy9cblxuY29uc3QgUm93U2VsZWN0aW9uID0ge1xuICBnZXRJbml0aWFsU3RhdGU6IHN0YXRlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcm93U2VsZWN0aW9uOiB7fSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdE9wdGlvbnM6IHRhYmxlID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3Jvd1NlbGVjdGlvbicsIHRhYmxlKSxcbiAgICAgIGVuYWJsZVJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuYWJsZU11bHRpUm93U2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlU3ViUm93U2VsZWN0aW9uOiB0cnVlXG4gICAgICAvLyBlbmFibGVHcm91cGluZ1Jvd1NlbGVjdGlvbjogZmFsc2UsXG4gICAgICAvLyBpc0FkZGl0aXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUubWV0YUtleSxcbiAgICAgIC8vIGlzSW5jbHVzaXZlU2VsZWN0RXZlbnQ6IChlOiB1bmtub3duKSA9PiAhIWUuc2hpZnRLZXksXG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlVGFibGU6IHRhYmxlID0+IHtcbiAgICB0YWJsZS5zZXRSb3dTZWxlY3Rpb24gPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHRhYmxlLm9wdGlvbnMub25Sb3dTZWxlY3Rpb25DaGFuZ2UodXBkYXRlcik7XG4gICAgdGFibGUucmVzZXRSb3dTZWxlY3Rpb24gPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcjtcbiAgICAgIHJldHVybiB0YWJsZS5zZXRSb3dTZWxlY3Rpb24oZGVmYXVsdFN0YXRlID8ge30gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRyID0gdGFibGUuaW5pdGlhbFN0YXRlLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRpbml0aWFsU3RhdGUkciA6IHt9KTtcbiAgICB9O1xuICAgIHRhYmxlLnRvZ2dsZUFsbFJvd3NTZWxlY3RlZCA9IHZhbHVlID0+IHtcbiAgICAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihvbGQgPT4ge1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6ICF0YWJsZS5nZXRJc0FsbFJvd3NTZWxlY3RlZCgpO1xuICAgICAgICBjb25zdCByb3dTZWxlY3Rpb24gPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHByZUdyb3VwZWRGbGF0Um93cyA9IHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpLmZsYXRSb3dzO1xuXG4gICAgICAgIC8vIFdlIGRvbid0IHVzZSBgbXV0YXRlUm93SXNTZWxlY3RlZGAgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAgICAgICAgLy8gQWxsIG9mIHRoZSByb3dzIGFyZSBmbGF0IGFscmVhZHksIHNvIGl0IHdvdWxkbid0IGJlIHdvcnRoIGl0XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHByZUdyb3VwZWRGbGF0Um93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBpZiAoIXJvdy5nZXRDYW5TZWxlY3QoKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dTZWxlY3Rpb25bcm93LmlkXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJlR3JvdXBlZEZsYXRSb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSByb3dTZWxlY3Rpb25bcm93LmlkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93U2VsZWN0aW9uO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0YWJsZS50b2dnbGVBbGxQYWdlUm93c1NlbGVjdGVkID0gdmFsdWUgPT4gdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICBjb25zdCByZXNvbHZlZFZhbHVlID0gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlIDogIXRhYmxlLmdldElzQWxsUGFnZVJvd3NTZWxlY3RlZCgpO1xuICAgICAgY29uc3Qgcm93U2VsZWN0aW9uID0ge1xuICAgICAgICAuLi5vbGRcbiAgICAgIH07XG4gICAgICB0YWJsZS5nZXRSb3dNb2RlbCgpLnJvd3MuZm9yRWFjaChyb3cgPT4ge1xuICAgICAgICBtdXRhdGVSb3dJc1NlbGVjdGVkKHJvd1NlbGVjdGlvbiwgcm93LmlkLCByZXNvbHZlZFZhbHVlLCB0cnVlLCB0YWJsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByb3dTZWxlY3Rpb247XG4gICAgfSk7XG5cbiAgICAvLyBhZGRSb3dTZWxlY3Rpb25SYW5nZTogcm93SWQgPT4ge1xuICAgIC8vICAgY29uc3Qge1xuICAgIC8vICAgICByb3dzLFxuICAgIC8vICAgICByb3dzQnlJZCxcbiAgICAvLyAgICAgb3B0aW9uczogeyBzZWxlY3RHcm91cGluZ1Jvd3MsIHNlbGVjdFN1YlJvd3MgfSxcbiAgICAvLyAgIH0gPSB0YWJsZVxuXG4gICAgLy8gICBjb25zdCBmaW5kU2VsZWN0ZWRSb3cgPSAocm93czogUm93W10pID0+IHtcbiAgICAvLyAgICAgbGV0IGZvdW5kXG4gICAgLy8gICAgIHJvd3MuZmluZChkID0+IHtcbiAgICAvLyAgICAgICBpZiAoZC5nZXRJc1NlbGVjdGVkKCkpIHtcbiAgICAvLyAgICAgICAgIGZvdW5kID0gZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgY29uc3Qgc3ViRm91bmQgPSBmaW5kU2VsZWN0ZWRSb3coZC5zdWJSb3dzIHx8IFtdKVxuICAgIC8vICAgICAgIGlmIChzdWJGb3VuZCkge1xuICAgIC8vICAgICAgICAgZm91bmQgPSBzdWJGb3VuZFxuICAgIC8vICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICAgIHJldHVybiBmb3VuZFxuICAgIC8vICAgfVxuXG4gICAgLy8gICBjb25zdCBmaXJzdFJvdyA9IGZpbmRTZWxlY3RlZFJvdyhyb3dzKSB8fCByb3dzWzBdXG4gICAgLy8gICBjb25zdCBsYXN0Um93ID0gcm93c0J5SWRbcm93SWRdXG5cbiAgICAvLyAgIGxldCBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgIGNvbnN0IHNlbGVjdGVkUm93SWRzID0ge31cblxuICAgIC8vICAgY29uc3QgYWRkUm93ID0gKHJvdzogUm93KSA9PiB7XG4gICAgLy8gICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdHJ1ZSwge1xuICAgIC8vICAgICAgIHJvd3NCeUlkLFxuICAgIC8vICAgICAgIHNlbGVjdEdyb3VwaW5nUm93czogc2VsZWN0R3JvdXBpbmdSb3dzISxcbiAgICAvLyAgICAgICBzZWxlY3RTdWJSb3dzOiBzZWxlY3RTdWJSb3dzISxcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgIH1cblxuICAgIC8vICAgdGFibGUucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgLy8gICAgIGNvbnN0IGlzRmlyc3RSb3cgPSByb3cuaWQgPT09IGZpcnN0Um93LmlkXG4gICAgLy8gICAgIGNvbnN0IGlzTGFzdFJvdyA9IHJvdy5pZCA9PT0gbGFzdFJvdy5pZFxuXG4gICAgLy8gICAgIGlmIChpc0ZpcnN0Um93IHx8IGlzTGFzdFJvdykge1xuICAgIC8vICAgICAgIGlmICghaW5jbHVkZSkge1xuICAgIC8vICAgICAgICAgaW5jbHVkZSA9IHRydWVcbiAgICAvLyAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGUpIHtcbiAgICAvLyAgICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgICAgICBpbmNsdWRlID0gZmFsc2VcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZiAoaW5jbHVkZSkge1xuICAgIC8vICAgICAgIGFkZFJvdyhyb3cpXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0pXG5cbiAgICAvLyAgIHRhYmxlLnNldFJvd1NlbGVjdGlvbihzZWxlY3RlZFJvd0lkcylcbiAgICAvLyB9LFxuICAgIHRhYmxlLmdldFByZVNlbGVjdGVkUm93TW9kZWwgPSAoKSA9PiB0YWJsZS5nZXRDb3JlUm93TW9kZWwoKTtcbiAgICB0YWJsZS5nZXRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldENvcmVSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0U2VsZWN0ZWRSb3dNb2RlbCcpKTtcbiAgICB0YWJsZS5nZXRGaWx0ZXJlZFNlbGVjdGVkUm93TW9kZWwgPSBtZW1vKCgpID0+IFt0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbiwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHJvd1NlbGVjdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICAgIGlmICghT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb3dzOiBbXSxcbiAgICAgICAgICBmbGF0Um93czogW10sXG4gICAgICAgICAgcm93c0J5SWQ6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0Um93c0ZuKHRhYmxlLCByb3dNb2RlbCk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0RmlsdGVyZWRTZWxlY3RlZFJvd01vZGVsJykpO1xuICAgIHRhYmxlLmdldEdyb3VwZWRTZWxlY3RlZFJvd01vZGVsID0gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5yb3dTZWxlY3Rpb24sIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsKCldLCAocm93U2VsZWN0aW9uLCByb3dNb2RlbCkgPT4ge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhyb3dTZWxlY3Rpb24pLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvd3M6IFtdLFxuICAgICAgICAgIGZsYXRSb3dzOiBbXSxcbiAgICAgICAgICByb3dzQnlJZDoge31cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRHcm91cGVkU2VsZWN0ZWRSb3dNb2RlbCcpKTtcblxuICAgIC8vL1xuXG4gICAgLy8gZ2V0R3JvdXBpbmdSb3dDYW5TZWxlY3Q6IHJvd0lkID0+IHtcbiAgICAvLyAgIGNvbnN0IHJvdyA9IHRhYmxlLmdldFJvdyhyb3dJZClcblxuICAgIC8vICAgaWYgKCFyb3cpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKClcbiAgICAvLyAgIH1cblxuICAgIC8vICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gICAgIHJldHVybiB0YWJsZS5vcHRpb25zLmVuYWJsZUdyb3VwaW5nUm93U2VsZWN0aW9uKHJvdylcbiAgICAvLyAgIH1cblxuICAgIC8vICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24gPz8gZmFsc2VcbiAgICAvLyB9LFxuXG4gICAgdGFibGUuZ2V0SXNBbGxSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwcmVHcm91cGVkRmxhdFJvd3MgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxSb3dzU2VsZWN0ZWQgPSBCb29sZWFuKHByZUdyb3VwZWRGbGF0Um93cy5sZW5ndGggJiYgT2JqZWN0LmtleXMocm93U2VsZWN0aW9uKS5sZW5ndGgpO1xuICAgICAgaWYgKGlzQWxsUm93c1NlbGVjdGVkKSB7XG4gICAgICAgIGlmIChwcmVHcm91cGVkRmxhdFJvd3Muc29tZShyb3cgPT4gcm93LmdldENhblNlbGVjdCgpICYmICFyb3dTZWxlY3Rpb25bcm93LmlkXSkpIHtcbiAgICAgICAgICBpc0FsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBbGxSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYWdpbmF0aW9uRmxhdFJvd3MgPSB0YWJsZS5nZXRQYWdpbmF0aW9uUm93TW9kZWwoKS5mbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvd1NlbGVjdGlvblxuICAgICAgfSA9IHRhYmxlLmdldFN0YXRlKCk7XG4gICAgICBsZXQgaXNBbGxQYWdlUm93c1NlbGVjdGVkID0gISFwYWdpbmF0aW9uRmxhdFJvd3MubGVuZ3RoO1xuICAgICAgaWYgKGlzQWxsUGFnZVJvd3NTZWxlY3RlZCAmJiBwYWdpbmF0aW9uRmxhdFJvd3Muc29tZShyb3cgPT4gIXJvd1NlbGVjdGlvbltyb3cuaWRdKSkge1xuICAgICAgICBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FsbFBhZ2VSb3dzU2VsZWN0ZWQ7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVSb3dzU2VsZWN0ZWQgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHJvd1NlO1xuICAgICAgY29uc3QgdG90YWxTZWxlY3RlZCA9IE9iamVjdC5rZXlzKChfdGFibGUkZ2V0U3RhdGUkcm93U2UgPSB0YWJsZS5nZXRTdGF0ZSgpLnJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRnZXRTdGF0ZSRyb3dTZSA6IHt9KS5sZW5ndGg7XG4gICAgICByZXR1cm4gdG90YWxTZWxlY3RlZCA+IDAgJiYgdG90YWxTZWxlY3RlZCA8IHRhYmxlLmdldEZpbHRlcmVkUm93TW9kZWwoKS5mbGF0Um93cy5sZW5ndGg7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRJc1NvbWVQYWdlUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFnaW5hdGlvbkZsYXRSb3dzID0gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCkuZmxhdFJvd3M7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0SXNBbGxQYWdlUm93c1NlbGVjdGVkKCkgPyBmYWxzZSA6IHBhZ2luYXRpb25GbGF0Um93cy5maWx0ZXIocm93ID0+IHJvdy5nZXRDYW5TZWxlY3QoKSkuc29tZShkID0+IGQuZ2V0SXNTZWxlY3RlZCgpIHx8IGQuZ2V0SXNTb21lU2VsZWN0ZWQoKSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRUb2dnbGVBbGxSb3dzU2VsZWN0ZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICB0YWJsZS50b2dnbGVBbGxSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gICAgdGFibGUuZ2V0VG9nZ2xlQWxsUGFnZVJvd3NTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHRhYmxlLnRvZ2dsZUFsbFBhZ2VSb3dzU2VsZWN0ZWQoZS50YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH0sXG4gIGNyZWF0ZVJvdzogKHJvdywgdGFibGUpID0+IHtcbiAgICByb3cudG9nZ2xlU2VsZWN0ZWQgPSAodmFsdWUsIG9wdHMpID0+IHtcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSByb3cuZ2V0SXNTZWxlY3RlZCgpO1xuICAgICAgdGFibGUuc2V0Um93U2VsZWN0aW9uKG9sZCA9PiB7XG4gICAgICAgIHZhciBfb3B0cyRzZWxlY3RDaGlsZHJlbjtcbiAgICAgICAgdmFsdWUgPSB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnID8gdmFsdWUgOiAhaXNTZWxlY3RlZDtcbiAgICAgICAgaWYgKHJvdy5nZXRDYW5TZWxlY3QoKSAmJiBpc1NlbGVjdGVkID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRSb3dJZHMgPSB7XG4gICAgICAgICAgLi4ub2xkXG4gICAgICAgIH07XG4gICAgICAgIG11dGF0ZVJvd0lzU2VsZWN0ZWQoc2VsZWN0ZWRSb3dJZHMsIHJvdy5pZCwgdmFsdWUsIChfb3B0cyRzZWxlY3RDaGlsZHJlbiA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuc2VsZWN0Q2hpbGRyZW4pICE9IG51bGwgPyBfb3B0cyRzZWxlY3RDaGlsZHJlbiA6IHRydWUsIHRhYmxlKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkUm93SWRzO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICByb3cuZ2V0SXNTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1Jvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKTtcbiAgICB9O1xuICAgIHJvdy5nZXRJc1NvbWVTZWxlY3RlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm93U2VsZWN0aW9uXG4gICAgICB9ID0gdGFibGUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgcm93U2VsZWN0aW9uKSA9PT0gJ3NvbWUnO1xuICAgIH07XG4gICAgcm93LmdldElzQWxsU3ViUm93c1NlbGVjdGVkID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByb3dTZWxlY3Rpb25cbiAgICAgIH0gPSB0YWJsZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGlzU3ViUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pID09PSAnYWxsJztcbiAgICB9O1xuICAgIHJvdy5nZXRDYW5TZWxlY3QgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlO1xuICAgICAgaWYgKHR5cGVvZiB0YWJsZS5vcHRpb25zLmVuYWJsZVJvd1NlbGVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlID0gdGFibGUub3B0aW9ucy5lbmFibGVSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhblNlbGVjdFN1YlJvd3MgPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGlmICh0eXBlb2YgdGFibGUub3B0aW9ucy5lbmFibGVTdWJSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlU3ViUm93U2VsZWN0aW9uKHJvdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKF90YWJsZSRvcHRpb25zJGVuYWJsZTIgPSB0YWJsZS5vcHRpb25zLmVuYWJsZVN1YlJvd1NlbGVjdGlvbikgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTIgOiB0cnVlO1xuICAgIH07XG4gICAgcm93LmdldENhbk11bHRpU2VsZWN0ID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZTM7XG4gICAgICBpZiAodHlwZW9mIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24ocm93KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSb3dTZWxlY3Rpb24pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUzIDogdHJ1ZTtcbiAgICB9O1xuICAgIHJvdy5nZXRUb2dnbGVTZWxlY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjYW5TZWxlY3QgPSByb3cuZ2V0Q2FuU2VsZWN0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIHZhciBfdGFyZ2V0O1xuICAgICAgICBpZiAoIWNhblNlbGVjdCkgcmV0dXJuO1xuICAgICAgICByb3cudG9nZ2xlU2VsZWN0ZWQoKF90YXJnZXQgPSBlLnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YXJnZXQuY2hlY2tlZCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn07XG5jb25zdCBtdXRhdGVSb3dJc1NlbGVjdGVkID0gKHNlbGVjdGVkUm93SWRzLCBpZCwgdmFsdWUsIGluY2x1ZGVDaGlsZHJlbiwgdGFibGUpID0+IHtcbiAgdmFyIF9yb3ckc3ViUm93cztcbiAgY29uc3Qgcm93ID0gdGFibGUuZ2V0Um93KGlkLCB0cnVlKTtcblxuICAvLyBjb25zdCBpc0dyb3VwZWQgPSByb3cuZ2V0SXNHcm91cGVkKClcblxuICAvLyBpZiAoIC8vIFRPRE86IGVuZm9yY2UgZ3JvdXBpbmcgcm93IHNlbGVjdGlvbiBydWxlc1xuICAvLyAgICFpc0dyb3VwZWQgfHxcbiAgLy8gICAoaXNHcm91cGVkICYmIHRhYmxlLm9wdGlvbnMuZW5hYmxlR3JvdXBpbmdSb3dTZWxlY3Rpb24pXG4gIC8vICkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIXJvdy5nZXRDYW5NdWx0aVNlbGVjdCgpKSB7XG4gICAgICBPYmplY3Qua2V5cyhzZWxlY3RlZFJvd0lkcykuZm9yRWFjaChrZXkgPT4gZGVsZXRlIHNlbGVjdGVkUm93SWRzW2tleV0pO1xuICAgIH1cbiAgICBpZiAocm93LmdldENhblNlbGVjdCgpKSB7XG4gICAgICBzZWxlY3RlZFJvd0lkc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWxldGUgc2VsZWN0ZWRSb3dJZHNbaWRdO1xuICB9XG4gIC8vIH1cblxuICBpZiAoaW5jbHVkZUNoaWxkcmVuICYmIChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRDYW5TZWxlY3RTdWJSb3dzKCkpIHtcbiAgICByb3cuc3ViUm93cy5mb3JFYWNoKHJvdyA9PiBtdXRhdGVSb3dJc1NlbGVjdGVkKHNlbGVjdGVkUm93SWRzLCByb3cuaWQsIHZhbHVlLCBpbmNsdWRlQ2hpbGRyZW4sIHRhYmxlKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzZWxlY3RSb3dzRm4odGFibGUsIHJvd01vZGVsKSB7XG4gIGNvbnN0IHJvd1NlbGVjdGlvbiA9IHRhYmxlLmdldFN0YXRlKCkucm93U2VsZWN0aW9uO1xuICBjb25zdCBuZXdTZWxlY3RlZEZsYXRSb3dzID0gW107XG4gIGNvbnN0IG5ld1NlbGVjdGVkUm93c0J5SWQgPSB7fTtcblxuICAvLyBGaWx0ZXJzIHRvcCBsZXZlbCBhbmQgbmVzdGVkIHJvd3NcbiAgY29uc3QgcmVjdXJzZVJvd3MgPSBmdW5jdGlvbiAocm93cywgZGVwdGgpIHtcbiAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgIHZhciBfcm93JHN1YlJvd3MyO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGlzUm93U2VsZWN0ZWQocm93LCByb3dTZWxlY3Rpb24pO1xuICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgbmV3U2VsZWN0ZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIG5ld1NlbGVjdGVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgIH1cbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoKSB7XG4gICAgICAgIHJvdyA9IHtcbiAgICAgICAgICAuLi5yb3csXG4gICAgICAgICAgc3ViUm93czogcmVjdXJzZVJvd3Mocm93LnN1YlJvd3MpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcm93O1xuICAgICAgfVxuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlUm93cyhyb3dNb2RlbC5yb3dzKSxcbiAgICBmbGF0Um93czogbmV3U2VsZWN0ZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3U2VsZWN0ZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gaXNSb3dTZWxlY3RlZChyb3csIHNlbGVjdGlvbikge1xuICB2YXIgX3NlbGVjdGlvbiRyb3ckaWQ7XG4gIHJldHVybiAoX3NlbGVjdGlvbiRyb3ckaWQgPSBzZWxlY3Rpb25bcm93LmlkXSkgIT0gbnVsbCA/IF9zZWxlY3Rpb24kcm93JGlkIDogZmFsc2U7XG59XG5mdW5jdGlvbiBpc1N1YlJvd1NlbGVjdGVkKHJvdywgc2VsZWN0aW9uLCB0YWJsZSkge1xuICB2YXIgX3JvdyRzdWJSb3dzMztcbiAgaWYgKCEoKF9yb3ckc3ViUm93czMgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MzLmxlbmd0aCkpIHJldHVybiBmYWxzZTtcbiAgbGV0IGFsbENoaWxkcmVuU2VsZWN0ZWQgPSB0cnVlO1xuICBsZXQgc29tZVNlbGVjdGVkID0gZmFsc2U7XG4gIHJvdy5zdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAvLyBCYWlsIG91dCBlYXJseSBpZiB3ZSBrbm93IGJvdGggb2YgdGhlc2VcbiAgICBpZiAoc29tZVNlbGVjdGVkICYmICFhbGxDaGlsZHJlblNlbGVjdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdWJSb3cuZ2V0Q2FuU2VsZWN0KCkpIHtcbiAgICAgIGlmIChpc1Jvd1NlbGVjdGVkKHN1YlJvdywgc2VsZWN0aW9uKSkge1xuICAgICAgICBzb21lU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxsQ2hpbGRyZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHJvdyBzZWxlY3Rpb24gb2YgbmVzdGVkIHN1YnJvd3NcbiAgICBpZiAoc3ViUm93LnN1YlJvd3MgJiYgc3ViUm93LnN1YlJvd3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBzdWJSb3dDaGlsZHJlblNlbGVjdGVkID0gaXNTdWJSb3dTZWxlY3RlZChzdWJSb3csIHNlbGVjdGlvbik7XG4gICAgICBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgc29tZVNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3ViUm93Q2hpbGRyZW5TZWxlY3RlZCA9PT0gJ3NvbWUnKSB7XG4gICAgICAgIHNvbWVTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsbENoaWxkcmVuU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYWxsQ2hpbGRyZW5TZWxlY3RlZCA/ICdhbGwnIDogc29tZVNlbGVjdGVkID8gJ3NvbWUnIDogZmFsc2U7XG59XG5cbmNvbnN0IHJlU3BsaXRBbHBoYU51bWVyaWMgPSAvKFswLTldKykvZ207XG5jb25zdCBhbHBoYW51bWVyaWMgPSAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgcmV0dXJuIGNvbXBhcmVBbHBoYW51bWVyaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLnRvTG93ZXJDYXNlKCksIHRvU3RyaW5nKHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpKTtcbn07XG5jb25zdCBhbHBoYW51bWVyaWNDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQWxwaGFudW1lcmljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKSwgdG9TdHJpbmcocm93Qi5nZXRWYWx1ZShjb2x1bW5JZCkpKTtcbn07XG5cbi8vIFRoZSB0ZXh0IGZpbHRlciBpcyBtb3JlIGJhc2ljIChsZXNzIG51bWVyaWMgc3VwcG9ydClcbi8vIGJ1dCBpcyBtdWNoIGZhc3RlclxuY29uc3QgdGV4dCA9IChyb3dBLCByb3dCLCBjb2x1bW5JZCkgPT4ge1xuICByZXR1cm4gY29tcGFyZUJhc2ljKHRvU3RyaW5nKHJvd0EuZ2V0VmFsdWUoY29sdW1uSWQpKS50b0xvd2VyQ2FzZSgpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkudG9Mb3dlckNhc2UoKSk7XG59O1xuXG4vLyBUaGUgdGV4dCBmaWx0ZXIgaXMgbW9yZSBiYXNpYyAobGVzcyBudW1lcmljIHN1cHBvcnQpXG4vLyBidXQgaXMgbXVjaCBmYXN0ZXJcbmNvbnN0IHRleHRDYXNlU2Vuc2l0aXZlID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWModG9TdHJpbmcocm93QS5nZXRWYWx1ZShjb2x1bW5JZCkpLCB0b1N0cmluZyhyb3dCLmdldFZhbHVlKGNvbHVtbklkKSkpO1xufTtcbmNvbnN0IGRhdGV0aW1lID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIGNvbnN0IGEgPSByb3dBLmdldFZhbHVlKGNvbHVtbklkKTtcbiAgY29uc3QgYiA9IHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpO1xuXG4gIC8vIENhbiBoYW5kbGUgbnVsbGlzaCB2YWx1ZXNcbiAgLy8gVXNlID4gYW5kIDwgYmVjYXVzZSA9PSAoYW5kID09PSkgZG9lc24ndCB3b3JrIHdpdGhcbiAgLy8gRGF0ZSBvYmplY3RzICh3b3VsZCByZXF1aXJlIGNhbGxpbmcgZ2V0VGltZSgpKS5cbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xufTtcbmNvbnN0IGJhc2ljID0gKHJvd0EsIHJvd0IsIGNvbHVtbklkKSA9PiB7XG4gIHJldHVybiBjb21wYXJlQmFzaWMocm93QS5nZXRWYWx1ZShjb2x1bW5JZCksIHJvd0IuZ2V0VmFsdWUoY29sdW1uSWQpKTtcbn07XG5cbi8vIFV0aWxzXG5cbmZ1bmN0aW9uIGNvbXBhcmVCYXNpYyhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuZnVuY3Rpb24gdG9TdHJpbmcoYSkge1xuICBpZiAodHlwZW9mIGEgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGlzTmFOKGEpIHx8IGEgPT09IEluZmluaXR5IHx8IGEgPT09IC1JbmZpbml0eSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGEpO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYTtcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8vIE1peGVkIHNvcnRpbmcgaXMgc2xvdywgYnV0IHZlcnkgaW5jbHVzaXZlIG9mIG1hbnkgZWRnZSBjYXNlcy5cbi8vIEl0IGhhbmRsZXMgbnVtYmVycywgbWl4ZWQgYWxwaGFudW1lcmljIGNvbWJpbmF0aW9ucywgYW5kIGV2ZW5cbi8vIG51bGwsIHVuZGVmaW5lZCwgYW5kIEluZmluaXR5XG5mdW5jdGlvbiBjb21wYXJlQWxwaGFudW1lcmljKGFTdHIsIGJTdHIpIHtcbiAgLy8gU3BsaXQgb24gbnVtYmVyIGdyb3VwcywgYnV0IGtlZXAgdGhlIGRlbGltaXRlclxuICAvLyBUaGVuIHJlbW92ZSBmYWxzZXkgc3BsaXQgdmFsdWVzXG4gIGNvbnN0IGEgPSBhU3RyLnNwbGl0KHJlU3BsaXRBbHBoYU51bWVyaWMpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgYiA9IGJTdHIuc3BsaXQocmVTcGxpdEFscGhhTnVtZXJpYykuZmlsdGVyKEJvb2xlYW4pO1xuXG4gIC8vIFdoaWxlXG4gIHdoaWxlIChhLmxlbmd0aCAmJiBiLmxlbmd0aCkge1xuICAgIGNvbnN0IGFhID0gYS5zaGlmdCgpO1xuICAgIGNvbnN0IGJiID0gYi5zaGlmdCgpO1xuICAgIGNvbnN0IGFuID0gcGFyc2VJbnQoYWEsIDEwKTtcbiAgICBjb25zdCBibiA9IHBhcnNlSW50KGJiLCAxMCk7XG4gICAgY29uc3QgY29tYm8gPSBbYW4sIGJuXS5zb3J0KCk7XG5cbiAgICAvLyBCb3RoIGFyZSBzdHJpbmdcbiAgICBpZiAoaXNOYU4oY29tYm9bMF0pKSB7XG4gICAgICBpZiAoYWEgPiBiYikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChiYiA+IGFhKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIE9uZSBpcyBhIHN0cmluZywgb25lIGlzIGEgbnVtYmVyXG4gICAgaWYgKGlzTmFOKGNvbWJvWzFdKSkge1xuICAgICAgcmV0dXJuIGlzTmFOKGFuKSA/IC0xIDogMTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIGFyZSBudW1iZXJzXG4gICAgaWYgKGFuID4gYm4pIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoYm4gPiBhbikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuLy8gRXhwb3J0c1xuXG5jb25zdCBzb3J0aW5nRm5zID0ge1xuICBhbHBoYW51bWVyaWMsXG4gIGFscGhhbnVtZXJpY0Nhc2VTZW5zaXRpdmUsXG4gIHRleHQsXG4gIHRleHRDYXNlU2Vuc2l0aXZlLFxuICBkYXRldGltZSxcbiAgYmFzaWNcbn07XG5cbi8vXG5cbmNvbnN0IFJvd1NvcnRpbmcgPSB7XG4gIGdldEluaXRpYWxTdGF0ZTogc3RhdGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nOiBbXSxcbiAgICAgIC4uLnN0YXRlXG4gICAgfTtcbiAgfSxcbiAgZ2V0RGVmYXVsdENvbHVtbkRlZjogKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nRm46ICdhdXRvJyxcbiAgICAgIHNvcnRVbmRlZmluZWQ6IDFcbiAgICB9O1xuICB9LFxuICBnZXREZWZhdWx0T3B0aW9uczogdGFibGUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBvblNvcnRpbmdDaGFuZ2U6IG1ha2VTdGF0ZVVwZGF0ZXIoJ3NvcnRpbmcnLCB0YWJsZSksXG4gICAgICBpc011bHRpU29ydEV2ZW50OiBlID0+IHtcbiAgICAgICAgcmV0dXJuIGUuc2hpZnRLZXk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgY3JlYXRlQ29sdW1uOiAoY29sdW1uLCB0YWJsZSkgPT4ge1xuICAgIGNvbHVtbi5nZXRBdXRvU29ydGluZ0ZuID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3dzID0gdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpLmZsYXRSb3dzLnNsaWNlKDEwKTtcbiAgICAgIGxldCBpc1N0cmluZyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgZmlyc3RSb3dzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcm93ID09IG51bGwgPyB2b2lkIDAgOiByb3cuZ2V0VmFsdWUoY29sdW1uLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgIHJldHVybiBzb3J0aW5nRm5zLmRhdGV0aW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXNTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgIGlmICh2YWx1ZS5zcGxpdChyZVNwbGl0QWxwaGFOdW1lcmljKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydGluZ0Zucy5hbHBoYW51bWVyaWM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRpbmdGbnMudGV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0aW5nRm5zLmJhc2ljO1xuICAgIH07XG4gICAgY29sdW1uLmdldEF1dG9Tb3J0RGlyID0gKCkgPT4ge1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZS5nZXRGaWx0ZXJlZFJvd01vZGVsKCkuZmxhdFJvd3NbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGZpcnN0Um93ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdFJvdy5nZXRWYWx1ZShjb2x1bW4uaWQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICdhc2MnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0aW5nRm4gPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkc29ydGluLCBfdGFibGUkb3B0aW9ucyRzb3J0aW4yO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbikgPyBjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbiA6IGNvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuID09PSAnYXV0bycgPyBjb2x1bW4uZ2V0QXV0b1NvcnRpbmdGbigpIDogKF90YWJsZSRvcHRpb25zJHNvcnRpbiA9IChfdGFibGUkb3B0aW9ucyRzb3J0aW4yID0gdGFibGUub3B0aW9ucy5zb3J0aW5nRm5zKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJG9wdGlvbnMkc29ydGluMltjb2x1bW4uY29sdW1uRGVmLnNvcnRpbmdGbl0pICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRzb3J0aW4gOiBzb3J0aW5nRm5zW2NvbHVtbi5jb2x1bW5EZWYuc29ydGluZ0ZuXTtcbiAgICB9O1xuICAgIGNvbHVtbi50b2dnbGVTb3J0aW5nID0gKGRlc2MsIG11bHRpKSA9PiB7XG4gICAgICAvLyBpZiAoY29sdW1uLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAvLyAgIGNvbHVtbi5jb2x1bW5zLmZvckVhY2goKGMsIGkpID0+IHtcbiAgICAgIC8vICAgICBpZiAoYy5pZCkge1xuICAgICAgLy8gICAgICAgdGFibGUudG9nZ2xlQ29sdW1uU29ydGluZyhjLmlkLCB1bmRlZmluZWQsIG11bHRpIHx8ICEhaSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH0pXG4gICAgICAvLyAgIHJldHVyblxuICAgICAgLy8gfVxuXG4gICAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIG91dHNpZGUgb2YgdGFibGUuc2V0U29ydGluZyB0byBiZSBpbiBzeW5jIHdpdGggcmVyZW5kZXJcbiAgICAgIGNvbnN0IG5leHRTb3J0aW5nT3JkZXIgPSBjb2x1bW4uZ2V0TmV4dFNvcnRpbmdPcmRlcigpO1xuICAgICAgY29uc3QgaGFzTWFudWFsVmFsdWUgPSB0eXBlb2YgZGVzYyAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVzYyAhPT0gbnVsbDtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcob2xkID0+IHtcbiAgICAgICAgLy8gRmluZCBhbnkgZXhpc3Rpbmcgc29ydGluZyBmb3IgdGhpcyBjb2x1bW5cbiAgICAgICAgY29uc3QgZXhpc3RpbmdTb3J0aW5nID0gb2xkID09IG51bGwgPyB2b2lkIDAgOiBvbGQuZmluZChkID0+IGQuaWQgPT09IGNvbHVtbi5pZCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5kZXggPSBvbGQgPT0gbnVsbCA/IHZvaWQgMCA6IG9sZC5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgICBsZXQgbmV3U29ydGluZyA9IFtdO1xuXG4gICAgICAgIC8vIFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggdGhpcyBzb3J0IGFjdGlvbj9cbiAgICAgICAgbGV0IHNvcnRBY3Rpb247XG4gICAgICAgIGxldCBuZXh0RGVzYyA9IGhhc01hbnVhbFZhbHVlID8gZGVzYyA6IG5leHRTb3J0aW5nT3JkZXIgPT09ICdkZXNjJztcblxuICAgICAgICAvLyBNdWx0aS1tb2RlXG4gICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSAmJiBtdWx0aSkge1xuICAgICAgICAgIGlmIChleGlzdGluZ1NvcnRpbmcpIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAndG9nZ2xlJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc29ydEFjdGlvbiA9ICdhZGQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3JtYWwgbW9kZVxuICAgICAgICAgIGlmIChvbGQgIT0gbnVsbCAmJiBvbGQubGVuZ3RoICYmIGV4aXN0aW5nSW5kZXggIT09IG9sZC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdTb3J0aW5nKSB7XG4gICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3RvZ2dsZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvcnRBY3Rpb24gPSAncmVwbGFjZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRvZ2dsZSBzdGF0ZXMgdGhhdCB3aWxsIHJlbW92ZSB0aGUgc29ydGluZ1xuICAgICAgICBpZiAoc29ydEFjdGlvbiA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBhcmUgXCJhY3R1YWxseVwiIHRvZ2dsaW5nIChub3QgYSBtYW51YWwgc2V0IHZhbHVlKSwgc2hvdWxkIHdlIHJlbW92ZSB0aGUgc29ydGluZz9cbiAgICAgICAgICBpZiAoIWhhc01hbnVhbFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBJcyBvdXIgaW50ZW50aW9uIHRvIHJlbW92ZT9cbiAgICAgICAgICAgIGlmICghbmV4dFNvcnRpbmdPcmRlcikge1xuICAgICAgICAgICAgICBzb3J0QWN0aW9uID0gJ3JlbW92ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0QWN0aW9uID09PSAnYWRkJykge1xuICAgICAgICAgIHZhciBfdGFibGUkb3B0aW9ucyRtYXhNdWw7XG4gICAgICAgICAgbmV3U29ydGluZyA9IFsuLi5vbGQsIHtcbiAgICAgICAgICAgIGlkOiBjb2x1bW4uaWQsXG4gICAgICAgICAgICBkZXNjOiBuZXh0RGVzY1xuICAgICAgICAgIH1dO1xuICAgICAgICAgIC8vIFRha2UgbGF0ZXN0IG4gY29sdW1uc1xuICAgICAgICAgIG5ld1NvcnRpbmcuc3BsaWNlKDAsIG5ld1NvcnRpbmcubGVuZ3RoIC0gKChfdGFibGUkb3B0aW9ucyRtYXhNdWwgPSB0YWJsZS5vcHRpb25zLm1heE11bHRpU29ydENvbENvdW50KSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TXVsIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3J0QWN0aW9uID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIC8vIFRoaXMgZmxpcHMgKG9yIHNldHMpIHRoZVxuICAgICAgICAgIG5ld1NvcnRpbmcgPSBvbGQubWFwKGQgPT4ge1xuICAgICAgICAgICAgaWYgKGQuaWQgPT09IGNvbHVtbi5pZCkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmQsXG4gICAgICAgICAgICAgICAgZGVzYzogbmV4dERlc2NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHNvcnRBY3Rpb24gPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgbmV3U29ydGluZyA9IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1NvcnRpbmcgPSBbe1xuICAgICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICAgIGRlc2M6IG5leHREZXNjXG4gICAgICAgICAgfV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NvcnRpbmc7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRGaXJzdFNvcnREaXIgPSAoKSA9PiB7XG4gICAgICB2YXIgX3JlZiwgX2NvbHVtbiRjb2x1bW5EZWYkc29yO1xuICAgICAgY29uc3Qgc29ydERlc2NGaXJzdCA9IChfcmVmID0gKF9jb2x1bW4kY29sdW1uRGVmJHNvciA9IGNvbHVtbi5jb2x1bW5EZWYuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJHNvciA6IHRhYmxlLm9wdGlvbnMuc29ydERlc2NGaXJzdCkgIT0gbnVsbCA/IF9yZWYgOiBjb2x1bW4uZ2V0QXV0b1NvcnREaXIoKSA9PT0gJ2Rlc2MnO1xuICAgICAgcmV0dXJuIHNvcnREZXNjRmlyc3QgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXROZXh0U29ydGluZ09yZGVyID0gbXVsdGkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRvcHRpb25zJGVuYWJsZSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMjtcbiAgICAgIGNvbnN0IGZpcnN0U29ydERpcmVjdGlvbiA9IGNvbHVtbi5nZXRGaXJzdFNvcnREaXIoKTtcbiAgICAgIGNvbnN0IGlzU29ydGVkID0gY29sdW1uLmdldElzU29ydGVkKCk7XG4gICAgICBpZiAoIWlzU29ydGVkKSB7XG4gICAgICAgIHJldHVybiBmaXJzdFNvcnREaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpZiAoaXNTb3J0ZWQgIT09IGZpcnN0U29ydERpcmVjdGlvbiAmJiAoKF90YWJsZSRvcHRpb25zJGVuYWJsZSA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZ1JlbW92YWwpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUgOiB0cnVlKSAmJiAoXG4gICAgICAvLyBJZiBlbmFibGVTb3J0UmVtb3ZlLCBlbmFibGUgaW4gZ2VuZXJhbFxuICAgICAgbXVsdGkgPyAoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMiA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlSZW1vdmUpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRlbmFibGUyIDogdHJ1ZSA6IHRydWUpIC8vIElmIG11bHRpLCBkb24ndCBhbGxvdyBpZiBlbmFibGVNdWx0aVJlbW92ZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU29ydGVkID09PSAnZGVzYycgPyAnYXNjJyA6ICdkZXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRDYW5Tb3J0ID0gKCkgPT4ge1xuICAgICAgdmFyIF9jb2x1bW4kY29sdW1uRGVmJGVuYSwgX3RhYmxlJG9wdGlvbnMkZW5hYmxlMztcbiAgICAgIHJldHVybiAoKF9jb2x1bW4kY29sdW1uRGVmJGVuYSA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF9jb2x1bW4kY29sdW1uRGVmJGVuYSA6IHRydWUpICYmICgoX3RhYmxlJG9wdGlvbnMkZW5hYmxlMyA9IHRhYmxlLm9wdGlvbnMuZW5hYmxlU29ydGluZykgIT0gbnVsbCA/IF90YWJsZSRvcHRpb25zJGVuYWJsZTMgOiB0cnVlKSAmJiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldENhbk11bHRpU29ydCA9ICgpID0+IHtcbiAgICAgIHZhciBfcmVmMiwgX2NvbHVtbiRjb2x1bW5EZWYkZW5hMjtcbiAgICAgIHJldHVybiAoX3JlZjIgPSAoX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA9IGNvbHVtbi5jb2x1bW5EZWYuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX2NvbHVtbiRjb2x1bW5EZWYkZW5hMiA6IHRhYmxlLm9wdGlvbnMuZW5hYmxlTXVsdGlTb3J0KSAhPSBudWxsID8gX3JlZjIgOiAhIWNvbHVtbi5hY2Nlc3NvckZuO1xuICAgIH07XG4gICAgY29sdW1uLmdldElzU29ydGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRTdGF0ZSRzb3J0aTtcbiAgICAgIGNvbnN0IGNvbHVtblNvcnQgPSAoX3RhYmxlJGdldFN0YXRlJHNvcnRpID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpLmZpbmQoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpO1xuICAgICAgcmV0dXJuICFjb2x1bW5Tb3J0ID8gZmFsc2UgOiBjb2x1bW5Tb3J0LmRlc2MgPyAnZGVzYycgOiAnYXNjJztcbiAgICB9O1xuICAgIGNvbHVtbi5nZXRTb3J0SW5kZXggPSAoKSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJGdldFN0YXRlJHNvcnRpMiwgX3RhYmxlJGdldFN0YXRlJHNvcnRpMztcbiAgICAgIHJldHVybiAoX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA9IChfdGFibGUkZ2V0U3RhdGUkc29ydGkzID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nKSA9PSBudWxsID8gdm9pZCAwIDogX3RhYmxlJGdldFN0YXRlJHNvcnRpMy5maW5kSW5kZXgoZCA9PiBkLmlkID09PSBjb2x1bW4uaWQpKSAhPSBudWxsID8gX3RhYmxlJGdldFN0YXRlJHNvcnRpMiA6IC0xO1xuICAgIH07XG4gICAgY29sdW1uLmNsZWFyU29ydGluZyA9ICgpID0+IHtcbiAgICAgIC8vY2xlYXIgc29ydGluZyBmb3IganVzdCAxIGNvbHVtblxuICAgICAgdGFibGUuc2V0U29ydGluZyhvbGQgPT4gb2xkICE9IG51bGwgJiYgb2xkLmxlbmd0aCA/IG9sZC5maWx0ZXIoZCA9PiBkLmlkICE9PSBjb2x1bW4uaWQpIDogW10pO1xuICAgIH07XG4gICAgY29sdW1uLmdldFRvZ2dsZVNvcnRpbmdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FuU29ydCA9IGNvbHVtbi5nZXRDYW5Tb3J0KCk7XG4gICAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGlmICghY2FuU29ydCkgcmV0dXJuO1xuICAgICAgICBlLnBlcnNpc3QgPT0gbnVsbCB8fCBlLnBlcnNpc3QoKTtcbiAgICAgICAgY29sdW1uLnRvZ2dsZVNvcnRpbmcgPT0gbnVsbCB8fCBjb2x1bW4udG9nZ2xlU29ydGluZyh1bmRlZmluZWQsIGNvbHVtbi5nZXRDYW5NdWx0aVNvcnQoKSA/IHRhYmxlLm9wdGlvbnMuaXNNdWx0aVNvcnRFdmVudCA9PSBudWxsID8gdm9pZCAwIDogdGFibGUub3B0aW9ucy5pc011bHRpU29ydEV2ZW50KGUpIDogZmFsc2UpO1xuICAgICAgfTtcbiAgICB9O1xuICB9LFxuICBjcmVhdGVUYWJsZTogdGFibGUgPT4ge1xuICAgIHRhYmxlLnNldFNvcnRpbmcgPSB1cGRhdGVyID0+IHRhYmxlLm9wdGlvbnMub25Tb3J0aW5nQ2hhbmdlID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLm9uU29ydGluZ0NoYW5nZSh1cGRhdGVyKTtcbiAgICB0YWJsZS5yZXNldFNvcnRpbmcgPSBkZWZhdWx0U3RhdGUgPT4ge1xuICAgICAgdmFyIF90YWJsZSRpbml0aWFsU3RhdGUkcywgX3RhYmxlJGluaXRpYWxTdGF0ZTtcbiAgICAgIHRhYmxlLnNldFNvcnRpbmcoZGVmYXVsdFN0YXRlID8gW10gOiAoX3RhYmxlJGluaXRpYWxTdGF0ZSRzID0gKF90YWJsZSRpbml0aWFsU3RhdGUgPSB0YWJsZS5pbml0aWFsU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkaW5pdGlhbFN0YXRlLnNvcnRpbmcpICE9IG51bGwgPyBfdGFibGUkaW5pdGlhbFN0YXRlJHMgOiBbXSk7XG4gICAgfTtcbiAgICB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCA9ICgpID0+IHRhYmxlLmdldEdyb3VwZWRSb3dNb2RlbCgpO1xuICAgIHRhYmxlLmdldFNvcnRlZFJvd01vZGVsID0gKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgJiYgdGFibGUub3B0aW9ucy5nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldFNvcnRlZFJvd01vZGVsKHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWJsZS5vcHRpb25zLm1hbnVhbFNvcnRpbmcgfHwgIXRhYmxlLl9nZXRTb3J0ZWRSb3dNb2RlbCkge1xuICAgICAgICByZXR1cm4gdGFibGUuZ2V0UHJlU29ydGVkUm93TW9kZWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWJsZS5fZ2V0U29ydGVkUm93TW9kZWwoKTtcbiAgICB9O1xuICB9XG59O1xuXG5jb25zdCBidWlsdEluRmVhdHVyZXMgPSBbSGVhZGVycywgQ29sdW1uVmlzaWJpbGl0eSwgQ29sdW1uT3JkZXJpbmcsIENvbHVtblBpbm5pbmcsIENvbHVtbkZhY2V0aW5nLCBDb2x1bW5GaWx0ZXJpbmcsIEdsb2JhbEZhY2V0aW5nLFxuLy9kZXBlbmRzIG9uIENvbHVtbkZhY2V0aW5nXG5HbG9iYWxGaWx0ZXJpbmcsXG4vL2RlcGVuZHMgb24gQ29sdW1uRmlsdGVyaW5nXG5Sb3dTb3J0aW5nLCBDb2x1bW5Hcm91cGluZyxcbi8vZGVwZW5kcyBvbiBSb3dTb3J0aW5nXG5Sb3dFeHBhbmRpbmcsIFJvd1BhZ2luYXRpb24sIFJvd1Bpbm5pbmcsIFJvd1NlbGVjdGlvbiwgQ29sdW1uU2l6aW5nXTtcblxuLy9cblxuZnVuY3Rpb24gY3JlYXRlVGFibGUob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkX2ZlYXR1cmVzLCBfb3B0aW9ucyRpbml0aWFsU3RhdGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChvcHRpb25zLmRlYnVnQWxsIHx8IG9wdGlvbnMuZGVidWdUYWJsZSkpIHtcbiAgICBjb25zb2xlLmluZm8oJ0NyZWF0aW5nIFRhYmxlIEluc3RhbmNlLi4uJyk7XG4gIH1cbiAgY29uc3QgX2ZlYXR1cmVzID0gWy4uLmJ1aWx0SW5GZWF0dXJlcywgLi4uKChfb3B0aW9ucyRfZmVhdHVyZXMgPSBvcHRpb25zLl9mZWF0dXJlcykgIT0gbnVsbCA/IF9vcHRpb25zJF9mZWF0dXJlcyA6IFtdKV07XG4gIGxldCB0YWJsZSA9IHtcbiAgICBfZmVhdHVyZXNcbiAgfTtcbiAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB0YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGZlYXR1cmUuZ2V0RGVmYXVsdE9wdGlvbnModGFibGUpKTtcbiAgfSwge30pO1xuICBjb25zdCBtZXJnZU9wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgICBpZiAodGFibGUub3B0aW9ucy5tZXJnZU9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLm1lcmdlT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9O1xuICBjb25zdCBjb3JlSW5pdGlhbFN0YXRlID0ge307XG4gIGxldCBpbml0aWFsU3RhdGUgPSB7XG4gICAgLi4uY29yZUluaXRpYWxTdGF0ZSxcbiAgICAuLi4oKF9vcHRpb25zJGluaXRpYWxTdGF0ZSA9IG9wdGlvbnMuaW5pdGlhbFN0YXRlKSAhPSBudWxsID8gX29wdGlvbnMkaW5pdGlhbFN0YXRlIDoge30pXG4gIH07XG4gIHRhYmxlLl9mZWF0dXJlcy5mb3JFYWNoKGZlYXR1cmUgPT4ge1xuICAgIHZhciBfZmVhdHVyZSRnZXRJbml0aWFsU3Q7XG4gICAgaW5pdGlhbFN0YXRlID0gKF9mZWF0dXJlJGdldEluaXRpYWxTdCA9IGZlYXR1cmUuZ2V0SW5pdGlhbFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBmZWF0dXJlLmdldEluaXRpYWxTdGF0ZShpbml0aWFsU3RhdGUpKSAhPSBudWxsID8gX2ZlYXR1cmUkZ2V0SW5pdGlhbFN0IDogaW5pdGlhbFN0YXRlO1xuICB9KTtcbiAgY29uc3QgcXVldWVkID0gW107XG4gIGxldCBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gIGNvbnN0IGNvcmVJbnN0YW5jZSA9IHtcbiAgICBfZmVhdHVyZXMsXG4gICAgb3B0aW9uczoge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSxcbiAgICBpbml0aWFsU3RhdGUsXG4gICAgX3F1ZXVlOiBjYiA9PiB7XG4gICAgICBxdWV1ZWQucHVzaChjYik7XG4gICAgICBpZiAoIXF1ZXVlZFRpbWVvdXQpIHtcbiAgICAgICAgcXVldWVkVGltZW91dCA9IHRydWU7XG5cbiAgICAgICAgLy8gU2NoZWR1bGUgYSBtaWNyb3Rhc2sgdG8gcnVuIHRoZSBxdWV1ZWQgY2FsbGJhY2tzIGFmdGVyXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgKHJlbmRlciwgZXRjKSBoYXMgZmluaXNoZWQuXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHdoaWxlIChxdWV1ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBxdWV1ZWQuc2hpZnQoKSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxdWV1ZWRUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4ge1xuICAgICAgdGFibGUuc2V0U3RhdGUodGFibGUuaW5pdGlhbFN0YXRlKTtcbiAgICB9LFxuICAgIHNldE9wdGlvbnM6IHVwZGF0ZXIgPT4ge1xuICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IGZ1bmN0aW9uYWxVcGRhdGUodXBkYXRlciwgdGFibGUub3B0aW9ucyk7XG4gICAgICB0YWJsZS5vcHRpb25zID0gbWVyZ2VPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2V0U3RhdGU6ICgpID0+IHtcbiAgICAgIHJldHVybiB0YWJsZS5vcHRpb25zLnN0YXRlO1xuICAgIH0sXG4gICAgc2V0U3RhdGU6IHVwZGF0ZXIgPT4ge1xuICAgICAgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlID09IG51bGwgfHwgdGFibGUub3B0aW9ucy5vblN0YXRlQ2hhbmdlKHVwZGF0ZXIpO1xuICAgIH0sXG4gICAgX2dldFJvd0lkOiAocm93LCBpbmRleCwgcGFyZW50KSA9PiB7XG4gICAgICB2YXIgX3RhYmxlJG9wdGlvbnMkZ2V0Um93O1xuICAgICAgcmV0dXJuIChfdGFibGUkb3B0aW9ucyRnZXRSb3cgPSB0YWJsZS5vcHRpb25zLmdldFJvd0lkID09IG51bGwgPyB2b2lkIDAgOiB0YWJsZS5vcHRpb25zLmdldFJvd0lkKHJvdywgaW5kZXgsIHBhcmVudCkpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRnZXRSb3cgOiBgJHtwYXJlbnQgPyBbcGFyZW50LmlkLCBpbmRleF0uam9pbignLicpIDogaW5kZXh9YDtcbiAgICB9LFxuICAgIGdldENvcmVSb3dNb2RlbDogKCkgPT4ge1xuICAgICAgaWYgKCF0YWJsZS5fZ2V0Q29yZVJvd01vZGVsKSB7XG4gICAgICAgIHRhYmxlLl9nZXRDb3JlUm93TW9kZWwgPSB0YWJsZS5vcHRpb25zLmdldENvcmVSb3dNb2RlbCh0YWJsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFibGUuX2dldENvcmVSb3dNb2RlbCgpO1xuICAgIH0sXG4gICAgLy8gVGhlIGZpbmFsIGNhbGxzIHN0YXJ0IGF0IHRoZSBib3R0b20gb2YgdGhlIG1vZGVsLFxuICAgIC8vIGV4cGFuZGVkIHJvd3MsIHdoaWNoIHRoZW4gd29yayB0aGVpciB3YXkgdXBcblxuICAgIGdldFJvd01vZGVsOiAoKSA9PiB7XG4gICAgICByZXR1cm4gdGFibGUuZ2V0UGFnaW5hdGlvblJvd01vZGVsKCk7XG4gICAgfSxcbiAgICAvL2luIG5leHQgdmVyc2lvbiwgd2Ugc2hvdWxkIGp1c3QgcGFzcyBpbiB0aGUgcm93IG1vZGVsIGFzIHRoZSBvcHRpb25hbCAybmQgYXJnXG4gICAgZ2V0Um93OiAoaWQsIHNlYXJjaEFsbCkgPT4ge1xuICAgICAgbGV0IHJvdyA9IChzZWFyY2hBbGwgPyB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSA6IHRhYmxlLmdldFJvd01vZGVsKCkpLnJvd3NCeUlkW2lkXTtcbiAgICAgIGlmICghcm93KSB7XG4gICAgICAgIHJvdyA9IHRhYmxlLmdldENvcmVSb3dNb2RlbCgpLnJvd3NCeUlkW2lkXTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3cgY291bGQgbm90IGZpbmQgcm93IHdpdGggSUQ6ICR7aWR9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93O1xuICAgIH0sXG4gICAgX2dldERlZmF1bHRDb2x1bW5EZWY6IG1lbW8oKCkgPT4gW3RhYmxlLm9wdGlvbnMuZGVmYXVsdENvbHVtbl0sIGRlZmF1bHRDb2x1bW4gPT4ge1xuICAgICAgdmFyIF9kZWZhdWx0Q29sdW1uO1xuICAgICAgZGVmYXVsdENvbHVtbiA9IChfZGVmYXVsdENvbHVtbiA9IGRlZmF1bHRDb2x1bW4pICE9IG51bGwgPyBfZGVmYXVsdENvbHVtbiA6IHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiBwcm9wcyA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRDb2x1bW5EZWYgPSBwcm9wcy5oZWFkZXIuY29sdW1uLmNvbHVtbkRlZjtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRDb2x1bW5EZWYuYWNjZXNzb3JLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5hY2Nlc3NvcktleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc29sdmVkQ29sdW1uRGVmLmFjY2Vzc29yRm4pIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZENvbHVtbkRlZi5pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZvb3RlcjogcHJvcHMgPT4gcHJvcHMuaGVhZGVyLmNvbHVtbi5pZCxcbiAgICAgICAgY2VsbDogcHJvcHMgPT4ge1xuICAgICAgICAgIHZhciBfcHJvcHMkcmVuZGVyVmFsdWUkdG8sIF9wcm9wcyRyZW5kZXJWYWx1ZTtcbiAgICAgICAgICByZXR1cm4gKF9wcm9wcyRyZW5kZXJWYWx1ZSR0byA9IChfcHJvcHMkcmVuZGVyVmFsdWUgPSBwcm9wcy5yZW5kZXJWYWx1ZSgpKSA9PSBudWxsIHx8IF9wcm9wcyRyZW5kZXJWYWx1ZS50b1N0cmluZyA9PSBudWxsID8gdm9pZCAwIDogX3Byb3BzJHJlbmRlclZhbHVlLnRvU3RyaW5nKCkpICE9IG51bGwgPyBfcHJvcHMkcmVuZGVyVmFsdWUkdG8gOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAuLi50YWJsZS5fZmVhdHVyZXMucmVkdWNlKChvYmosIGZlYXR1cmUpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvYmosIGZlYXR1cmUuZ2V0RGVmYXVsdENvbHVtbkRlZiA9PSBudWxsID8gdm9pZCAwIDogZmVhdHVyZS5nZXREZWZhdWx0Q29sdW1uRGVmKCkpO1xuICAgICAgICB9LCB7fSksXG4gICAgICAgIC4uLmRlZmF1bHRDb2x1bW5cbiAgICAgIH07XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdfZ2V0RGVmYXVsdENvbHVtbkRlZicpKSxcbiAgICBfZ2V0Q29sdW1uRGVmczogKCkgPT4gdGFibGUub3B0aW9ucy5jb2x1bW5zLFxuICAgIGdldEFsbENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLl9nZXRDb2x1bW5EZWZzKCldLCBjb2x1bW5EZWZzID0+IHtcbiAgICAgIGNvbnN0IHJlY3Vyc2VDb2x1bW5zID0gZnVuY3Rpb24gKGNvbHVtbkRlZnMsIHBhcmVudCwgZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkZXB0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbkRlZnMubWFwKGNvbHVtbkRlZiA9PiB7XG4gICAgICAgICAgY29uc3QgY29sdW1uID0gY3JlYXRlQ29sdW1uKHRhYmxlLCBjb2x1bW5EZWYsIGRlcHRoLCBwYXJlbnQpO1xuICAgICAgICAgIGNvbnN0IGdyb3VwaW5nQ29sdW1uRGVmID0gY29sdW1uRGVmO1xuICAgICAgICAgIGNvbHVtbi5jb2x1bW5zID0gZ3JvdXBpbmdDb2x1bW5EZWYuY29sdW1ucyA/IHJlY3Vyc2VDb2x1bW5zKGdyb3VwaW5nQ29sdW1uRGVmLmNvbHVtbnMsIGNvbHVtbiwgZGVwdGggKyAxKSA6IFtdO1xuICAgICAgICAgIHJldHVybiBjb2x1bW47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZWN1cnNlQ29sdW1ucyhjb2x1bW5EZWZzKTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbENvbHVtbnMnKSksXG4gICAgZ2V0QWxsRmxhdENvbHVtbnM6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbENvbHVtbnMoKV0sIGFsbENvbHVtbnMgPT4ge1xuICAgICAgcmV0dXJuIGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4ge1xuICAgICAgICByZXR1cm4gY29sdW1uLmdldEZsYXRDb2x1bW5zKCk7XG4gICAgICB9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbEZsYXRDb2x1bW5zJykpLFxuICAgIF9nZXRBbGxGbGF0Q29sdW1uc0J5SWQ6IG1lbW8oKCkgPT4gW3RhYmxlLmdldEFsbEZsYXRDb2x1bW5zKCldLCBmbGF0Q29sdW1ucyA9PiB7XG4gICAgICByZXR1cm4gZmxhdENvbHVtbnMucmVkdWNlKChhY2MsIGNvbHVtbikgPT4ge1xuICAgICAgICBhY2NbY29sdW1uLmlkXSA9IGNvbHVtbjtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9LCBnZXRNZW1vT3B0aW9ucyhvcHRpb25zLCAnZGVidWdDb2x1bW5zJywgJ2dldEFsbEZsYXRDb2x1bW5zQnlJZCcpKSxcbiAgICBnZXRBbGxMZWFmQ29sdW1uczogbWVtbygoKSA9PiBbdGFibGUuZ2V0QWxsQ29sdW1ucygpLCB0YWJsZS5fZ2V0T3JkZXJDb2x1bW5zRm4oKV0sIChhbGxDb2x1bW5zLCBvcmRlckNvbHVtbnMpID0+IHtcbiAgICAgIGxldCBsZWFmQ29sdW1ucyA9IGFsbENvbHVtbnMuZmxhdE1hcChjb2x1bW4gPT4gY29sdW1uLmdldExlYWZDb2x1bW5zKCkpO1xuICAgICAgcmV0dXJuIG9yZGVyQ29sdW1ucyhsZWFmQ29sdW1ucyk7XG4gICAgfSwgZ2V0TWVtb09wdGlvbnMob3B0aW9ucywgJ2RlYnVnQ29sdW1ucycsICdnZXRBbGxMZWFmQ29sdW1ucycpKSxcbiAgICBnZXRDb2x1bW46IGNvbHVtbklkID0+IHtcbiAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLl9nZXRBbGxGbGF0Q29sdW1uc0J5SWQoKVtjb2x1bW5JZF07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29sdW1uKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtUYWJsZV0gQ29sdW1uIHdpdGggaWQgJyR7Y29sdW1uSWR9JyBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2x1bW47XG4gICAgfVxuICB9O1xuICBPYmplY3QuYXNzaWduKHRhYmxlLCBjb3JlSW5zdGFuY2UpO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGFibGUuX2ZlYXR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGZlYXR1cmUgPSB0YWJsZS5fZmVhdHVyZXNbaW5kZXhdO1xuICAgIGZlYXR1cmUgPT0gbnVsbCB8fCBmZWF0dXJlLmNyZWF0ZVRhYmxlID09IG51bGwgfHwgZmVhdHVyZS5jcmVhdGVUYWJsZSh0YWJsZSk7XG4gIH1cbiAgcmV0dXJuIHRhYmxlO1xufVxuXG5mdW5jdGlvbiBnZXRDb3JlUm93TW9kZWwoKSB7XG4gIHJldHVybiB0YWJsZSA9PiBtZW1vKCgpID0+IFt0YWJsZS5vcHRpb25zLmRhdGFdLCBkYXRhID0+IHtcbiAgICBjb25zdCByb3dNb2RlbCA9IHtcbiAgICAgIHJvd3M6IFtdLFxuICAgICAgZmxhdFJvd3M6IFtdLFxuICAgICAgcm93c0J5SWQ6IHt9XG4gICAgfTtcbiAgICBjb25zdCBhY2Nlc3NSb3dzID0gZnVuY3Rpb24gKG9yaWdpbmFsUm93cywgZGVwdGgsIHBhcmVudFJvdykge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmlnaW5hbFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBhbiBleHBlbnNpdmUgY2hlY2sgYXQgc2NhbGUsIHNvIHdlIHNob3VsZCBtb3ZlIGl0IHNvbWV3aGVyZSBlbHNlLCBidXQgd2hlcmU/XG4gICAgICAgIC8vIGlmICghaWQpIHtcbiAgICAgICAgLy8gICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRSb3dJZCBleHBlY3RlZCBhbiBJRCwgYnV0IGdvdCAke2lkfWApXG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgcm93XG4gICAgICAgIGNvbnN0IHJvdyA9IGNyZWF0ZVJvdyh0YWJsZSwgdGFibGUuX2dldFJvd0lkKG9yaWdpbmFsUm93c1tpXSwgaSwgcGFyZW50Um93KSwgb3JpZ2luYWxSb3dzW2ldLCBpLCBkZXB0aCwgdW5kZWZpbmVkLCBwYXJlbnRSb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmVudFJvdy5pZCk7XG5cbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBldmVyeSByb3cgaW4gYSBmbGF0IGFycmF5XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgLy8gQWxzbyBrZWVwIHRyYWNrIG9mIGV2ZXJ5IHJvdyBieSBpdHMgSURcbiAgICAgICAgcm93TW9kZWwucm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgLy8gUHVzaCB0YWJsZSByb3cgaW50byBwYXJlbnRcbiAgICAgICAgcm93cy5wdXNoKHJvdyk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBvcmlnaW5hbCBzdWJyb3dzXG4gICAgICAgIGlmICh0YWJsZS5vcHRpb25zLmdldFN1YlJvd3MpIHtcbiAgICAgICAgICB2YXIgX3JvdyRvcmlnaW5hbFN1YlJvd3M7XG4gICAgICAgICAgcm93Lm9yaWdpbmFsU3ViUm93cyA9IHRhYmxlLm9wdGlvbnMuZ2V0U3ViUm93cyhvcmlnaW5hbFJvd3NbaV0sIGkpO1xuXG4gICAgICAgICAgLy8gVGhlbiByZWN1cnNpdmVseSBhY2Nlc3MgdGhlbVxuICAgICAgICAgIGlmICgoX3JvdyRvcmlnaW5hbFN1YlJvd3MgPSByb3cub3JpZ2luYWxTdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckb3JpZ2luYWxTdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBhY2Nlc3NSb3dzKHJvdy5vcmlnaW5hbFN1YlJvd3MsIGRlcHRoICsgMSwgcm93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgcm93TW9kZWwucm93cyA9IGFjY2Vzc1Jvd3MoZGF0YSk7XG4gICAgcmV0dXJuIHJvd01vZGVsO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRSb3dNb2RlbCcsICgpID0+IHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRFeHBhbmRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5leHBhbmRlZCwgdGFibGUuZ2V0UHJlRXhwYW5kZWRSb3dNb2RlbCgpLCB0YWJsZS5vcHRpb25zLnBhZ2luYXRlRXhwYW5kZWRSb3dzXSwgKGV4cGFuZGVkLCByb3dNb2RlbCwgcGFnaW5hdGVFeHBhbmRlZFJvd3MpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoIHx8IGV4cGFuZGVkICE9PSB0cnVlICYmICFPYmplY3Qua2V5cyhleHBhbmRlZCAhPSBudWxsID8gZXhwYW5kZWQgOiB7fSkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGlmICghcGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIC8vIE9ubHkgZXhwYW5kIHJvd3MgYXQgdGhpcyBwb2ludCBpZiB0aGV5IGFyZSBiZWluZyBwYWdpbmF0ZWRcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgcmV0dXJuIGV4cGFuZFJvd3Mocm93TW9kZWwpO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRFeHBhbmRlZFJvd01vZGVsJykpO1xufVxuZnVuY3Rpb24gZXhwYW5kUm93cyhyb3dNb2RlbCkge1xuICBjb25zdCBleHBhbmRlZFJvd3MgPSBbXTtcbiAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICB2YXIgX3JvdyRzdWJSb3dzO1xuICAgIGV4cGFuZGVkUm93cy5wdXNoKHJvdyk7XG4gICAgaWYgKChfcm93JHN1YlJvd3MgPSByb3cuc3ViUm93cykgIT0gbnVsbCAmJiBfcm93JHN1YlJvd3MubGVuZ3RoICYmIHJvdy5nZXRJc0V4cGFuZGVkKCkpIHtcbiAgICAgIHJvdy5zdWJSb3dzLmZvckVhY2goaGFuZGxlUm93KTtcbiAgICB9XG4gIH07XG4gIHJvd01vZGVsLnJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICByZXR1cm4ge1xuICAgIHJvd3M6IGV4cGFuZGVkUm93cyxcbiAgICBmbGF0Um93czogcm93TW9kZWwuZmxhdFJvd3MsXG4gICAgcm93c0J5SWQ6IHJvd01vZGVsLnJvd3NCeUlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRNaW5NYXhWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IGZhY2V0ZWRSb3dNb2RlbC5mbGF0Um93cy5mbGF0TWFwKGZsYXRSb3cgPT4ge1xuICAgICAgdmFyIF9mbGF0Um93JGdldFVuaXF1ZVZhbDtcbiAgICAgIHJldHVybiAoX2ZsYXRSb3ckZ2V0VW5pcXVlVmFsID0gZmxhdFJvdy5nZXRVbmlxdWVWYWx1ZXMoY29sdW1uSWQpKSAhPSBudWxsID8gX2ZsYXRSb3ckZ2V0VW5pcXVlVmFsIDogW107XG4gICAgfSkubWFwKE51bWJlcikuZmlsdGVyKHZhbHVlID0+ICFOdW1iZXIuaXNOYU4odmFsdWUpKTtcbiAgICBpZiAoIXVuaXF1ZVZhbHVlcy5sZW5ndGgpIHJldHVybjtcbiAgICBsZXQgZmFjZXRlZE1pblZhbHVlID0gdW5pcXVlVmFsdWVzWzBdO1xuICAgIGxldCBmYWNldGVkTWF4VmFsdWUgPSB1bmlxdWVWYWx1ZXNbdW5pcXVlVmFsdWVzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdW5pcXVlVmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWUgPCBmYWNldGVkTWluVmFsdWUpIGZhY2V0ZWRNaW5WYWx1ZSA9IHZhbHVlO2Vsc2UgaWYgKHZhbHVlID4gZmFjZXRlZE1heFZhbHVlKSBmYWNldGVkTWF4VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIFtmYWNldGVkTWluVmFsdWUsIGZhY2V0ZWRNYXhWYWx1ZV07XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldEZhY2V0ZWRNaW5NYXhWYWx1ZXMnKSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclJvd3Mocm93cywgZmlsdGVyUm93SW1wbCwgdGFibGUpIHtcbiAgaWYgKHRhYmxlLm9wdGlvbnMuZmlsdGVyRnJvbUxlYWZSb3dzKSB7XG4gICAgcmV0dXJuIGZpbHRlclJvd01vZGVsRnJvbUxlYWZzKHJvd3MsIGZpbHRlclJvd0ltcGwsIHRhYmxlKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzLCBmaWx0ZXJSb3dJbXBsLCB0YWJsZSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJSb3dNb2RlbEZyb21MZWFmcyhyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTtcbiAgY29uc3QgbmV3RmlsdGVyZWRGbGF0Um93cyA9IFtdO1xuICBjb25zdCBuZXdGaWx0ZXJlZFJvd3NCeUlkID0ge307XG4gIGNvbnN0IG1heERlcHRoID0gKF90YWJsZSRvcHRpb25zJG1heExlYSA9IHRhYmxlLm9wdGlvbnMubWF4TGVhZlJvd0ZpbHRlckRlcHRoKSAhPSBudWxsID8gX3RhYmxlJG9wdGlvbnMkbWF4TGVhIDogMTAwO1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gRmlsdGVyIGZyb20gY2hpbGRyZW4gdXAgZmlyc3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0ZpbHRlci5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgIGxldCByb3cgPSByb3dzVG9GaWx0ZXJbaV07XG4gICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgbmV3Um93LmNvbHVtbkZpbHRlcnMgPSByb3cuY29sdW1uRmlsdGVycztcbiAgICAgIGlmICgoX3JvdyRzdWJSb3dzID0gcm93LnN1YlJvd3MpICE9IG51bGwgJiYgX3JvdyRzdWJSb3dzLmxlbmd0aCAmJiBkZXB0aCA8IG1heERlcHRoKSB7XG4gICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgIHJvdyA9IG5ld1JvdztcbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpICYmICFuZXdSb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpbHRlclJvdyhyb3cpIHx8IG5ld1Jvdy5zdWJSb3dzLmxlbmd0aCkge1xuICAgICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIG5ld0ZpbHRlcmVkUm93c0J5SWRbcm93LmlkXSA9IHJvdztcbiAgICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICBpZiAoZmlsdGVyUm93KHJvdykpIHtcbiAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICBuZXdGaWx0ZXJlZFJvd3NCeUlkW3Jvdy5pZF0gPSByb3c7XG4gICAgICAgICAgbmV3RmlsdGVyZWRGbGF0Um93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvd3M7XG4gIH07XG4gIHJldHVybiB7XG4gICAgcm93czogcmVjdXJzZUZpbHRlclJvd3Mocm93c1RvRmlsdGVyKSxcbiAgICBmbGF0Um93czogbmV3RmlsdGVyZWRGbGF0Um93cyxcbiAgICByb3dzQnlJZDogbmV3RmlsdGVyZWRSb3dzQnlJZFxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyUm93TW9kZWxGcm9tUm9vdChyb3dzVG9GaWx0ZXIsIGZpbHRlclJvdywgdGFibGUpIHtcbiAgdmFyIF90YWJsZSRvcHRpb25zJG1heExlYTI7XG4gIGNvbnN0IG5ld0ZpbHRlcmVkRmxhdFJvd3MgPSBbXTtcbiAgY29uc3QgbmV3RmlsdGVyZWRSb3dzQnlJZCA9IHt9O1xuICBjb25zdCBtYXhEZXB0aCA9IChfdGFibGUkb3B0aW9ucyRtYXhMZWEyID0gdGFibGUub3B0aW9ucy5tYXhMZWFmUm93RmlsdGVyRGVwdGgpICE9IG51bGwgPyBfdGFibGUkb3B0aW9ucyRtYXhMZWEyIDogMTAwO1xuXG4gIC8vIEZpbHRlcnMgdG9wIGxldmVsIGFuZCBuZXN0ZWQgcm93c1xuICBjb25zdCByZWN1cnNlRmlsdGVyUm93cyA9IGZ1bmN0aW9uIChyb3dzVG9GaWx0ZXIsIGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgIGRlcHRoID0gMDtcbiAgICB9XG4gICAgLy8gRmlsdGVyIGZyb20gcGFyZW50cyBkb3dud2FyZCBmaXJzdFxuXG4gICAgY29uc3Qgcm93cyA9IFtdO1xuXG4gICAgLy8gQXBwbHkgdGhlIGZpbHRlciB0byBhbnkgc3ViUm93c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93c1RvRmlsdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcm93ID0gcm93c1RvRmlsdGVyW2ldO1xuICAgICAgY29uc3QgcGFzcyA9IGZpbHRlclJvdyhyb3cpO1xuICAgICAgaWYgKHBhc3MpIHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93czI7XG4gICAgICAgIGlmICgoX3JvdyRzdWJSb3dzMiA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93czIubGVuZ3RoICYmIGRlcHRoIDwgbWF4RGVwdGgpIHtcbiAgICAgICAgICBjb25zdCBuZXdSb3cgPSBjcmVhdGVSb3codGFibGUsIHJvdy5pZCwgcm93Lm9yaWdpbmFsLCByb3cuaW5kZXgsIHJvdy5kZXB0aCwgdW5kZWZpbmVkLCByb3cucGFyZW50SWQpO1xuICAgICAgICAgIG5ld1Jvdy5zdWJSb3dzID0gcmVjdXJzZUZpbHRlclJvd3Mocm93LnN1YlJvd3MsIGRlcHRoICsgMSk7XG4gICAgICAgICAgcm93ID0gbmV3Um93O1xuICAgICAgICB9XG4gICAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgICAgICBuZXdGaWx0ZXJlZEZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgICAgbmV3RmlsdGVyZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm93cztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICByb3dzOiByZWN1cnNlRmlsdGVyUm93cyhyb3dzVG9GaWx0ZXIpLFxuICAgIGZsYXRSb3dzOiBuZXdGaWx0ZXJlZEZsYXRSb3dzLFxuICAgIHJvd3NCeUlkOiBuZXdGaWx0ZXJlZFJvd3NCeUlkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuICh0YWJsZSwgY29sdW1uSWQpID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlciwgdGFibGUuZ2V0RmlsdGVyZWRSb3dNb2RlbCgpXSwgKHByZVJvd01vZGVsLCBjb2x1bW5GaWx0ZXJzLCBnbG9iYWxGaWx0ZXIpID0+IHtcbiAgICBpZiAoIXByZVJvd01vZGVsLnJvd3MubGVuZ3RoIHx8ICEoY29sdW1uRmlsdGVycyAhPSBudWxsICYmIGNvbHVtbkZpbHRlcnMubGVuZ3RoKSAmJiAhZ2xvYmFsRmlsdGVyKSB7XG4gICAgICByZXR1cm4gcHJlUm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmFibGVJZHMgPSBbLi4uY29sdW1uRmlsdGVycy5tYXAoZCA9PiBkLmlkKS5maWx0ZXIoZCA9PiBkICE9PSBjb2x1bW5JZCksIGdsb2JhbEZpbHRlciA/ICdfX2dsb2JhbF9fJyA6IHVuZGVmaW5lZF0uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsdGVyUm93cyhwcmVSb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGYWNldGVkUm93TW9kZWwnKSk7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0ZWRVbmlxdWVWYWx1ZXMoKSB7XG4gIHJldHVybiAodGFibGUsIGNvbHVtbklkKSA9PiBtZW1vKCgpID0+IHtcbiAgICB2YXIgX3RhYmxlJGdldENvbHVtbjtcbiAgICByZXR1cm4gWyhfdGFibGUkZ2V0Q29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90YWJsZSRnZXRDb2x1bW4uZ2V0RmFjZXRlZFJvd01vZGVsKCldO1xuICB9LCBmYWNldGVkUm93TW9kZWwgPT4ge1xuICAgIGlmICghZmFjZXRlZFJvd01vZGVsKSByZXR1cm4gbmV3IE1hcCgpO1xuICAgIGxldCBmYWNldGVkVW5pcXVlVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFjZXRlZFJvd01vZGVsLmZsYXRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBmYWNldGVkUm93TW9kZWwuZmxhdFJvd3NbaV0uZ2V0VW5pcXVlVmFsdWVzKGNvbHVtbklkKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2pdO1xuICAgICAgICBpZiAoZmFjZXRlZFVuaXF1ZVZhbHVlcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgdmFyIF9mYWNldGVkVW5pcXVlVmFsdWVzJDtcbiAgICAgICAgICBmYWNldGVkVW5pcXVlVmFsdWVzLnNldCh2YWx1ZSwgKChfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgPSBmYWNldGVkVW5pcXVlVmFsdWVzLmdldCh2YWx1ZSkpICE9IG51bGwgPyBfZmFjZXRlZFVuaXF1ZVZhbHVlcyQgOiAwKSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhY2V0ZWRVbmlxdWVWYWx1ZXMuc2V0KHZhbHVlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFjZXRlZFVuaXF1ZVZhbHVlcztcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCBgZ2V0RmFjZXRlZFVuaXF1ZVZhbHVlc18ke2NvbHVtbklkfWApKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsdGVyZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFByZUZpbHRlcmVkUm93TW9kZWwoKSwgdGFibGUuZ2V0U3RhdGUoKS5jb2x1bW5GaWx0ZXJzLCB0YWJsZS5nZXRTdGF0ZSgpLmdsb2JhbEZpbHRlcl0sIChyb3dNb2RlbCwgY29sdW1uRmlsdGVycywgZ2xvYmFsRmlsdGVyKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCAmJiBjb2x1bW5GaWx0ZXJzLmxlbmd0aCkgJiYgIWdsb2JhbEZpbHRlcikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dNb2RlbC5mbGF0Um93cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3dNb2RlbC5mbGF0Um93c1tpXS5jb2x1bW5GaWx0ZXJzID0ge307XG4gICAgICAgIHJvd01vZGVsLmZsYXRSb3dzW2ldLmNvbHVtbkZpbHRlcnNNZXRhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkQ29sdW1uRmlsdGVycyA9IFtdO1xuICAgIGNvbnN0IHJlc29sdmVkR2xvYmFsRmlsdGVycyA9IFtdO1xuICAgIChjb2x1bW5GaWx0ZXJzICE9IG51bGwgPyBjb2x1bW5GaWx0ZXJzIDogW10pLmZvckVhY2goZCA9PiB7XG4gICAgICB2YXIgX2ZpbHRlckZuJHJlc29sdmVGaWx0O1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKGQuaWQpO1xuICAgICAgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZmlsdGVyRm4gPSBjb2x1bW4uZ2V0RmlsdGVyRm4oKTtcbiAgICAgIGlmICghZmlsdGVyRm4pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBmaW5kIGEgdmFsaWQgJ2NvbHVtbi5maWx0ZXJGbicgZm9yIGNvbHVtbiB3aXRoIHRoZSBJRDogJHtjb2x1bW4uaWR9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmVkQ29sdW1uRmlsdGVycy5wdXNoKHtcbiAgICAgICAgaWQ6IGQuaWQsXG4gICAgICAgIGZpbHRlckZuLFxuICAgICAgICByZXNvbHZlZFZhbHVlOiAoX2ZpbHRlckZuJHJlc29sdmVGaWx0ID0gZmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBmaWx0ZXJGbi5yZXNvbHZlRmlsdGVyVmFsdWUoZC52YWx1ZSkpICE9IG51bGwgPyBfZmlsdGVyRm4kcmVzb2x2ZUZpbHQgOiBkLnZhbHVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBmaWx0ZXJhYmxlSWRzID0gKGNvbHVtbkZpbHRlcnMgIT0gbnVsbCA/IGNvbHVtbkZpbHRlcnMgOiBbXSkubWFwKGQgPT4gZC5pZCk7XG4gICAgY29uc3QgZ2xvYmFsRmlsdGVyRm4gPSB0YWJsZS5nZXRHbG9iYWxGaWx0ZXJGbigpO1xuICAgIGNvbnN0IGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMgPSB0YWJsZS5nZXRBbGxMZWFmQ29sdW1ucygpLmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmdldENhbkdsb2JhbEZpbHRlcigpKTtcbiAgICBpZiAoZ2xvYmFsRmlsdGVyICYmIGdsb2JhbEZpbHRlckZuICYmIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICBmaWx0ZXJhYmxlSWRzLnB1c2goJ19fZ2xvYmFsX18nKTtcbiAgICAgIGdsb2JhbGx5RmlsdGVyYWJsZUNvbHVtbnMuZm9yRWFjaChjb2x1bW4gPT4ge1xuICAgICAgICB2YXIgX2dsb2JhbEZpbHRlckZuJHJlc29sO1xuICAgICAgICByZXNvbHZlZEdsb2JhbEZpbHRlcnMucHVzaCh7XG4gICAgICAgICAgaWQ6IGNvbHVtbi5pZCxcbiAgICAgICAgICBmaWx0ZXJGbjogZ2xvYmFsRmlsdGVyRm4sXG4gICAgICAgICAgcmVzb2x2ZWRWYWx1ZTogKF9nbG9iYWxGaWx0ZXJGbiRyZXNvbCA9IGdsb2JhbEZpbHRlckZuLnJlc29sdmVGaWx0ZXJWYWx1ZSA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsRmlsdGVyRm4ucmVzb2x2ZUZpbHRlclZhbHVlKGdsb2JhbEZpbHRlcikpICE9IG51bGwgPyBfZ2xvYmFsRmlsdGVyRm4kcmVzb2wgOiBnbG9iYWxGaWx0ZXJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRDb2x1bW5GaWx0ZXI7XG4gICAgbGV0IGN1cnJlbnRHbG9iYWxGaWx0ZXI7XG5cbiAgICAvLyBGbGFnIHRoZSBwcmVmaWx0ZXJlZCByb3cgbW9kZWwgd2l0aCBlYWNoIGZpbHRlciBzdGF0ZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93TW9kZWwuZmxhdFJvd3MubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHJvd01vZGVsLmZsYXRSb3dzW2pdO1xuICAgICAgcm93LmNvbHVtbkZpbHRlcnMgPSB7fTtcbiAgICAgIGlmIChyZXNvbHZlZENvbHVtbkZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRDb2x1bW5GaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudENvbHVtbkZpbHRlciA9IHJlc29sdmVkQ29sdW1uRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRDb2x1bW5GaWx0ZXIuaWQ7XG5cbiAgICAgICAgICAvLyBUYWcgdGhlIHJvdyB3aXRoIHRoZSBjb2x1bW4gZmlsdGVyIHN0YXRlXG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNbaWRdID0gY3VycmVudENvbHVtbkZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50Q29sdW1uRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXNvbHZlZEdsb2JhbEZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRHbG9iYWxGaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudEdsb2JhbEZpbHRlciA9IHJlc29sdmVkR2xvYmFsRmlsdGVyc1tpXTtcbiAgICAgICAgICBjb25zdCBpZCA9IGN1cnJlbnRHbG9iYWxGaWx0ZXIuaWQ7XG4gICAgICAgICAgLy8gVGFnIHRoZSByb3cgd2l0aCB0aGUgZmlyc3QgdHJ1dGh5IGdsb2JhbCBmaWx0ZXIgc3RhdGVcbiAgICAgICAgICBpZiAoY3VycmVudEdsb2JhbEZpbHRlci5maWx0ZXJGbihyb3csIGlkLCBjdXJyZW50R2xvYmFsRmlsdGVyLnJlc29sdmVkVmFsdWUsIGZpbHRlck1ldGEgPT4ge1xuICAgICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnNNZXRhW2lkXSA9IGZpbHRlck1ldGE7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJvdy5jb2x1bW5GaWx0ZXJzLl9fZ2xvYmFsX18gPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb3cuY29sdW1uRmlsdGVycy5fX2dsb2JhbF9fICE9PSB0cnVlKSB7XG4gICAgICAgICAgcm93LmNvbHVtbkZpbHRlcnMuX19nbG9iYWxfXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlclJvd3NJbXBsID0gcm93ID0+IHtcbiAgICAgIC8vIEhvcml6b250YWxseSBmaWx0ZXIgcm93cyB0aHJvdWdoIGVhY2ggY29sdW1uXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbHRlcmFibGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJvdy5jb2x1bW5GaWx0ZXJzW2ZpbHRlcmFibGVJZHNbaV1dID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8vIEZpbHRlciBmaW5hbCByb3dzIHVzaW5nIGFsbCBvZiB0aGUgYWN0aXZlIGZpbHRlcnNcbiAgICByZXR1cm4gZmlsdGVyUm93cyhyb3dNb2RlbC5yb3dzLCBmaWx0ZXJSb3dzSW1wbCwgdGFibGUpO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRGaWx0ZXJlZFJvd01vZGVsJywgKCkgPT4gdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwZWRSb3dNb2RlbCgpIHtcbiAgcmV0dXJuIHRhYmxlID0+IG1lbW8oKCkgPT4gW3RhYmxlLmdldFN0YXRlKCkuZ3JvdXBpbmcsIHRhYmxlLmdldFByZUdyb3VwZWRSb3dNb2RlbCgpXSwgKGdyb3VwaW5nLCByb3dNb2RlbCkgPT4ge1xuICAgIGlmICghcm93TW9kZWwucm93cy5sZW5ndGggfHwgIWdyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgcm93TW9kZWwucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgIHJvdy5kZXB0aCA9IDA7XG4gICAgICAgIHJvdy5wYXJlbnRJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJvd01vZGVsO1xuICAgIH1cblxuICAgIC8vIEZpbHRlciB0aGUgZ3JvdXBpbmcgbGlzdCBkb3duIHRvIGNvbHVtbnMgdGhhdCBleGlzdFxuICAgIGNvbnN0IGV4aXN0aW5nR3JvdXBpbmcgPSBncm91cGluZy5maWx0ZXIoY29sdW1uSWQgPT4gdGFibGUuZ2V0Q29sdW1uKGNvbHVtbklkKSk7XG4gICAgY29uc3QgZ3JvdXBlZEZsYXRSb3dzID0gW107XG4gICAgY29uc3QgZ3JvdXBlZFJvd3NCeUlkID0ge307XG4gICAgLy8gY29uc3Qgb25seUdyb3VwZWRGbGF0Um93czogUm93W10gPSBbXTtcbiAgICAvLyBjb25zdCBvbmx5R3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcbiAgICAvLyBjb25zdCBub25Hcm91cGVkRmxhdFJvd3M6IFJvd1tdID0gW107XG4gICAgLy8gY29uc3Qgbm9uR3JvdXBlZFJvd3NCeUlkOiBSZWNvcmQ8Um93SWQsIFJvdz4gPSB7fTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGdyb3VwIHRoZSBkYXRhXG4gICAgY29uc3QgZ3JvdXBVcFJlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKHJvd3MsIGRlcHRoLCBwYXJlbnRJZCkge1xuICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHtcbiAgICAgICAgZGVwdGggPSAwO1xuICAgICAgfVxuICAgICAgLy8gR3JvdXBpbmcgZGVwdGggaGFzIGJlZW4gYmVlbiBtZXRcbiAgICAgIC8vIFN0b3AgZ3JvdXBpbmcgYW5kIHNpbXBseSByZXdyaXRlIHRoZCBkZXB0aCBhbmQgcm93IHJlbGF0aW9uc2hpcHNcbiAgICAgIGlmIChkZXB0aCA+PSBleGlzdGluZ0dyb3VwaW5nLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICByb3cuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgICBncm91cGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICAgIGdyb3VwZWRSb3dzQnlJZFtyb3cuaWRdID0gcm93O1xuICAgICAgICAgIGlmIChyb3cuc3ViUm93cykge1xuICAgICAgICAgICAgcm93LnN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkocm93LnN1YlJvd3MsIGRlcHRoICsgMSwgcm93LmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb2x1bW5JZCA9IGV4aXN0aW5nR3JvdXBpbmdbZGVwdGhdO1xuXG4gICAgICAvLyBHcm91cCB0aGUgcm93cyB0b2dldGhlciBmb3IgdGhpcyBsZXZlbFxuICAgICAgY29uc3Qgcm93R3JvdXBzTWFwID0gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCk7XG5cbiAgICAgIC8vIFBlcmZvcm0gYWdncmVnYXRpb25zIGZvciBlYWNoIGdyb3VwXG4gICAgICBjb25zdCBhZ2dyZWdhdGVkR3JvdXBlZFJvd3MgPSBBcnJheS5mcm9tKHJvd0dyb3Vwc01hcC5lbnRyaWVzKCkpLm1hcCgoX3JlZiwgaW5kZXgpID0+IHtcbiAgICAgICAgbGV0IFtncm91cGluZ1ZhbHVlLCBncm91cGVkUm93c10gPSBfcmVmO1xuICAgICAgICBsZXQgaWQgPSBgJHtjb2x1bW5JZH06JHtncm91cGluZ1ZhbHVlfWA7XG4gICAgICAgIGlkID0gcGFyZW50SWQgPyBgJHtwYXJlbnRJZH0+JHtpZH1gIDogaWQ7XG5cbiAgICAgICAgLy8gRmlyc3QsIFJlY3Vyc2UgdG8gZ3JvdXAgc3ViIHJvd3MgYmVmb3JlIGFnZ3JlZ2F0aW9uXG4gICAgICAgIGNvbnN0IHN1YlJvd3MgPSBncm91cFVwUmVjdXJzaXZlbHkoZ3JvdXBlZFJvd3MsIGRlcHRoICsgMSwgaWQpO1xuICAgICAgICBzdWJSb3dzLmZvckVhY2goc3ViUm93ID0+IHtcbiAgICAgICAgICBzdWJSb3cucGFyZW50SWQgPSBpZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgbGVhZiByb3dzIG9mIHRoZSByb3dzIGluIHRoaXMgZ3JvdXBcbiAgICAgICAgY29uc3QgbGVhZlJvd3MgPSBkZXB0aCA/IGZsYXR0ZW5CeShncm91cGVkUm93cywgcm93ID0+IHJvdy5zdWJSb3dzKSA6IGdyb3VwZWRSb3dzO1xuICAgICAgICBjb25zdCByb3cgPSBjcmVhdGVSb3codGFibGUsIGlkLCBsZWFmUm93c1swXS5vcmlnaW5hbCwgaW5kZXgsIGRlcHRoLCB1bmRlZmluZWQsIHBhcmVudElkKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyb3csIHtcbiAgICAgICAgICBncm91cGluZ0NvbHVtbklkOiBjb2x1bW5JZCxcbiAgICAgICAgICBncm91cGluZ1ZhbHVlLFxuICAgICAgICAgIHN1YlJvd3MsXG4gICAgICAgICAgbGVhZlJvd3MsXG4gICAgICAgICAgZ2V0VmFsdWU6IGNvbHVtbklkID0+IHtcbiAgICAgICAgICAgIC8vIERvbid0IGFnZ3JlZ2F0ZSBjb2x1bW5zIHRoYXQgYXJlIGluIHRoZSBncm91cGluZ1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nR3JvdXBpbmcuaW5jbHVkZXMoY29sdW1uSWQpKSB7XG4gICAgICAgICAgICAgIGlmIChyb3cuX3ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb3cuX3ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFJvd3NbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dyb3VwZWRSb3dzJDAkZ2V0VmFsO1xuICAgICAgICAgICAgICAgIHJvdy5fdmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gKF9ncm91cGVkUm93cyQwJGdldFZhbCA9IGdyb3VwZWRSb3dzWzBdLmdldFZhbHVlKGNvbHVtbklkKSkgIT0gbnVsbCA/IF9ncm91cGVkUm93cyQwJGdldFZhbCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcm93Ll92YWx1ZXNDYWNoZVtjb2x1bW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlLmhhc093blByb3BlcnR5KGNvbHVtbklkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gcm93Ll9ncm91cGluZ1ZhbHVlc0NhY2hlW2NvbHVtbklkXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWdncmVnYXRlIHRoZSB2YWx1ZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHRhYmxlLmdldENvbHVtbihjb2x1bW5JZCk7XG4gICAgICAgICAgICBjb25zdCBhZ2dyZWdhdGVGbiA9IGNvbHVtbiA9PSBudWxsID8gdm9pZCAwIDogY29sdW1uLmdldEFnZ3JlZ2F0aW9uRm4oKTtcbiAgICAgICAgICAgIGlmIChhZ2dyZWdhdGVGbikge1xuICAgICAgICAgICAgICByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdID0gYWdncmVnYXRlRm4oY29sdW1uSWQsIGxlYWZSb3dzLCBncm91cGVkUm93cyk7XG4gICAgICAgICAgICAgIHJldHVybiByb3cuX2dyb3VwaW5nVmFsdWVzQ2FjaGVbY29sdW1uSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN1YlJvd3MuZm9yRWFjaChzdWJSb3cgPT4ge1xuICAgICAgICAgIGdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAgICAgLy8gaWYgKHN1YlJvdy5nZXRJc0dyb3VwZWQ/LigpKSB7XG4gICAgICAgICAgLy8gICBvbmx5R3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgbm9uR3JvdXBlZEZsYXRSb3dzLnB1c2goc3ViUm93KTtcbiAgICAgICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhZ2dyZWdhdGVkR3JvdXBlZFJvd3M7XG4gICAgfTtcbiAgICBjb25zdCBncm91cGVkUm93cyA9IGdyb3VwVXBSZWN1cnNpdmVseShyb3dNb2RlbC5yb3dzLCAwKTtcbiAgICBncm91cGVkUm93cy5mb3JFYWNoKHN1YlJvdyA9PiB7XG4gICAgICBncm91cGVkRmxhdFJvd3MucHVzaChzdWJSb3cpO1xuICAgICAgZ3JvdXBlZFJvd3NCeUlkW3N1YlJvdy5pZF0gPSBzdWJSb3c7XG4gICAgICAvLyBpZiAoc3ViUm93LmdldElzR3JvdXBlZD8uKCkpIHtcbiAgICAgIC8vICAgb25seUdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG9ubHlHcm91cGVkUm93c0J5SWRbc3ViUm93LmlkXSA9IHN1YlJvdztcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRGbGF0Um93cy5wdXNoKHN1YlJvdyk7XG4gICAgICAvLyAgIG5vbkdyb3VwZWRSb3dzQnlJZFtzdWJSb3cuaWRdID0gc3ViUm93O1xuICAgICAgLy8gfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBncm91cGVkUm93cyxcbiAgICAgIGZsYXRSb3dzOiBncm91cGVkRmxhdFJvd3MsXG4gICAgICByb3dzQnlJZDogZ3JvdXBlZFJvd3NCeUlkXG4gICAgfTtcbiAgfSwgZ2V0TWVtb09wdGlvbnModGFibGUub3B0aW9ucywgJ2RlYnVnVGFibGUnLCAnZ2V0R3JvdXBlZFJvd01vZGVsJywgKCkgPT4ge1xuICAgIHRhYmxlLl9xdWV1ZSgoKSA9PiB7XG4gICAgICB0YWJsZS5fYXV0b1Jlc2V0RXhwYW5kZWQoKTtcbiAgICAgIHRhYmxlLl9hdXRvUmVzZXRQYWdlSW5kZXgoKTtcbiAgICB9KTtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ3JvdXBCeShyb3dzLCBjb2x1bW5JZCkge1xuICBjb25zdCBncm91cE1hcCA9IG5ldyBNYXAoKTtcbiAgcmV0dXJuIHJvd3MucmVkdWNlKChtYXAsIHJvdykgPT4ge1xuICAgIGNvbnN0IHJlc0tleSA9IGAke3Jvdy5nZXRHcm91cGluZ1ZhbHVlKGNvbHVtbklkKX1gO1xuICAgIGNvbnN0IHByZXZpb3VzID0gbWFwLmdldChyZXNLZXkpO1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgIG1hcC5zZXQocmVzS2V5LCBbcm93XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzLnB1c2gocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfSwgZ3JvdXBNYXApO1xufVxuXG5mdW5jdGlvbiBnZXRQYWdpbmF0aW9uUm93TW9kZWwob3B0cykge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5wYWdpbmF0aW9uLCB0YWJsZS5nZXRQcmVQYWdpbmF0aW9uUm93TW9kZWwoKSwgdGFibGUub3B0aW9ucy5wYWdpbmF0ZUV4cGFuZGVkUm93cyA/IHVuZGVmaW5lZCA6IHRhYmxlLmdldFN0YXRlKCkuZXhwYW5kZWRdLCAocGFnaW5hdGlvbiwgcm93TW9kZWwpID0+IHtcbiAgICBpZiAoIXJvd01vZGVsLnJvd3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcm93TW9kZWw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VTaXplLFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHBhZ2luYXRpb247XG4gICAgbGV0IHtcbiAgICAgIHJvd3MsXG4gICAgICBmbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkXG4gICAgfSA9IHJvd01vZGVsO1xuICAgIGNvbnN0IHBhZ2VTdGFydCA9IHBhZ2VTaXplICogcGFnZUluZGV4O1xuICAgIGNvbnN0IHBhZ2VFbmQgPSBwYWdlU3RhcnQgKyBwYWdlU2l6ZTtcbiAgICByb3dzID0gcm93cy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpO1xuICAgIGxldCBwYWdpbmF0ZWRSb3dNb2RlbDtcbiAgICBpZiAoIXRhYmxlLm9wdGlvbnMucGFnaW5hdGVFeHBhbmRlZFJvd3MpIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0gZXhwYW5kUm93cyh7XG4gICAgICAgIHJvd3MsXG4gICAgICAgIGZsYXRSb3dzLFxuICAgICAgICByb3dzQnlJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsID0ge1xuICAgICAgICByb3dzLFxuICAgICAgICBmbGF0Um93cyxcbiAgICAgICAgcm93c0J5SWRcbiAgICAgIH07XG4gICAgfVxuICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzID0gW107XG4gICAgY29uc3QgaGFuZGxlUm93ID0gcm93ID0+IHtcbiAgICAgIHBhZ2luYXRlZFJvd01vZGVsLmZsYXRSb3dzLnB1c2gocm93KTtcbiAgICAgIGlmIChyb3cuc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgcm93LnN1YlJvd3MuZm9yRWFjaChoYW5kbGVSb3cpO1xuICAgICAgfVxuICAgIH07XG4gICAgcGFnaW5hdGVkUm93TW9kZWwucm93cy5mb3JFYWNoKGhhbmRsZVJvdyk7XG4gICAgcmV0dXJuIHBhZ2luYXRlZFJvd01vZGVsO1xuICB9LCBnZXRNZW1vT3B0aW9ucyh0YWJsZS5vcHRpb25zLCAnZGVidWdUYWJsZScsICdnZXRQYWdpbmF0aW9uUm93TW9kZWwnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJvd01vZGVsKCkge1xuICByZXR1cm4gdGFibGUgPT4gbWVtbygoKSA9PiBbdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nLCB0YWJsZS5nZXRQcmVTb3J0ZWRSb3dNb2RlbCgpXSwgKHNvcnRpbmcsIHJvd01vZGVsKSA9PiB7XG4gICAgaWYgKCFyb3dNb2RlbC5yb3dzLmxlbmd0aCB8fCAhKHNvcnRpbmcgIT0gbnVsbCAmJiBzb3J0aW5nLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiByb3dNb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc29ydGluZ1N0YXRlID0gdGFibGUuZ2V0U3RhdGUoKS5zb3J0aW5nO1xuICAgIGNvbnN0IHNvcnRlZEZsYXRSb3dzID0gW107XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHNvcnRpbmdzIHRoYXQgY29ycmVzcG9uZCB0byBub24gZXhpc3RpbmcgY29sdW1uc1xuICAgIGNvbnN0IGF2YWlsYWJsZVNvcnRpbmcgPSBzb3J0aW5nU3RhdGUuZmlsdGVyKHNvcnQgPT4ge1xuICAgICAgdmFyIF90YWJsZSRnZXRDb2x1bW47XG4gICAgICByZXR1cm4gKF90YWJsZSRnZXRDb2x1bW4gPSB0YWJsZS5nZXRDb2x1bW4oc29ydC5pZCkpID09IG51bGwgPyB2b2lkIDAgOiBfdGFibGUkZ2V0Q29sdW1uLmdldENhblNvcnQoKTtcbiAgICB9KTtcbiAgICBjb25zdCBjb2x1bW5JbmZvQnlJZCA9IHt9O1xuICAgIGF2YWlsYWJsZVNvcnRpbmcuZm9yRWFjaChzb3J0RW50cnkgPT4ge1xuICAgICAgY29uc3QgY29sdW1uID0gdGFibGUuZ2V0Q29sdW1uKHNvcnRFbnRyeS5pZCk7XG4gICAgICBpZiAoIWNvbHVtbikgcmV0dXJuO1xuICAgICAgY29sdW1uSW5mb0J5SWRbc29ydEVudHJ5LmlkXSA9IHtcbiAgICAgICAgc29ydFVuZGVmaW5lZDogY29sdW1uLmNvbHVtbkRlZi5zb3J0VW5kZWZpbmVkLFxuICAgICAgICBpbnZlcnRTb3J0aW5nOiBjb2x1bW4uY29sdW1uRGVmLmludmVydFNvcnRpbmcsXG4gICAgICAgIHNvcnRpbmdGbjogY29sdW1uLmdldFNvcnRpbmdGbigpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHNvcnREYXRhID0gcm93cyA9PiB7XG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBwZXJmb3JtIGEgc3RhYmxlIHNvcnRpbmcgdXNpbmcgdGhlIHJvdyBpbmRleFxuICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgY29uc3Qgc29ydGVkRGF0YSA9IHJvd3MubWFwKHJvdyA9PiAoe1xuICAgICAgICAuLi5yb3dcbiAgICAgIH0pKTtcbiAgICAgIHNvcnRlZERhdGEuc29ydCgocm93QSwgcm93QikgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF2YWlsYWJsZVNvcnRpbmcubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgX3NvcnRFbnRyeSRkZXNjO1xuICAgICAgICAgIGNvbnN0IHNvcnRFbnRyeSA9IGF2YWlsYWJsZVNvcnRpbmdbaV07XG4gICAgICAgICAgY29uc3QgY29sdW1uSW5mbyA9IGNvbHVtbkluZm9CeUlkW3NvcnRFbnRyeS5pZF07XG4gICAgICAgICAgY29uc3Qgc29ydFVuZGVmaW5lZCA9IGNvbHVtbkluZm8uc29ydFVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBpc0Rlc2MgPSAoX3NvcnRFbnRyeSRkZXNjID0gc29ydEVudHJ5ID09IG51bGwgPyB2b2lkIDAgOiBzb3J0RW50cnkuZGVzYykgIT0gbnVsbCA/IF9zb3J0RW50cnkkZGVzYyA6IGZhbHNlO1xuICAgICAgICAgIGxldCBzb3J0SW50ID0gMDtcblxuICAgICAgICAgIC8vIEFsbCBzb3J0aW5nIGludHMgc2hvdWxkIGFsd2F5cyByZXR1cm4gaW4gYXNjZW5kaW5nIG9yZGVyXG4gICAgICAgICAgaWYgKHNvcnRVbmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFWYWx1ZSA9IHJvd0EuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGJWYWx1ZSA9IHJvd0IuZ2V0VmFsdWUoc29ydEVudHJ5LmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGFVbmRlZmluZWQgPSBhVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGJVbmRlZmluZWQgPSBiVmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhVW5kZWZpbmVkIHx8IGJVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHNvcnRVbmRlZmluZWQgPT09ICdmaXJzdCcpIHJldHVybiBhVW5kZWZpbmVkID8gLTEgOiAxO1xuICAgICAgICAgICAgICBpZiAoc29ydFVuZGVmaW5lZCA9PT0gJ2xhc3QnKSByZXR1cm4gYVVuZGVmaW5lZCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgc29ydEludCA9IGFVbmRlZmluZWQgJiYgYlVuZGVmaW5lZCA/IDAgOiBhVW5kZWZpbmVkID8gc29ydFVuZGVmaW5lZCA6IC1zb3J0VW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc29ydEludCA9PT0gMCkge1xuICAgICAgICAgICAgc29ydEludCA9IGNvbHVtbkluZm8uc29ydGluZ0ZuKHJvd0EsIHJvd0IsIHNvcnRFbnRyeS5pZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgc29ydGluZyBpcyBub24temVybywgdGFrZSBjYXJlIG9mIGRlc2MgYW5kIGludmVyc2lvblxuICAgICAgICAgIGlmIChzb3J0SW50ICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXNEZXNjKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sdW1uSW5mby5pbnZlcnRTb3J0aW5nKSB7XG4gICAgICAgICAgICAgIHNvcnRJbnQgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc29ydEludDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd0EuaW5kZXggLSByb3dCLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBzdWItcm93cywgc29ydCB0aGVtXG4gICAgICBzb3J0ZWREYXRhLmZvckVhY2gocm93ID0+IHtcbiAgICAgICAgdmFyIF9yb3ckc3ViUm93cztcbiAgICAgICAgc29ydGVkRmxhdFJvd3MucHVzaChyb3cpO1xuICAgICAgICBpZiAoKF9yb3ckc3ViUm93cyA9IHJvdy5zdWJSb3dzKSAhPSBudWxsICYmIF9yb3ckc3ViUm93cy5sZW5ndGgpIHtcbiAgICAgICAgICByb3cuc3ViUm93cyA9IHNvcnREYXRhKHJvdy5zdWJSb3dzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydGVkRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICByb3dzOiBzb3J0RGF0YShyb3dNb2RlbC5yb3dzKSxcbiAgICAgIGZsYXRSb3dzOiBzb3J0ZWRGbGF0Um93cyxcbiAgICAgIHJvd3NCeUlkOiByb3dNb2RlbC5yb3dzQnlJZFxuICAgIH07XG4gIH0sIGdldE1lbW9PcHRpb25zKHRhYmxlLm9wdGlvbnMsICdkZWJ1Z1RhYmxlJywgJ2dldFNvcnRlZFJvd01vZGVsJywgKCkgPT4gdGFibGUuX2F1dG9SZXNldFBhZ2VJbmRleCgpKSk7XG59XG5cbmV4cG9ydCB7IENvbHVtbkZhY2V0aW5nLCBDb2x1bW5GaWx0ZXJpbmcsIENvbHVtbkdyb3VwaW5nLCBDb2x1bW5PcmRlcmluZywgQ29sdW1uUGlubmluZywgQ29sdW1uU2l6aW5nLCBDb2x1bW5WaXNpYmlsaXR5LCBHbG9iYWxGYWNldGluZywgR2xvYmFsRmlsdGVyaW5nLCBIZWFkZXJzLCBSb3dFeHBhbmRpbmcsIFJvd1BhZ2luYXRpb24sIFJvd1Bpbm5pbmcsIFJvd1NlbGVjdGlvbiwgUm93U29ydGluZywgX2dldFZpc2libGVMZWFmQ29sdW1ucywgYWdncmVnYXRpb25GbnMsIGJ1aWxkSGVhZGVyR3JvdXBzLCBjcmVhdGVDZWxsLCBjcmVhdGVDb2x1bW4sIGNyZWF0ZUNvbHVtbkhlbHBlciwgY3JlYXRlUm93LCBjcmVhdGVUYWJsZSwgZGVmYXVsdENvbHVtblNpemluZywgZXhwYW5kUm93cywgZmlsdGVyRm5zLCBmbGF0dGVuQnksIGZ1bmN0aW9uYWxVcGRhdGUsIGdldENvcmVSb3dNb2RlbCwgZ2V0RXhwYW5kZWRSb3dNb2RlbCwgZ2V0RmFjZXRlZE1pbk1heFZhbHVlcywgZ2V0RmFjZXRlZFJvd01vZGVsLCBnZXRGYWNldGVkVW5pcXVlVmFsdWVzLCBnZXRGaWx0ZXJlZFJvd01vZGVsLCBnZXRHcm91cGVkUm93TW9kZWwsIGdldE1lbW9PcHRpb25zLCBnZXRQYWdpbmF0aW9uUm93TW9kZWwsIGdldFNvcnRlZFJvd01vZGVsLCBpc0Z1bmN0aW9uLCBpc051bWJlckFycmF5LCBpc1Jvd1NlbGVjdGVkLCBpc1N1YlJvd1NlbGVjdGVkLCBtYWtlU3RhdGVVcGRhdGVyLCBtZW1vLCBub29wLCBvcmRlckNvbHVtbnMsIHBhc3NpdmVFdmVudFN1cHBvcnRlZCwgcmVTcGxpdEFscGhhTnVtZXJpYywgc2VsZWN0Um93c0ZuLCBzaG91bGRBdXRvUmVtb3ZlRmlsdGVyLCBzb3J0aW5nRm5zIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@tanstack/table-core/build/lib/index.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst getRect = (element) => {\n  const { offsetWidth, offsetHeight } = element;\n  return { width: offsetWidth, height: offsetHeight };\n};\nconst defaultKeyExtractor = (index) => index;\nconst defaultRangeExtractor = (range) => {\n  const start = Math.max(range.startIndex - range.overscan, 0);\n  const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n  const arr = [];\n  for (let i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nconst observeElementRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  const handler = (rect) => {\n    const { width, height } = rect;\n    cb({ width: Math.round(width), height: Math.round(height) });\n  };\n  handler(getRect(element));\n  if (!targetWindow.ResizeObserver) {\n    return () => {\n    };\n  }\n  const observer = new targetWindow.ResizeObserver((entries) => {\n    const run = () => {\n      const entry = entries[0];\n      if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n          handler({ width: box.inlineSize, height: box.blockSize });\n          return;\n        }\n      }\n      handler(getRect(element));\n    };\n    instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n  });\n  observer.observe(element, { box: \"border-box\" });\n  return () => {\n    observer.unobserve(element);\n  };\n};\nconst addEventListenerOptions = {\n  passive: true\n};\nconst observeWindowRect = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const handler = () => {\n    cb({ width: element.innerWidth, height: element.innerHeight });\n  };\n  handler();\n  element.addEventListener(\"resize\", handler, addEventListenerOptions);\n  return () => {\n    element.removeEventListener(\"resize\", handler);\n  };\n};\nconst supportsScrollend = typeof window == \"undefined\" ? true : \"onscrollend\" in window;\nconst observeElementOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    const { horizontal, isRtl } = instance.options;\n    offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst observeWindowOffset = (instance, cb) => {\n  const element = instance.scrollElement;\n  if (!element) {\n    return;\n  }\n  const targetWindow = instance.targetWindow;\n  if (!targetWindow) {\n    return;\n  }\n  let offset = 0;\n  const fallback = instance.options.useScrollendEvent && supportsScrollend ? () => void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(\n    targetWindow,\n    () => {\n      cb(offset, false);\n    },\n    instance.options.isScrollingResetDelay\n  );\n  const createHandler = (isScrolling) => () => {\n    offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n    fallback();\n    cb(offset, isScrolling);\n  };\n  const handler = createHandler(true);\n  const endHandler = createHandler(false);\n  endHandler();\n  element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n  const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n  if (registerScrollendEvent) {\n    element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n  }\n  return () => {\n    element.removeEventListener(\"scroll\", handler);\n    if (registerScrollendEvent) {\n      element.removeEventListener(\"scrollend\", endHandler);\n    }\n  };\n};\nconst measureElement = (element, entry, instance) => {\n  if (entry == null ? void 0 : entry.borderBoxSize) {\n    const box = entry.borderBoxSize[0];\n    if (box) {\n      const size = Math.round(\n        box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n      return size;\n    }\n  }\n  return element[instance.options.horizontal ? \"offsetWidth\" : \"offsetHeight\"];\n};\nconst windowScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nconst elementScroll = (offset, {\n  adjustments = 0,\n  behavior\n}, instance) => {\n  var _a, _b;\n  const toOffset = offset + adjustments;\n  (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n    [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n    behavior\n  });\n};\nclass Virtualizer {\n  constructor(opts) {\n    this.unsubs = [];\n    this.scrollElement = null;\n    this.targetWindow = null;\n    this.isScrolling = false;\n    this.measurementsCache = [];\n    this.itemSizeCache = /* @__PURE__ */ new Map();\n    this.pendingMeasuredCacheIndexes = [];\n    this.scrollRect = null;\n    this.scrollOffset = null;\n    this.scrollDirection = null;\n    this.scrollAdjustments = 0;\n    this.elementsCache = /* @__PURE__ */ new Map();\n    this.observer = /* @__PURE__ */ (() => {\n      let _ro = null;\n      const get = () => {\n        if (_ro) {\n          return _ro;\n        }\n        if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n          return null;\n        }\n        return _ro = new this.targetWindow.ResizeObserver((entries) => {\n          entries.forEach((entry) => {\n            const run = () => {\n              this._measureElement(entry.target, entry);\n            };\n            this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n          });\n        });\n      };\n      return {\n        disconnect: () => {\n          var _a;\n          (_a = get()) == null ? void 0 : _a.disconnect();\n          _ro = null;\n        },\n        observe: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.observe(target, { box: \"border-box\" });\n        },\n        unobserve: (target) => {\n          var _a;\n          return (_a = get()) == null ? void 0 : _a.unobserve(target);\n        }\n      };\n    })();\n    this.range = null;\n    this.setOptions = (opts2) => {\n      Object.entries(opts2).forEach(([key, value]) => {\n        if (typeof value === \"undefined\") delete opts2[key];\n      });\n      this.options = {\n        debug: false,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: false,\n        getItemKey: defaultKeyExtractor,\n        rangeExtractor: defaultRangeExtractor,\n        onChange: () => {\n        },\n        measureElement,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: true,\n        isRtl: false,\n        useScrollendEvent: false,\n        useAnimationFrameWithResizeObserver: false,\n        ...opts2\n      };\n    };\n    this.notify = (sync) => {\n      var _a, _b;\n      (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n    };\n    this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        this.calculateRange();\n        return [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ];\n      },\n      (isScrolling) => {\n        this.notify(isScrolling);\n      },\n      {\n        key:  true && \"maybeNotify\",\n        debug: () => this.options.debug,\n        initialDeps: [\n          this.isScrolling,\n          this.range ? this.range.startIndex : null,\n          this.range ? this.range.endIndex : null\n        ]\n      }\n    );\n    this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((d) => d());\n      this.unsubs = [];\n      this.observer.disconnect();\n      this.scrollElement = null;\n      this.targetWindow = null;\n    };\n    this._didMount = () => {\n      return () => {\n        this.cleanup();\n      };\n    };\n    this._willUpdate = () => {\n      var _a;\n      const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== scrollElement) {\n        this.cleanup();\n        if (!scrollElement) {\n          this.maybeNotify();\n          return;\n        }\n        this.scrollElement = scrollElement;\n        if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n          this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n        } else {\n          this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n        }\n        this.elementsCache.forEach((cached) => {\n          this.observer.observe(cached);\n        });\n        this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        });\n        this.unsubs.push(\n          this.options.observeElementRect(this, (rect) => {\n            this.scrollRect = rect;\n            this.maybeNotify();\n          })\n        );\n        this.unsubs.push(\n          this.options.observeElementOffset(this, (offset, isScrolling) => {\n            this.scrollAdjustments = 0;\n            this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n            this.scrollOffset = offset;\n            this.isScrolling = isScrolling;\n            this.maybeNotify();\n          })\n        );\n      }\n    };\n    this.getSize = () => {\n      if (!this.options.enabled) {\n        this.scrollRect = null;\n        return 0;\n      }\n      this.scrollRect = this.scrollRect ?? this.options.initialRect;\n      return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n    };\n    this.getScrollOffset = () => {\n      if (!this.options.enabled) {\n        this.scrollOffset = null;\n        return 0;\n      }\n      this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n      return this.scrollOffset;\n    };\n    this.getFurthestMeasurement = (measurements, index) => {\n      const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n      const furthestMeasurements = /* @__PURE__ */ new Map();\n      for (let m = index - 1; m >= 0; m--) {\n        const measurement = measurements[m];\n        if (furthestMeasurementsFound.has(measurement.lane)) {\n          continue;\n        }\n        const previousFurthestMeasurement = furthestMeasurements.get(\n          measurement.lane\n        );\n        if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n          furthestMeasurements.set(measurement.lane, measurement);\n        } else if (measurement.end < previousFurthestMeasurement.end) {\n          furthestMeasurementsFound.set(measurement.lane, true);\n        }\n        if (furthestMeasurementsFound.size === this.options.lanes) {\n          break;\n        }\n      }\n      return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b) => {\n        if (a.end === b.end) {\n          return a.index - b.index;\n        }\n        return a.end - b.end;\n      })[0] : void 0;\n    };\n    this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (count, paddingStart, scrollMargin, getItemKey, enabled) => {\n        this.pendingMeasuredCacheIndexes = [];\n        return {\n          count,\n          paddingStart,\n          scrollMargin,\n          getItemKey,\n          enabled\n        };\n      },\n      {\n        key: false\n      }\n    );\n    this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache) => {\n        if (!enabled) {\n          this.measurementsCache = [];\n          this.itemSizeCache.clear();\n          return [];\n        }\n        if (this.measurementsCache.length === 0) {\n          this.measurementsCache = this.options.initialMeasurementsCache;\n          this.measurementsCache.forEach((item) => {\n            this.itemSizeCache.set(item.key, item.size);\n          });\n        }\n        const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const measurements = this.measurementsCache.slice(0, min);\n        for (let i = min; i < count; i++) {\n          const key = getItemKey(i);\n          const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n          const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n          const measuredSize = itemSizeCache.get(key);\n          const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n          const end = start + size;\n          const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n          measurements[i] = {\n            index: i,\n            start,\n            size,\n            end,\n            key,\n            lane\n          };\n        }\n        this.measurementsCache = measurements;\n        return measurements;\n      },\n      {\n        key:  true && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    );\n    this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [\n        this.getMeasurements(),\n        this.getSize(),\n        this.getScrollOffset(),\n        this.options.lanes\n      ],\n      (measurements, outerSize, scrollOffset, lanes) => {\n        return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n          measurements,\n          outerSize,\n          scrollOffset,\n          lanes\n        }) : null;\n      },\n      {\n        key:  true && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => {\n        let startIndex = null;\n        let endIndex = null;\n        const range = this.calculateRange();\n        if (range) {\n          startIndex = range.startIndex;\n          endIndex = range.endIndex;\n        }\n        this.maybeNotify.updateDeps([this.isScrolling, startIndex, endIndex]);\n        return [\n          this.options.rangeExtractor,\n          this.options.overscan,\n          this.options.count,\n          startIndex,\n          endIndex\n        ];\n      },\n      (rangeExtractor, overscan, count, startIndex, endIndex) => {\n        return startIndex === null || endIndex === null ? [] : rangeExtractor({\n          startIndex,\n          endIndex,\n          overscan,\n          count\n        });\n      },\n      {\n        key:  true && \"getVirtualIndexes\",\n        debug: () => this.options.debug\n      }\n    );\n    this.indexFromElement = (node) => {\n      const attributeName = this.options.indexAttribute;\n      const indexStr = node.getAttribute(attributeName);\n      if (!indexStr) {\n        console.warn(\n          `Missing attribute name '${attributeName}={index}' on measured element.`\n        );\n        return -1;\n      }\n      return parseInt(indexStr, 10);\n    };\n    this._measureElement = (node, entry) => {\n      const index = this.indexFromElement(node);\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const key = item.key;\n      const prevNode = this.elementsCache.get(key);\n      if (prevNode !== node) {\n        if (prevNode) {\n          this.observer.unobserve(prevNode);\n        }\n        this.observer.observe(node);\n        this.elementsCache.set(key, node);\n      }\n      if (node.isConnected) {\n        this.resizeItem(index, this.options.measureElement(node, entry, this));\n      }\n    };\n    this.resizeItem = (index, size) => {\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return;\n      }\n      const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n      const delta = size - itemSize;\n      if (delta !== 0) {\n        if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n          if ( true && this.options.debug) {\n            console.info(\"correction\", delta);\n          }\n          this._scrollToOffset(this.getScrollOffset(), {\n            adjustments: this.scrollAdjustments += delta,\n            behavior: void 0\n          });\n        }\n        this.pendingMeasuredCacheIndexes.push(item.index);\n        this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n        this.notify(false);\n      }\n    };\n    this.measureElement = (node) => {\n      if (!node) {\n        this.elementsCache.forEach((cached, key) => {\n          if (!cached.isConnected) {\n            this.observer.unobserve(cached);\n            this.elementsCache.delete(key);\n          }\n        });\n        return;\n      }\n      this._measureElement(node, void 0);\n    };\n    this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(\n      () => [this.getVirtualIndexes(), this.getMeasurements()],\n      (indexes, measurements) => {\n        const virtualItems = [];\n        for (let k = 0, len = indexes.length; k < len; k++) {\n          const i = indexes[k];\n          const measurement = measurements[i];\n          virtualItems.push(measurement);\n        }\n        return virtualItems;\n      },\n      {\n        key:  true && \"getVirtualItems\",\n        debug: () => this.options.debug\n      }\n    );\n    this.getVirtualItemForOffset = (offset) => {\n      const measurements = this.getMeasurements();\n      if (measurements.length === 0) {\n        return void 0;\n      }\n      return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(\n        measurements[findNearestBinarySearch(\n          0,\n          measurements.length - 1,\n          (index) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start,\n          offset\n        )]\n      );\n    };\n    this.getOffsetForAlignment = (toOffset, align, itemSize = 0) => {\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n      }\n      if (align === \"center\") {\n        toOffset += (itemSize - size) / 2;\n      } else if (align === \"end\") {\n        toOffset -= size;\n      }\n      const maxOffset = this.getTotalSize() + this.options.scrollMargin - size;\n      return Math.max(Math.min(maxOffset, toOffset), 0);\n    };\n    this.getOffsetForIndex = (index, align = \"auto\") => {\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      const item = this.measurementsCache[index];\n      if (!item) {\n        return void 0;\n      }\n      const size = this.getSize();\n      const scrollOffset = this.getScrollOffset();\n      if (align === \"auto\") {\n        if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n          align = \"end\";\n        } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n          align = \"start\";\n        } else {\n          return [scrollOffset, align];\n        }\n      }\n      const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n      return [\n        this.getOffsetForAlignment(toOffset, align, item.size),\n        align\n      ];\n    };\n    this.isDynamicMode = () => this.elementsCache.size > 0;\n    this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      index = Math.max(0, Math.min(index, this.options.count - 1));\n      let attempts = 0;\n      const maxAttempts = 10;\n      const tryScroll = (currentAlign) => {\n        if (!this.targetWindow) return;\n        const offsetInfo = this.getOffsetForIndex(index, currentAlign);\n        if (!offsetInfo) {\n          console.warn(\"Failed to get offset for index:\", index);\n          return;\n        }\n        const [offset, align] = offsetInfo;\n        this._scrollToOffset(offset, { adjustments: void 0, behavior });\n        this.targetWindow.requestAnimationFrame(() => {\n          const currentOffset = this.getScrollOffset();\n          const afterInfo = this.getOffsetForIndex(index, align);\n          if (!afterInfo) {\n            console.warn(\"Failed to get offset for index:\", index);\n            return;\n          }\n          if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(afterInfo[0], currentOffset)) {\n            scheduleRetry(align);\n          }\n        });\n      };\n      const scheduleRetry = (align) => {\n        if (!this.targetWindow) return;\n        attempts++;\n        if (attempts < maxAttempts) {\n          if ( true && this.options.debug) {\n            console.info(\"Schedule retry\", attempts, maxAttempts);\n          }\n          this.targetWindow.requestAnimationFrame(() => tryScroll(align));\n        } else {\n          console.warn(\n            `Failed to scroll to index ${index} after ${maxAttempts} attempts.`\n          );\n        }\n      };\n      tryScroll(initialAlign);\n    };\n    this.scrollBy = (delta, { behavior } = {}) => {\n      if (behavior === \"smooth\" && this.isDynamicMode()) {\n        console.warn(\n          \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n        );\n      }\n      this._scrollToOffset(this.getScrollOffset() + delta, {\n        adjustments: void 0,\n        behavior\n      });\n    };\n    this.getTotalSize = () => {\n      var _a;\n      const measurements = this.getMeasurements();\n      let end;\n      if (measurements.length === 0) {\n        end = this.options.paddingStart;\n      } else if (this.options.lanes === 1) {\n        end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n      } else {\n        const endByLane = Array(this.options.lanes).fill(null);\n        let endIndex = measurements.length - 1;\n        while (endIndex >= 0 && endByLane.some((val) => val === null)) {\n          const item = measurements[endIndex];\n          if (endByLane[item.lane] === null) {\n            endByLane[item.lane] = item.end;\n          }\n          endIndex--;\n        }\n        end = Math.max(...endByLane.filter((val) => val !== null));\n      }\n      return Math.max(\n        end - this.options.scrollMargin + this.options.paddingEnd,\n        0\n      );\n    };\n    this._scrollToOffset = (offset, {\n      adjustments,\n      behavior\n    }) => {\n      this.options.scrollToFn(offset, { behavior, adjustments }, this);\n    };\n    this.measure = () => {\n      this.itemSizeCache = /* @__PURE__ */ new Map();\n      this.notify(false);\n    };\n    this.setOptions(opts);\n  }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value) => {\n  while (low <= high) {\n    const middle = (low + high) / 2 | 0;\n    const currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange({\n  measurements,\n  outerSize,\n  scrollOffset,\n  lanes\n}) {\n  const lastIndex = measurements.length - 1;\n  const getOffset = (index) => measurements[index].start;\n  if (measurements.length <= lanes) {\n    return {\n      startIndex: 0,\n      endIndex: lastIndex\n    };\n  }\n  let startIndex = findNearestBinarySearch(\n    0,\n    lastIndex,\n    getOffset,\n    scrollOffset\n  );\n  let endIndex = startIndex;\n  if (lanes === 1) {\n    while (endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize) {\n      endIndex++;\n    }\n  } else if (lanes > 1) {\n    const endPerLane = Array(lanes).fill(0);\n    while (endIndex < lastIndex && endPerLane.some((pos) => pos < scrollOffset + outerSize)) {\n      const item = measurements[endIndex];\n      endPerLane[item.lane] = item.end;\n      endIndex++;\n    }\n    const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n    while (startIndex >= 0 && startPerLane.some((pos) => pos >= scrollOffset)) {\n      const item = measurements[startIndex];\n      startPerLane[item.lane] = item.start;\n      startIndex--;\n    }\n    startIndex = Math.max(0, startIndex - startIndex % lanes);\n    endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n  }\n  return { startIndex, endIndex };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF1RTtBQUN2RTtBQUNBLFVBQVUsNEJBQTRCO0FBQ3RDLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsU0FBUyxzREFBc0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDhDQUE4QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQXdEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixtREFBUTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixtREFBUTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzRUFBc0UsbUJBQW1CO0FBQ3pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0NBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQUk7QUFDL0I7QUFDQSxTQUFTLHdEQUF3RDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhLEtBQXFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsYUFBYSxLQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0NBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjLEVBQUUsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQXFDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0NBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdURBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVEQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0QkFBNEIsSUFBSTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbUNBQW1DLHlDQUF5QyxJQUFJO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVc7QUFDMUI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFxQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5Q0FBeUMsT0FBTyxRQUFRLGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXLElBQUk7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3Q0FBd0MsdUJBQXVCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQWdCRTtBQUNGIiwic291cmNlcyI6WyIvaG9tZS9hZGVzb2xhL0Vwb2NoTGFiL0Vwb2NoRGFzaGJvYXJkL2pzL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlYm91bmNlLCBtZW1vLCBub3RVbmRlZmluZWQsIGFwcHJveEVxdWFsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNvbnN0IGdldFJlY3QgPSAoZWxlbWVudCkgPT4ge1xuICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGVsZW1lbnQ7XG4gIHJldHVybiB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfTtcbn07XG5jb25zdCBkZWZhdWx0S2V5RXh0cmFjdG9yID0gKGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IChyYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBhcnIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSk7XG4gIH07XG4gIGhhbmRsZXIoZ2V0UmVjdChlbGVtZW50KSk7XG4gIGlmICghdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IHRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgaGFuZGxlcih7IHdpZHRoOiBib3guaW5saW5lU2l6ZSwgaGVpZ2h0OiBib3guYmxvY2tTaXplIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlcihnZXRSZWN0KGVsZW1lbnQpKTtcbiAgICB9O1xuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKSA6IHJ1bigpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd1JlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYih7IHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgsIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCB9KTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBzdXBwb3J0c1Njcm9sbGVuZCA9IHR5cGVvZiB3aW5kb3cgPT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBcIm9uc2Nyb2xsZW5kXCIgaW4gd2luZG93O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kID8gKCkgPT4gdm9pZCAwIDogZGVib3VuY2UoXG4gICAgdGFyZ2V0V2luZG93LFxuICAgICgpID0+IHtcbiAgICAgIGNiKG9mZnNldCwgZmFsc2UpO1xuICAgIH0sXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXlcbiAgKTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgaXNSdGwgfSA9IGluc3RhbmNlLm9wdGlvbnM7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbCA/IGVsZW1lbnRbXCJzY3JvbGxMZWZ0XCJdICogKGlzUnRsICYmIC0xIHx8IDEpIDogZWxlbWVudFtcInNjcm9sbFRvcFwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd09mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmYWxsYmFjayA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFhcIiA6IFwic2Nyb2xsWVwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50W2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwib2Zmc2V0V2lkdGhcIiA6IFwib2Zmc2V0SGVpZ2h0XCJdO1xufTtcbmNvbnN0IHdpbmRvd1Njcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jb25zdCBlbGVtZW50U2Nyb2xsID0gKG9mZnNldCwge1xuICBhZGp1c3RtZW50cyA9IDAsXG4gIGJlaGF2aW9yXG59LCBpbnN0YW5jZSkgPT4ge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCB0b09mZnNldCA9IG9mZnNldCArIGFkanVzdG1lbnRzO1xuICAoX2IgPSAoX2EgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2Nyb2xsVG8pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgW2luc3RhbmNlLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwibGVmdFwiIDogXCJ0b3BcIl06IHRvT2Zmc2V0LFxuICAgIGJlaGF2aW9yXG4gIH0pO1xufTtcbmNsYXNzIFZpcnR1YWxpemVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudW5zdWJzID0gW107XG4gICAgdGhpcy5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLnRhcmdldFdpbmRvdyA9IG51bGw7XG4gICAgdGhpcy5pc1Njcm9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgIHRoaXMuZWxlbWVudHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IF9ybyA9IG51bGw7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChfcm8pIHtcbiAgICAgICAgICByZXR1cm4gX3JvO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cgfHwgIXRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ybyA9IG5ldyB0aGlzLnRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bikgOiBydW4oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBfcm8gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9ic2VydmUodGFyZ2V0LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVub2JzZXJ2ZTogKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMucmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuc2V0T3B0aW9ucyA9IChvcHRzMikgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMob3B0czIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSBkZWxldGUgb3B0czJba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWxPZmZzZXQ6IDAsXG4gICAgICAgIG92ZXJzY2FuOiAxLFxuICAgICAgICBwYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ0VuZDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIGdldEl0ZW1LZXk6IGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gICAgICAgIHJhbmdlRXh0cmFjdG9yOiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVFbGVtZW50LFxuICAgICAgICBpbml0aWFsUmVjdDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIHNjcm9sbE1hcmdpbjogMCxcbiAgICAgICAgZ2FwOiAwLFxuICAgICAgICBpbmRleEF0dHJpYnV0ZTogXCJkYXRhLWluZGV4XCIsXG4gICAgICAgIGluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTogW10sXG4gICAgICAgIGxhbmVzOiAxLFxuICAgICAgICBpc1Njcm9sbGluZ1Jlc2V0RGVsYXk6IDE1MCxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaXNSdGw6IGZhbHNlLFxuICAgICAgICB1c2VTY3JvbGxlbmRFdmVudDogZmFsc2UsXG4gICAgICAgIHVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0czJcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vdGlmeSA9IChzeW5jKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgIH07XG4gICAgdGhpcy5tYXliZU5vdGlmeSA9IG1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChpc1Njcm9sbGluZykgPT4ge1xuICAgICAgICB0aGlzLm5vdGlmeShpc1Njcm9sbGluZyk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcIm1heWJlTm90aWZ5XCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICAgIGluaXRpYWxEZXBzOiBbXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5lbmRJbmRleCA6IG51bGxcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5fZGlkTW91bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5lbmFibGVkID8gdGhpcy5vcHRpb25zLmdldFNjcm9sbEVsZW1lbnQoKSA6IG51bGw7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgJiYgXCJvd25lckRvY3VtZW50XCIgaW4gdGhpcy5zY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9ICgoX2EgPSB0aGlzLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS53aW5kb3cpID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShjYWNoZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRSZWN0KHRoaXMsIChyZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50T2Zmc2V0KHRoaXMsIChvZmZzZXQsIGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gaXNTY3JvbGxpbmcgPyB0aGlzLmdldFNjcm9sbE9mZnNldCgpIDwgb2Zmc2V0ID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gaXNTY3JvbGxpbmc7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbFJlY3QgPSB0aGlzLnNjcm9sbFJlY3QgPz8gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxPZmZzZXQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMuc2Nyb2xsT2Zmc2V0ID8/ICh0eXBlb2YgdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KCkgOiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxPZmZzZXQ7XG4gICAgfTtcbiAgICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSAobWVhc3VyZW1lbnRzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1ttXTtcbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID0gZnVydGhlc3RNZWFzdXJlbWVudHMuZ2V0KFxuICAgICAgICAgIG1lYXN1cmVtZW50LmxhbmVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9PSBudWxsIHx8IG1lYXN1cmVtZW50LmVuZCA+IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zZXQobWVhc3VyZW1lbnQubGFuZSwgbWVhc3VyZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNldChtZWFzdXJlbWVudC5sYW5lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEuZW5kID09PSBiLmVuZCkge1xuICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lbmQgLSBiLmVuZDtcbiAgICAgIH0pWzBdIDogdm9pZCAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5LFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZFxuICAgICAgXSxcbiAgICAgIChjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBwYWRkaW5nU3RhcnQsXG4gICAgICAgICAgc2Nyb2xsTWFyZ2luLFxuICAgICAgICAgIGdldEl0ZW1LZXksXG4gICAgICAgICAgZW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBmYWxzZVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRPcHRpb25zKCksIHRoaXMuaXRlbVNpemVDYWNoZV0sXG4gICAgICAoeyBjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQgfSwgaXRlbVNpemVDYWNoZSkgPT4ge1xuICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVtZW50c0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSB0aGlzLm9wdGlvbnMuaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlO1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgaXRlbS5zaXplKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4oLi4udGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMpIDogMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5zbGljZSgwLCBtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gbWluOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGdldEl0ZW1LZXkoaSk7XG4gICAgICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/IG1lYXN1cmVtZW50c1tpIC0gMV0gOiB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQobWVhc3VyZW1lbnRzLCBpKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCArIHRoaXMub3B0aW9ucy5nYXAgOiBwYWRkaW5nU3RhcnQgKyBzY3JvbGxNYXJnaW47XG4gICAgICAgICAgY29uc3QgbWVhc3VyZWRTaXplID0gaXRlbVNpemVDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICBjb25zdCBzaXplID0gdHlwZW9mIG1lYXN1cmVkU2l6ZSA9PT0gXCJudW1iZXJcIiA/IG1lYXN1cmVkU2l6ZSA6IHRoaXMub3B0aW9ucy5lc3RpbWF0ZVNpemUoaSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBzaXplO1xuICAgICAgICAgIGNvbnN0IGxhbmUgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lIDogaSAlIHRoaXMub3B0aW9ucy5sYW5lcztcbiAgICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHM7XG4gICAgICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldE1lYXN1cmVtZW50c1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVJhbmdlID0gbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGhpcy5nZXRNZWFzdXJlbWVudHMoKSxcbiAgICAgICAgdGhpcy5nZXRTaXplKCksXG4gICAgICAgIHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksXG4gICAgICAgIHRoaXMub3B0aW9ucy5sYW5lc1xuICAgICAgXSxcbiAgICAgIChtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0LCBsYW5lcykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgIG91dGVyU2l6ZSxcbiAgICAgICAgICBzY3JvbGxPZmZzZXQsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJjYWxjdWxhdGVSYW5nZVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldFZpcnR1YWxJbmRleGVzID0gbWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBudWxsO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBudWxsO1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heWJlTm90aWZ5LnVwZGF0ZURlcHMoW3RoaXMuaXNTY3JvbGxpbmcsIHN0YXJ0SW5kZXgsIGVuZEluZGV4XSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnJhbmdlRXh0cmFjdG9yLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vdmVyc2NhbixcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChyYW5nZUV4dHJhY3Rvciwgb3ZlcnNjYW4sIGNvdW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RhcnRJbmRleCA9PT0gbnVsbCB8fCBlbmRJbmRleCA9PT0gbnVsbCA/IFtdIDogcmFuZ2VFeHRyYWN0b3Ioe1xuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kSW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgY291bnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldFZpcnR1YWxJbmRleGVzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuaW5kZXhGcm9tRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5vcHRpb25zLmluZGV4QXR0cmlidXRlO1xuICAgICAgY29uc3QgaW5kZXhTdHIgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmICghaW5kZXhTdHIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lICcke2F0dHJpYnV0ZU5hbWV9PXtpbmRleH0nIG9uIG1lYXN1cmVkIGVsZW1lbnQuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VJbnQoaW5kZXhTdHIsIDEwKTtcbiAgICB9O1xuICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gKG5vZGUsIGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhGcm9tRWxlbWVudChub2RlKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5lbGVtZW50c0NhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5zZXQoa2V5LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplSXRlbShpbmRleCwgdGhpcy5vcHRpb25zLm1lYXN1cmVFbGVtZW50KG5vZGUsIGVudHJ5LCB0aGlzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZUl0ZW0gPSAoaW5kZXgsIHNpemUpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemVDYWNoZS5nZXQoaXRlbS5rZXkpID8/IGl0ZW0uc2l6ZTtcbiAgICAgIGNvbnN0IGRlbHRhID0gc2l6ZSAtIGl0ZW1TaXplO1xuICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZSAhPT0gdm9pZCAwID8gdGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UoaXRlbSwgZGVsdGEsIHRoaXMpIDogaXRlbS5zdGFydCA8IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyB0aGlzLnNjcm9sbEFkanVzdG1lbnRzKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImNvcnJlY3Rpb25cIiwgZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpLCB7XG4gICAgICAgICAgICBhZGp1c3RtZW50czogdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICAgIGJlaGF2aW9yOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5wdXNoKGl0ZW0uaW5kZXgpO1xuICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKHRoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIHNpemUpKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmZvckVhY2goKGNhY2hlZCwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKCFjYWNoZWQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKGNhY2hlZCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQobm9kZSwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1zID0gbWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldFZpcnR1YWxJbmRleGVzKCksIHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCldLFxuICAgICAgKGluZGV4ZXMsIG1lYXN1cmVtZW50cykgPT4ge1xuICAgICAgICBjb25zdCB2aXJ0dWFsSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGluZGV4ZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBpID0gaW5kZXhlc1trXTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICAgICAgICB2aXJ0dWFsSXRlbXMucHVzaChtZWFzdXJlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0VmlydHVhbEl0ZW1zXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RVbmRlZmluZWQoXG4gICAgICAgIG1lYXN1cmVtZW50c1tmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaChcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1lYXN1cmVtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgIChpbmRleCkgPT4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tpbmRleF0pLnN0YXJ0LFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICApXVxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50ID0gKHRvT2Zmc2V0LCBhbGlnbiwgaXRlbVNpemUgPSAwKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmdldFNjcm9sbE9mZnNldCgpO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBhbGlnbiA9IHRvT2Zmc2V0ID49IHNjcm9sbE9mZnNldCArIHNpemUgPyBcImVuZFwiIDogXCJzdGFydFwiO1xuICAgICAgfVxuICAgICAgaWYgKGFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ICs9IChpdGVtU2l6ZSAtIHNpemUpIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgLT0gc2l6ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heE9mZnNldCA9IHRoaXMuZ2V0VG90YWxTaXplKCkgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsTWFyZ2luIC0gc2l6ZTtcbiAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihtYXhPZmZzZXQsIHRvT2Zmc2V0KSwgMCk7XG4gICAgfTtcbiAgICB0aGlzLmdldE9mZnNldEZvckluZGV4ID0gKGluZGV4LCBhbGlnbiA9IFwiYXV0b1wiKSA9PiB7XG4gICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLm9wdGlvbnMuY291bnQgLSAxKSk7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZVtpbmRleF07XG4gICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICBpZiAoYWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGlmIChpdGVtLmVuZCA+PSBzY3JvbGxPZmZzZXQgKyBzaXplIC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQpIHtcbiAgICAgICAgICBhbGlnbiA9IFwiZW5kXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5zdGFydCA8PSBzY3JvbGxPZmZzZXQgKyB0aGlzLm9wdGlvbnMuc2Nyb2xsUGFkZGluZ1N0YXJ0KSB7XG4gICAgICAgICAgYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtzY3JvbGxPZmZzZXQsIGFsaWduXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdG9PZmZzZXQgPSBhbGlnbiA9PT0gXCJlbmRcIiA/IGl0ZW0uZW5kICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdFbmQgOiBpdGVtLnN0YXJ0IC0gdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50KHRvT2Zmc2V0LCBhbGlnbiwgaXRlbS5zaXplKSxcbiAgICAgICAgYWxpZ25cbiAgICAgIF07XG4gICAgfTtcbiAgICB0aGlzLmlzRHluYW1pY01vZGUgPSAoKSA9PiB0aGlzLmVsZW1lbnRzQ2FjaGUuc2l6ZSA+IDA7XG4gICAgdGhpcy5zY3JvbGxUb09mZnNldCA9ICh0b09mZnNldCwgeyBhbGlnbiA9IFwic3RhcnRcIiwgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24pLCB7XG4gICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgIGJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsVG9JbmRleCA9IChpbmRleCwgeyBhbGlnbjogaW5pdGlhbEFsaWduID0gXCJhdXRvXCIsIGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gMTA7XG4gICAgICBjb25zdCB0cnlTY3JvbGwgPSAoY3VycmVudEFsaWduKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cpIHJldHVybjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0SW5mbyA9IHRoaXMuZ2V0T2Zmc2V0Rm9ySW5kZXgoaW5kZXgsIGN1cnJlbnRBbGlnbik7XG4gICAgICAgIGlmICghb2Zmc2V0SW5mbykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBnZXQgb2Zmc2V0IGZvciBpbmRleDpcIiwgaW5kZXgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb2Zmc2V0LCBhbGlnbl0gPSBvZmZzZXRJbmZvO1xuICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldChvZmZzZXQsIHsgYWRqdXN0bWVudHM6IHZvaWQgMCwgYmVoYXZpb3IgfSk7XG4gICAgICAgIHRoaXMudGFyZ2V0V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY3VycmVudE9mZnNldCA9IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgY29uc3QgYWZ0ZXJJbmZvID0gdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgYWxpZ24pO1xuICAgICAgICAgIGlmICghYWZ0ZXJJbmZvKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZ2V0IG9mZnNldCBmb3IgaW5kZXg6XCIsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFhcHByb3hFcXVhbChhZnRlckluZm9bMF0sIGN1cnJlbnRPZmZzZXQpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZVJldHJ5KGFsaWduKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjaGVkdWxlUmV0cnkgPSAoYWxpZ24pID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldFdpbmRvdykgcmV0dXJuO1xuICAgICAgICBhdHRlbXB0cysrO1xuICAgICAgICBpZiAoYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJTY2hlZHVsZSByZXRyeVwiLCBhdHRlbXB0cywgbWF4QXR0ZW1wdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdHJ5U2Nyb2xsKGFsaWduKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBzY3JvbGwgdG8gaW5kZXggJHtpbmRleH0gYWZ0ZXIgJHttYXhBdHRlbXB0c30gYXR0ZW1wdHMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0cnlTY3JvbGwoaW5pdGlhbEFsaWduKTtcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQnkgPSAoZGVsdGEsIHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBpZiAoYmVoYXZpb3IgPT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiVGhlIGBzbW9vdGhgIHNjcm9sbCBiZWhhdmlvciBpcyBub3QgZnVsbHkgc3VwcG9ydGVkIHdpdGggZHluYW1pYyBzaXplLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpICsgZGVsdGEsIHtcbiAgICAgICAgYWRqdXN0bWVudHM6IHZvaWQgMCxcbiAgICAgICAgYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5nZXRUb3RhbFNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgbGV0IGVuZDtcbiAgICAgIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVuZCA9IHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSkge1xuICAgICAgICBlbmQgPSAoKF9hID0gbWVhc3VyZW1lbnRzW21lYXN1cmVtZW50cy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmVuZCkgPz8gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVuZEJ5TGFuZSA9IEFycmF5KHRoaXMub3B0aW9ucy5sYW5lcykuZmlsbChudWxsKTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChlbmRJbmRleCA+PSAwICYmIGVuZEJ5TGFuZS5zb21lKCh2YWwpID0+IHZhbCA9PT0gbnVsbCkpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gbWVhc3VyZW1lbnRzW2VuZEluZGV4XTtcbiAgICAgICAgICBpZiAoZW5kQnlMYW5lW2l0ZW0ubGFuZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVuZEJ5TGFuZVtpdGVtLmxhbmVdID0gaXRlbS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZEluZGV4LS07XG4gICAgICAgIH1cbiAgICAgICAgZW5kID0gTWF0aC5tYXgoLi4uZW5kQnlMYW5lLmZpbHRlcigodmFsKSA9PiB2YWwgIT09IG51bGwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgICAgZW5kIC0gdGhpcy5vcHRpb25zLnNjcm9sbE1hcmdpbiArIHRoaXMub3B0aW9ucy5wYWRkaW5nRW5kLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH07XG4gICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQgPSAob2Zmc2V0LCB7XG4gICAgICBhZGp1c3RtZW50cyxcbiAgICAgIGJlaGF2aW9yXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5vcHRpb25zLnNjcm9sbFRvRm4ob2Zmc2V0LCB7IGJlaGF2aW9yLCBhZGp1c3RtZW50cyB9LCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMubWVhc3VyZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXRlbVNpemVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vdGlmeShmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0cyk7XG4gIH1cbn1cbmNvbnN0IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoID0gKGxvdywgaGlnaCwgZ2V0Q3VycmVudFZhbHVlLCB2YWx1ZSkgPT4ge1xuICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICBjb25zdCBtaWRkbGUgPSAobG93ICsgaGlnaCkgLyAyIHwgMDtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBnZXRDdXJyZW50VmFsdWUobWlkZGxlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgdmFsdWUpIHtcbiAgICAgIGxvdyA9IG1pZGRsZSArIDE7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsdWUgPiB2YWx1ZSkge1xuICAgICAgaGlnaCA9IG1pZGRsZSAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgfVxuICB9XG4gIGlmIChsb3cgPiAwKSB7XG4gICAgcmV0dXJuIGxvdyAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVSYW5nZSh7XG4gIG1lYXN1cmVtZW50cyxcbiAgb3V0ZXJTaXplLFxuICBzY3JvbGxPZmZzZXQsXG4gIGxhbmVzXG59KSB7XG4gIGNvbnN0IGxhc3RJbmRleCA9IG1lYXN1cmVtZW50cy5sZW5ndGggLSAxO1xuICBjb25zdCBnZXRPZmZzZXQgPSAoaW5kZXgpID0+IG1lYXN1cmVtZW50c1tpbmRleF0uc3RhcnQ7XG4gIGlmIChtZWFzdXJlbWVudHMubGVuZ3RoIDw9IGxhbmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0SW5kZXg6IDAsXG4gICAgICBlbmRJbmRleDogbGFzdEluZGV4XG4gICAgfTtcbiAgfVxuICBsZXQgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgIDAsXG4gICAgbGFzdEluZGV4LFxuICAgIGdldE9mZnNldCxcbiAgICBzY3JvbGxPZmZzZXRcbiAgKTtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgaWYgKGxhbmVzID09PSAxKSB7XG4gICAgd2hpbGUgKGVuZEluZGV4IDwgbGFzdEluZGV4ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgICBlbmRJbmRleCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsYW5lcyA+IDEpIHtcbiAgICBjb25zdCBlbmRQZXJMYW5lID0gQXJyYXkobGFuZXMpLmZpbGwoMCk7XG4gICAgd2hpbGUgKGVuZEluZGV4IDwgbGFzdEluZGV4ICYmIGVuZFBlckxhbmUuc29tZSgocG9zKSA9PiBwb3MgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWVhc3VyZW1lbnRzW2VuZEluZGV4XTtcbiAgICAgIGVuZFBlckxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uZW5kO1xuICAgICAgZW5kSW5kZXgrKztcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRQZXJMYW5lID0gQXJyYXkobGFuZXMpLmZpbGwoc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKTtcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0UGVyTGFuZS5zb21lKChwb3MpID0+IHBvcyA+PSBzY3JvbGxPZmZzZXQpKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWVhc3VyZW1lbnRzW3N0YXJ0SW5kZXhdO1xuICAgICAgc3RhcnRQZXJMYW5lW2l0ZW0ubGFuZV0gPSBpdGVtLnN0YXJ0O1xuICAgICAgc3RhcnRJbmRleC0tO1xuICAgIH1cbiAgICBzdGFydEluZGV4ID0gTWF0aC5tYXgoMCwgc3RhcnRJbmRleCAtIHN0YXJ0SW5kZXggJSBsYW5lcyk7XG4gICAgZW5kSW5kZXggPSBNYXRoLm1pbihsYXN0SW5kZXgsIGVuZEluZGV4ICsgKGxhbmVzIC0gMSAtIGVuZEluZGV4ICUgbGFuZXMpKTtcbiAgfVxuICByZXR1cm4geyBzdGFydEluZGV4LCBlbmRJbmRleCB9O1xufVxuZXhwb3J0IHtcbiAgVmlydHVhbGl6ZXIsXG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgZGVmYXVsdEtleUV4dHJhY3RvcixcbiAgZGVmYXVsdFJhbmdlRXh0cmFjdG9yLFxuICBlbGVtZW50U2Nyb2xsLFxuICBtZWFzdXJlRWxlbWVudCxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkLFxuICBvYnNlcnZlRWxlbWVudE9mZnNldCxcbiAgb2JzZXJ2ZUVsZW1lbnRSZWN0LFxuICBvYnNlcnZlV2luZG93T2Zmc2V0LFxuICBvYnNlcnZlV2luZG93UmVjdCxcbiAgd2luZG93U2Nyb2xsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n  let deps = opts.initialDeps ?? [];\n  let result;\n  function memoizedFunction() {\n    var _a, _b, _c, _d;\n    let depTime;\n    if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n    const newDeps = getDeps();\n    const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index) => deps[index] !== dep);\n    if (!depsChanged) {\n      return result;\n    }\n    deps = newDeps;\n    let resultTime;\n    if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n    result = fn(...newDeps);\n    if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n      const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n      const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n      const resultFpsPercentage = resultEndTime / 16;\n      const pad = (str, num) => {\n        str = String(str);\n        while (str.length < num) {\n          str = \" \" + str;\n        }\n        return str;\n      };\n      console.info(\n        `%c ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * resultFpsPercentage, 120)\n        )}deg 100% 31%);`,\n        opts == null ? void 0 : opts.key\n      );\n    }\n    (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n    return result;\n  }\n  memoizedFunction.updateDeps = (newDeps) => {\n    deps = newDeps;\n  };\n  return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n  if (value === void 0) {\n    throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n  } else {\n    return value;\n  }\n}\nconst approxEqual = (a, b) => Math.abs(a - b) < 1.01;\nconst debounce = (targetWindow, fn, ms) => {\n  let timeoutId;\n  return function(...args) {\n    targetWindow.clearTimeout(timeoutId);\n    timeoutId = targetWindow.setTimeout(() => fn.apply(this, args), ms);\n  };\n};\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCLEdBQUcsb0JBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVcsSUFBSSxPQUFPO0FBQ2pFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBtZW1vKGdldERlcHMsIGZuLCBvcHRzKSB7XG4gIGxldCBkZXBzID0gb3B0cy5pbml0aWFsRGVwcyA/PyBbXTtcbiAgbGV0IHJlc3VsdDtcbiAgZnVuY3Rpb24gbWVtb2l6ZWRGdW5jdGlvbigpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgbGV0IGRlcFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2EgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRzKSkpIGRlcFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IG5ld0RlcHMgPSBnZXREZXBzKCk7XG4gICAgY29uc3QgZGVwc0NoYW5nZWQgPSBuZXdEZXBzLmxlbmd0aCAhPT0gZGVwcy5sZW5ndGggfHwgbmV3RGVwcy5zb21lKChkZXAsIGluZGV4KSA9PiBkZXBzW2luZGV4XSAhPT0gZGVwKTtcbiAgICBpZiAoIWRlcHNDaGFuZ2VkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBkZXBzID0gbmV3RGVwcztcbiAgICBsZXQgcmVzdWx0VGltZTtcbiAgICBpZiAob3B0cy5rZXkgJiYgKChfYiA9IG9wdHMuZGVidWcpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKG9wdHMpKSkgcmVzdWx0VGltZSA9IERhdGUubm93KCk7XG4gICAgcmVzdWx0ID0gZm4oLi4ubmV3RGVwcyk7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2MgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRzKSkpIHtcbiAgICAgIGNvbnN0IGRlcEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gZGVwVGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RW5kVGltZSA9IE1hdGgucm91bmQoKERhdGUubm93KCkgLSByZXN1bHRUaW1lKSAqIDEwMCkgLyAxMDA7XG4gICAgICBjb25zdCByZXN1bHRGcHNQZXJjZW50YWdlID0gcmVzdWx0RW5kVGltZSAvIDE2O1xuICAgICAgY29uc3QgcGFkID0gKHN0ciwgbnVtKSA9PiB7XG4gICAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAgIHN0ciA9IFwiIFwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9O1xuICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICBgJWPij7EgJHtwYWQocmVzdWx0RW5kVGltZSwgNSl9IC8ke3BhZChkZXBFbmRUaW1lLCA1KX0gbXNgLFxuICAgICAgICBgXG4gICAgICAgICAgICBmb250LXNpemU6IC42cmVtO1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICBjb2xvcjogaHNsKCR7TWF0aC5tYXgoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLm1pbigxMjAgLSAxMjAgKiByZXN1bHRGcHNQZXJjZW50YWdlLCAxMjApXG4gICAgICAgICl9ZGVnIDEwMCUgMzElKTtgLFxuICAgICAgICBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmtleVxuICAgICAgKTtcbiAgICB9XG4gICAgKF9kID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNhbGwob3B0cywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIG1lbW9pemVkRnVuY3Rpb24udXBkYXRlRGVwcyA9IChuZXdEZXBzKSA9PiB7XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gIH07XG4gIHJldHVybiBtZW1vaXplZEZ1bmN0aW9uO1xufVxuZnVuY3Rpb24gbm90VW5kZWZpbmVkKHZhbHVlLCBtc2cpIHtcbiAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdW5kZWZpbmVkJHttc2cgPyBgOiAke21zZ31gIDogXCJcIn1gKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmNvbnN0IGFwcHJveEVxdWFsID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKSA8IDEuMDE7XG5jb25zdCBkZWJvdW5jZSA9ICh0YXJnZXRXaW5kb3csIGZuLCBtcykgPT4ge1xuICBsZXQgdGltZW91dElkO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIHRhcmdldFdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSB0YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKSwgbXMpO1xuICB9O1xufTtcbmV4cG9ydCB7XG4gIGFwcHJveEVxdWFsLFxuICBkZWJvdW5jZSxcbiAgbWVtbyxcbiAgbm90VW5kZWZpbmVkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/clsx/dist/clsx.mjs":
/*!*****************************************!*\
  !*** ./node_modules/clsx/dist/clsx.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clsx: () => (/* binding */ clsx),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clsx);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxjQUFjLGFBQWEsK0NBQStDLGdEQUFnRCxlQUFlLFFBQVEsSUFBSSwwQ0FBMEMseUNBQXlDLFNBQWdCLGdCQUFnQix3Q0FBd0MsSUFBSSxtREFBbUQsU0FBUyxpRUFBZSxJQUFJIiwic291cmNlcyI6WyIvaG9tZS9hZGVzb2xhL0Vwb2NoTGFiL0Vwb2NoRGFzaGJvYXJkL2pzL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpe3ZhciBvPWUubGVuZ3RoO2Zvcih0PTA7dDxvO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zil9ZWxzZSBmb3IoZiBpbiBlKWVbZl0mJihuJiYobis9XCIgXCIpLG4rPWYpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIixvPWFyZ3VtZW50cy5sZW5ndGg7ZjxvO2YrKykoZT1hcmd1bWVudHNbZl0pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/clsx/dist/clsx.mjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/ms/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fadesola%2FEpochLab%2FEpochDashboard%2Fjs%2Fpages%2Findex.tsx&page=%2F!":
/*!************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fadesola%2FEpochLab%2FEpochDashboard%2Fjs%2Fpages%2Findex.tsx&page=%2F! ***!
  \************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.tsx */ \"(pages-dir-browser)/./pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPSUyRmhvbWUlMkZhZGVzb2xhJTJGRXBvY2hMYWIlMkZFcG9jaERhc2hib2FyZCUyRmpzJTJGcGFnZXMlMkZpbmRleC50c3gmcGFnZT0lMkYhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsZ0VBQW1CO0FBQzFDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vcGFnZXMvaW5kZXgudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fadesola%2FEpochLab%2FEpochDashboard%2Fjs%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/index.tsx":
/*!*************************!*\
  !*** ./pages/index.tsx ***!
  \*************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HomePage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _src_examples_components_Navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/examples/components/Navigation */ \"(pages-dir-browser)/./src/examples/components/Navigation.tsx\");\n/* harmony import */ var _src_examples_pages_CardExample__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/examples/pages/CardExample */ \"(pages-dir-browser)/./src/examples/pages/CardExample.tsx\");\n/* harmony import */ var _src_examples_pages_TableExample__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/examples/pages/TableExample */ \"(pages-dir-browser)/./src/examples/pages/TableExample.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nfunction HomePage() {\n    _s();\n    const [currentView, setCurrentView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('card');\n    const renderView = ()=>{\n        switch(currentView){\n            case 'card':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_examples_pages_CardExample__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 12,\n                    columnNumber: 16\n                }, this);\n            case 'table':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_examples_pages_TableExample__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 14,\n                    columnNumber: 16\n                }, this);\n            case 'line':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Line chart coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 16,\n                    columnNumber: 16\n                }, this);\n            case 'bar':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Bar chart coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 18,\n                    columnNumber: 16\n                }, this);\n            case 'heatmap':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Heatmap coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 20,\n                    columnNumber: 16\n                }, this);\n            case 'histogram':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Histogram coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 22,\n                    columnNumber: 16\n                }, this);\n            case 'boxplot':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Box plot coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 16\n                }, this);\n            case 'xrange':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"X-Range coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 26,\n                    columnNumber: 16\n                }, this);\n            case 'pie':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Pie chart coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 28,\n                    columnNumber: 16\n                }, this);\n            case 'full':\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-secondary-ashGrey\",\n                    children: \"Full dashboard coming soon...\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 30,\n                    columnNumber: 16\n                }, this);\n            default:\n                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_examples_pages_CardExample__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 32,\n                    columnNumber: 16\n                }, this);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex min-h-screen bg-secondary-darkGray\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_src_examples_components_Navigation__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                currentView: currentView,\n                onNavigate: setCurrentView\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                lineNumber: 38,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: \"flex-1 p-8\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"max-w-6xl\",\n                    children: renderView()\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                    lineNumber: 41,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/pages/index.tsx\",\n        lineNumber: 37,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"7Xy3FJwiPY280U1u4Kox385MLh4=\");\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2luZGV4LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWdDO0FBQzhCO0FBQ0g7QUFDRTtBQUU5QyxTQUFTSTs7SUFDdEIsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdOLCtDQUFRQSxDQUFDO0lBRS9DLE1BQU1PLGFBQWE7UUFDakIsT0FBUUY7WUFDTixLQUFLO2dCQUNILHFCQUFPLDhEQUFDSCx1RUFBV0E7Ozs7O1lBQ3JCLEtBQUs7Z0JBQ0gscUJBQU8sOERBQUNDLHdFQUFZQTs7Ozs7WUFDdEIsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0s7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQsS0FBSztnQkFDSCxxQkFBTyw4REFBQ0Q7b0JBQUlDLFdBQVU7OEJBQXlCOzs7Ozs7WUFDakQ7Z0JBQ0UscUJBQU8sOERBQUNQLHVFQUFXQTs7Ozs7UUFDdkI7SUFDRjtJQUVBLHFCQUNFLDhEQUFDTTtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ1IsMkVBQVVBO2dCQUFDSSxhQUFhQTtnQkFBYUssWUFBWUo7Ozs7OzswQkFFbEQsOERBQUNLO2dCQUFLRixXQUFVOzBCQUNkLDRFQUFDRDtvQkFBSUMsV0FBVTs4QkFDWkY7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS1g7R0F6Q3dCSDtLQUFBQSIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9wYWdlcy9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4uL3NyYy9leGFtcGxlcy9jb21wb25lbnRzL05hdmlnYXRpb24nXG5pbXBvcnQgQ2FyZEV4YW1wbGUgZnJvbSAnLi4vc3JjL2V4YW1wbGVzL3BhZ2VzL0NhcmRFeGFtcGxlJ1xuaW1wb3J0IFRhYmxlRXhhbXBsZSBmcm9tICcuLi9zcmMvZXhhbXBsZXMvcGFnZXMvVGFibGVFeGFtcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lUGFnZSgpIHtcbiAgY29uc3QgW2N1cnJlbnRWaWV3LCBzZXRDdXJyZW50Vmlld10gPSB1c2VTdGF0ZSgnY2FyZCcpXG5cbiAgY29uc3QgcmVuZGVyVmlldyA9ICgpID0+IHtcbiAgICBzd2l0Y2ggKGN1cnJlbnRWaWV3KSB7XG4gICAgICBjYXNlICdjYXJkJzpcbiAgICAgICAgcmV0dXJuIDxDYXJkRXhhbXBsZSAvPlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gPFRhYmxlRXhhbXBsZSAvPlxuICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj5MaW5lIGNoYXJ0IGNvbWluZyBzb29uLi4uPC9kaXY+XG4gICAgICBjYXNlICdiYXInOlxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+QmFyIGNoYXJ0IGNvbWluZyBzb29uLi4uPC9kaXY+XG4gICAgICBjYXNlICdoZWF0bWFwJzpcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zZWNvbmRhcnktYXNoR3JleVwiPkhlYXRtYXAgY29taW5nIHNvb24uLi48L2Rpdj5cbiAgICAgIGNhc2UgJ2hpc3RvZ3JhbSc6XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj5IaXN0b2dyYW0gY29taW5nIHNvb24uLi48L2Rpdj5cbiAgICAgIGNhc2UgJ2JveHBsb3QnOlxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+Qm94IHBsb3QgY29taW5nIHNvb24uLi48L2Rpdj5cbiAgICAgIGNhc2UgJ3hyYW5nZSc6XG4gICAgICAgIHJldHVybiA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj5YLVJhbmdlIGNvbWluZyBzb29uLi4uPC9kaXY+XG4gICAgICBjYXNlICdwaWUnOlxuICAgICAgICByZXR1cm4gPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+UGllIGNoYXJ0IGNvbWluZyBzb29uLi4uPC9kaXY+XG4gICAgICBjYXNlICdmdWxsJzpcbiAgICAgICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zZWNvbmRhcnktYXNoR3JleVwiPkZ1bGwgZGFzaGJvYXJkIGNvbWluZyBzb29uLi4uPC9kaXY+XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gPENhcmRFeGFtcGxlIC8+XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggbWluLWgtc2NyZWVuIGJnLXNlY29uZGFyeS1kYXJrR3JheVwiPlxuICAgICAgPE5hdmlnYXRpb24gY3VycmVudFZpZXc9e2N1cnJlbnRWaWV3fSBvbk5hdmlnYXRlPXtzZXRDdXJyZW50Vmlld30gLz5cblxuICAgICAgPG1haW4gY2xhc3NOYW1lPVwiZmxleC0xIHAtOFwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTZ4bFwiPlxuICAgICAgICAgIHtyZW5kZXJWaWV3KCl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9tYWluPlxuICAgIDwvZGl2PlxuICApXG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwiTmF2aWdhdGlvbiIsIkNhcmRFeGFtcGxlIiwiVGFibGVFeGFtcGxlIiwiSG9tZVBhZ2UiLCJjdXJyZW50VmlldyIsInNldEN1cnJlbnRWaWV3IiwicmVuZGVyVmlldyIsImRpdiIsImNsYXNzTmFtZSIsIm9uTmF2aWdhdGUiLCJtYWluIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/index.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/components/Card.tsx":
/*!*********************************!*\
  !*** ./src/components/Card.tsx ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types_proto__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types/proto */ \"(pages-dir-browser)/./src/types/proto.ts\");\n/* harmony import */ var _utils_protoHelpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/protoHelpers */ \"(pages-dir-browser)/./src/utils/protoHelpers.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\nconst Card = (param)=>{\n    let { cardDef, className = '' } = param;\n    var _groupedCardData_groups;\n    _s();\n    const groupedCardData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"Card.useMemo[groupedCardData]\": ()=>{\n            if (!(cardDef === null || cardDef === void 0 ? void 0 : cardDef.data) || !Array.isArray(cardDef.data) || cardDef.data.length === 0) {\n                return undefined;\n            }\n            const cardDataArray = cardDef.data;\n            const groupedCards = [];\n            const groupNumbers = Array.from(new Set(cardDataArray.map({\n                \"Card.useMemo[groupedCardData].groupNumbers\": (c)=>c.group\n            }[\"Card.useMemo[groupedCardData].groupNumbers\"]))).sort({\n                \"Card.useMemo[groupedCardData].groupNumbers\": (a, b)=>{\n                    if (a === undefined || a === null) return 1;\n                    if (b === undefined || b === null) return -1;\n                    return Number(a) - Number(b);\n                }\n            }[\"Card.useMemo[groupedCardData].groupNumbers\"]);\n            for (const groupNum of groupNumbers){\n                const group = cardDataArray.filter({\n                    \"Card.useMemo[groupedCardData].group\": (card)=>card.group === groupNum\n                }[\"Card.useMemo[groupedCardData].group\"]);\n                if (group.length > 0) {\n                    groupedCards.push(group);\n                }\n            }\n            return {\n                groups: groupedCards,\n                category: cardDef.category\n            };\n        }\n    }[\"Card.useMemo[groupedCardData]\"], [\n        cardDef\n    ]);\n    const formatCardValue = (cardData)=>{\n        const scalarValue = (0,_utils_protoHelpers__WEBPACK_IMPORTED_MODULE_3__.getScalarValue)(cardData.value);\n        if (scalarValue === null || scalarValue === undefined) {\n            return '-';\n        }\n        if (typeof scalarValue === 'boolean') {\n            return scalarValue ? 'Yes' : 'No';\n        }\n        const type = cardData.type || _types_proto__WEBPACK_IMPORTED_MODULE_2__.EpochFolioType.TypeString;\n        return (0,_utils_protoHelpers__WEBPACK_IMPORTED_MODULE_3__.formatScalarByType)(cardData.value, type);\n    };\n    if (!(groupedCardData === null || groupedCardData === void 0 ? void 0 : (_groupedCardData_groups = groupedCardData.groups) === null || _groupedCardData_groups === void 0 ? void 0 : _groupedCardData_groups.length)) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex h-fit flex-col items-start gap-5 rounded-2 border border-primary-white/5 bg-primary-white/2 p-5 \".concat(className),\n        children: groupedCardData.groups.map((group, groupIndex)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex w-full flex-col gap-5\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-2 gap-x-2.5 gap-y-5\",\n                        children: group.map((cardData, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col items-start gap-1.25\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-xs font-normal text-secondary-ashGrey m-0\",\n                                        children: cardData.title\n                                    }, void 0, false, {\n                                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                                        lineNumber: 76,\n                                        columnNumber: 17\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"text-lg font-normal text-primary-white m-0\",\n                                        children: formatCardValue(cardData)\n                                    }, void 0, false, {\n                                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                                        lineNumber: 79,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, index, true, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                                lineNumber: 72,\n                                columnNumber: 15\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                        lineNumber: 70,\n                        columnNumber: 11\n                    }, undefined),\n                    groupIndex < groupedCardData.groups.length - 1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"h-px w-full bg-primary-white/10\"\n                    }, void 0, false, {\n                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                        lineNumber: 86,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, groupIndex, true, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n                lineNumber: 69,\n                columnNumber: 9\n            }, undefined))\n    }, void 0, false, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Card.tsx\",\n        lineNumber: 65,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Card, \"gg22wXpz+uWeMLH40VJK8VG5H+I=\");\n_c = Card;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Card);\nvar _c;\n$RefreshReg$(_c, \"Card\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0NhcmQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFzQztBQUM0QjtBQUNRO0FBWTFFLE1BQU1LLE9BQTRCO1FBQUMsRUFBRUMsT0FBTyxFQUFFQyxZQUFZLEVBQUUsRUFBRTtRQTZDdkRDOztJQTVDTCxNQUFNQSxrQkFBa0JQLDhDQUFPQTt5Q0FBQztZQUM5QixJQUFJLEVBQUNLLG9CQUFBQSw4QkFBQUEsUUFBU0csSUFBSSxLQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0wsUUFBUUcsSUFBSSxLQUFLSCxRQUFRRyxJQUFJLENBQUNHLE1BQU0sS0FBSyxHQUFHO2dCQUMvRSxPQUFPQztZQUNUO1lBRUEsTUFBTUMsZ0JBQWdCUixRQUFRRyxJQUFJO1lBQ2xDLE1BQU1NLGVBQTZCLEVBQUU7WUFFckMsTUFBTUMsZUFBZU4sTUFBTU8sSUFBSSxDQUM3QixJQUFJQyxJQUFJSixjQUFjSyxHQUFHOzhEQUFDLENBQUNDLElBQU1BLEVBQUVDLEtBQUs7K0RBQ3hDQyxJQUFJOzhEQUFDLENBQUNDLEdBQUdDO29CQUNULElBQUlELE1BQU1WLGFBQWFVLE1BQU0sTUFBTSxPQUFPO29CQUMxQyxJQUFJQyxNQUFNWCxhQUFhVyxNQUFNLE1BQU0sT0FBTyxDQUFDO29CQUMzQyxPQUFPQyxPQUFPRixLQUFLRSxPQUFPRDtnQkFDNUI7O1lBRUEsS0FBSyxNQUFNRSxZQUFZVixhQUFjO2dCQUNuQyxNQUFNSyxRQUFRUCxjQUFjYSxNQUFNOzJEQUFDLENBQUNDLE9BQVNBLEtBQUtQLEtBQUssS0FBS0s7O2dCQUM1RCxJQUFJTCxNQUFNVCxNQUFNLEdBQUcsR0FBRztvQkFDcEJHLGFBQWFjLElBQUksQ0FBQ1I7Z0JBQ3BCO1lBQ0Y7WUFFQSxPQUFPO2dCQUNMUyxRQUFRZjtnQkFDUmdCLFVBQVV6QixRQUFReUIsUUFBUTtZQUM1QjtRQUNGO3dDQUFHO1FBQUN6QjtLQUFRO0lBRVosTUFBTTBCLGtCQUFrQixDQUFDQztRQUN2QixNQUFNQyxjQUFjOUIsbUVBQWNBLENBQUM2QixTQUFTRSxLQUFLO1FBRWpELElBQUlELGdCQUFnQixRQUFRQSxnQkFBZ0JyQixXQUFXO1lBQ3JELE9BQU87UUFDVDtRQUVBLElBQUksT0FBT3FCLGdCQUFnQixXQUFXO1lBQ3BDLE9BQU9BLGNBQWMsUUFBUTtRQUMvQjtRQUVBLE1BQU1FLE9BQU9ILFNBQVNHLElBQUksSUFBSWxDLHdEQUFjQSxDQUFDbUMsVUFBVTtRQUN2RCxPQUFPbEMsdUVBQWtCQSxDQUFDOEIsU0FBU0UsS0FBSyxFQUFFQztJQUM1QztJQUVBLElBQUksRUFBQzVCLDRCQUFBQSx1Q0FBQUEsMEJBQUFBLGdCQUFpQnNCLE1BQU0sY0FBdkJ0Qiw4Q0FBQUEsd0JBQXlCSSxNQUFNLEdBQUU7UUFDcEMsT0FBTztJQUNUO0lBRUEscUJBQ0UsOERBQUMwQjtRQUNDL0IsV0FBVyx3R0FBa0gsT0FBVkE7a0JBRWxIQyxnQkFBZ0JzQixNQUFNLENBQUNYLEdBQUcsQ0FBQyxDQUFDRSxPQUFPa0IsMkJBQ2xDLDhEQUFDRDtnQkFBcUIvQixXQUFVOztrQ0FDOUIsOERBQUMrQjt3QkFBSS9CLFdBQVU7a0NBQ1pjLE1BQU1GLEdBQUcsQ0FBQyxDQUFDYyxVQUFVTyxzQkFDcEIsOERBQUNGO2dDQUVDL0IsV0FBVTs7a0RBRVYsOERBQUNrQzt3Q0FBRWxDLFdBQVU7a0RBQ1YwQixTQUFTUyxLQUFLOzs7Ozs7a0RBRWpCLDhEQUFDRDt3Q0FBRWxDLFdBQVU7a0RBQ1Z5QixnQkFBZ0JDOzs7Ozs7OytCQVBkTzs7Ozs7Ozs7OztvQkFZVkQsYUFBYS9CLGdCQUFnQnNCLE1BQU0sQ0FBQ2xCLE1BQU0sR0FBRyxtQkFDNUMsOERBQUMwQjt3QkFBSS9CLFdBQVU7Ozs7Ozs7ZUFqQlRnQzs7Ozs7Ozs7OztBQXVCbEI7R0E3RU1sQztLQUFBQTtBQStFTixpRUFBZUEsSUFBSUEsRUFBQSIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvY29tcG9uZW50cy9DYXJkLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQ2FyZERlZiwgQ2FyZERhdGEsIEVwb2NoRm9saW9UeXBlIH0gZnJvbSAnLi4vdHlwZXMvcHJvdG8nXG5pbXBvcnQgeyBmb3JtYXRTY2FsYXJCeVR5cGUsIGdldFNjYWxhclZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvcHJvdG9IZWxwZXJzJ1xuXG5pbnRlcmZhY2UgQ2FyZFByb3BzIHtcbiAgY2FyZERlZjogQ2FyZERlZlxuICBjbGFzc05hbWU/OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEdyb3VwZWRDYXJkcyB7XG4gIGdyb3VwczogQ2FyZERhdGFbXVtdXG4gIGNhdGVnb3J5Pzogc3RyaW5nXG59XG5cbmNvbnN0IENhcmQ6IFJlYWN0LkZDPENhcmRQcm9wcz4gPSAoeyBjYXJkRGVmLCBjbGFzc05hbWUgPSAnJyB9KSA9PiB7XG4gIGNvbnN0IGdyb3VwZWRDYXJkRGF0YSA9IHVzZU1lbW8oKCk6IEdyb3VwZWRDYXJkcyB8IHVuZGVmaW5lZCA9PiB7XG4gICAgaWYgKCFjYXJkRGVmPy5kYXRhIHx8ICFBcnJheS5pc0FycmF5KGNhcmREZWYuZGF0YSkgfHwgY2FyZERlZi5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGNvbnN0IGNhcmREYXRhQXJyYXkgPSBjYXJkRGVmLmRhdGFcbiAgICBjb25zdCBncm91cGVkQ2FyZHM6IENhcmREYXRhW11bXSA9IFtdXG5cbiAgICBjb25zdCBncm91cE51bWJlcnMgPSBBcnJheS5mcm9tKFxuICAgICAgbmV3IFNldChjYXJkRGF0YUFycmF5Lm1hcCgoYykgPT4gYy5ncm91cCkpXG4gICAgKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHJldHVybiAxXG4gICAgICBpZiAoYiA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IG51bGwpIHJldHVybiAtMVxuICAgICAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKVxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IGdyb3VwTnVtIG9mIGdyb3VwTnVtYmVycykge1xuICAgICAgY29uc3QgZ3JvdXAgPSBjYXJkRGF0YUFycmF5LmZpbHRlcigoY2FyZCkgPT4gY2FyZC5ncm91cCA9PT0gZ3JvdXBOdW0pXG4gICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkge1xuICAgICAgICBncm91cGVkQ2FyZHMucHVzaChncm91cClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ3JvdXBzOiBncm91cGVkQ2FyZHMsXG4gICAgICBjYXRlZ29yeTogY2FyZERlZi5jYXRlZ29yeVxuICAgIH1cbiAgfSwgW2NhcmREZWZdKVxuXG4gIGNvbnN0IGZvcm1hdENhcmRWYWx1ZSA9IChjYXJkRGF0YTogQ2FyZERhdGEpOiBzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHNjYWxhclZhbHVlID0gZ2V0U2NhbGFyVmFsdWUoY2FyZERhdGEudmFsdWUpXG5cbiAgICBpZiAoc2NhbGFyVmFsdWUgPT09IG51bGwgfHwgc2NhbGFyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuICctJ1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2NhbGFyVmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIHNjYWxhclZhbHVlID8gJ1llcycgOiAnTm8nXG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGNhcmREYXRhLnR5cGUgfHwgRXBvY2hGb2xpb1R5cGUuVHlwZVN0cmluZ1xuICAgIHJldHVybiBmb3JtYXRTY2FsYXJCeVR5cGUoY2FyZERhdGEudmFsdWUsIHR5cGUpXG4gIH1cblxuICBpZiAoIWdyb3VwZWRDYXJkRGF0YT8uZ3JvdXBzPy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e2BmbGV4IGgtZml0IGZsZXgtY29sIGl0ZW1zLXN0YXJ0IGdhcC01IHJvdW5kZWQtMiBib3JkZXIgYm9yZGVyLXByaW1hcnktd2hpdGUvNSBiZy1wcmltYXJ5LXdoaXRlLzIgcC01ICR7Y2xhc3NOYW1lfWB9XG4gICAgPlxuICAgICAge2dyb3VwZWRDYXJkRGF0YS5ncm91cHMubWFwKChncm91cCwgZ3JvdXBJbmRleCkgPT4gKFxuICAgICAgICA8ZGl2IGtleT17Z3JvdXBJbmRleH0gY2xhc3NOYW1lPVwiZmxleCB3LWZ1bGwgZmxleC1jb2wgZ2FwLTVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLXgtMi41IGdhcC15LTVcIj5cbiAgICAgICAgICAgIHtncm91cC5tYXAoKGNhcmREYXRhLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLXN0YXJ0IGdhcC0xLjI1XCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQteHMgZm9udC1ub3JtYWwgdGV4dC1zZWNvbmRhcnktYXNoR3JleSBtLTBcIj5cbiAgICAgICAgICAgICAgICAgIHtjYXJkRGF0YS50aXRsZX1cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LW5vcm1hbCB0ZXh0LXByaW1hcnktd2hpdGUgbS0wXCI+XG4gICAgICAgICAgICAgICAgICB7Zm9ybWF0Q2FyZFZhbHVlKGNhcmREYXRhKX1cbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge2dyb3VwSW5kZXggPCBncm91cGVkQ2FyZERhdGEuZ3JvdXBzLmxlbmd0aCAtIDEgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJoLXB4IHctZnVsbCBiZy1wcmltYXJ5LXdoaXRlLzEwXCIgLz5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICkpfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IENhcmQiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwiRXBvY2hGb2xpb1R5cGUiLCJmb3JtYXRTY2FsYXJCeVR5cGUiLCJnZXRTY2FsYXJWYWx1ZSIsIkNhcmQiLCJjYXJkRGVmIiwiY2xhc3NOYW1lIiwiZ3JvdXBlZENhcmREYXRhIiwiZGF0YSIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNhcmREYXRhQXJyYXkiLCJncm91cGVkQ2FyZHMiLCJncm91cE51bWJlcnMiLCJmcm9tIiwiU2V0IiwibWFwIiwiYyIsImdyb3VwIiwic29ydCIsImEiLCJiIiwiTnVtYmVyIiwiZ3JvdXBOdW0iLCJmaWx0ZXIiLCJjYXJkIiwicHVzaCIsImdyb3VwcyIsImNhdGVnb3J5IiwiZm9ybWF0Q2FyZFZhbHVlIiwiY2FyZERhdGEiLCJzY2FsYXJWYWx1ZSIsInZhbHVlIiwidHlwZSIsIlR5cGVTdHJpbmciLCJkaXYiLCJncm91cEluZGV4IiwiaW5kZXgiLCJwIiwidGl0bGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/Card.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/components/Table.tsx":
/*!**********************************!*\
  !*** ./src/components/Table.tsx ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tanstack/react-table */ \"(pages-dir-browser)/./node_modules/@tanstack/react-table/build/lib/index.mjs\");\n/* harmony import */ var _tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tanstack/react-virtual */ \"(pages-dir-browser)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\");\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ \"(pages-dir-browser)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var _types_proto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../types/proto */ \"(pages-dir-browser)/./src/types/proto.ts\");\n/* harmony import */ var _utils_protoHelpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/protoHelpers */ \"(pages-dir-browser)/./src/utils/protoHelpers.ts\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst ROW_HEIGHT = 43;\nconst Table = (param)=>{\n    let { headers, rows, columnTypes, className = '' } = param;\n    _s();\n    const parentRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [sorting, setSorting] = react__WEBPACK_IMPORTED_MODULE_1___default().useState([]);\n    // Convert rows to objects for TanStack Table\n    const tableData = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"Table.useMemo[tableData]\": ()=>{\n            return rows.map({\n                \"Table.useMemo[tableData]\": (row, index)=>{\n                    const rowObj = {\n                        _index: index\n                    };\n                    headers.forEach({\n                        \"Table.useMemo[tableData]\": (header, colIndex)=>{\n                            rowObj[header] = {\n                                value: row[colIndex],\n                                type: columnTypes[colIndex],\n                                formatted: (0,_utils_protoHelpers__WEBPACK_IMPORTED_MODULE_4__.formatScalarByType)(row[colIndex], columnTypes[colIndex])\n                            };\n                        }\n                    }[\"Table.useMemo[tableData]\"]);\n                    return rowObj;\n                }\n            }[\"Table.useMemo[tableData]\"]);\n        }\n    }[\"Table.useMemo[tableData]\"], [\n        rows,\n        headers,\n        columnTypes\n    ]);\n    // Create column definitions\n    const columnHelper = (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.createColumnHelper)();\n    const columns = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"Table.useMemo[columns]\": ()=>{\n            return headers.map({\n                \"Table.useMemo[columns]\": (header, index)=>columnHelper.accessor(header, {\n                        header: header,\n                        cell: {\n                            \"Table.useMemo[columns]\": (param)=>{\n                                let { getValue } = param;\n                                const cellData = getValue();\n                                return (cellData === null || cellData === void 0 ? void 0 : cellData.formatted) || '-';\n                            }\n                        }[\"Table.useMemo[columns]\"],\n                        sortingFn: {\n                            \"Table.useMemo[columns]\": (rowA, rowB, columnId)=>{\n                                var _rowA_getValue, _rowB_getValue;\n                                const aVal = (0,_utils_protoHelpers__WEBPACK_IMPORTED_MODULE_4__.getScalarValue)((_rowA_getValue = rowA.getValue(columnId)) === null || _rowA_getValue === void 0 ? void 0 : _rowA_getValue.value);\n                                const bVal = (0,_utils_protoHelpers__WEBPACK_IMPORTED_MODULE_4__.getScalarValue)((_rowB_getValue = rowB.getValue(columnId)) === null || _rowB_getValue === void 0 ? void 0 : _rowB_getValue.value);\n                                if (aVal === null && bVal === null) return 0;\n                                if (aVal === null) return 1;\n                                if (bVal === null) return -1;\n                                const columnType = columnTypes[index];\n                                if (columnType === _types_proto__WEBPACK_IMPORTED_MODULE_3__.EpochFolioType.TypeString) {\n                                    return String(aVal).localeCompare(String(bVal));\n                                } else if (columnType === _types_proto__WEBPACK_IMPORTED_MODULE_3__.EpochFolioType.TypeBoolean) {\n                                    return aVal === bVal ? 0 : aVal ? 1 : -1;\n                                } else {\n                                    return Number(aVal) - Number(bVal);\n                                }\n                            }\n                        }[\"Table.useMemo[columns]\"]\n                    })\n            }[\"Table.useMemo[columns]\"]);\n        }\n    }[\"Table.useMemo[columns]\"], [\n        headers,\n        columnTypes,\n        columnHelper\n    ]);\n    const table = (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.useReactTable)({\n        data: tableData,\n        columns,\n        state: {\n            sorting\n        },\n        onSortingChange: setSorting,\n        getCoreRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.getCoreRowModel)(),\n        getSortedRowModel: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.getSortedRowModel)()\n    });\n    const { rows: tableRows } = table.getRowModel();\n    // Virtualization\n    const rowVirtualizer = (0,_tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_6__.useVirtualizer)({\n        count: tableRows.length,\n        getScrollElement: {\n            \"Table.useVirtualizer[rowVirtualizer]\": ()=>parentRef.current\n        }[\"Table.useVirtualizer[rowVirtualizer]\"],\n        estimateSize: {\n            \"Table.useVirtualizer[rowVirtualizer]\": ()=>ROW_HEIGHT\n        }[\"Table.useVirtualizer[rowVirtualizer]\"],\n        overscan: 5\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (0,clsx__WEBPACK_IMPORTED_MODULE_2__[\"default\"])('w-full', className),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: parentRef,\n                className: \"h-[400px] overflow-auto rounded-2 border border-primary-white/5 bg-primary-white/2 scrollbar-hide\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"table\", {\n                    className: \"w-full\",\n                    style: {\n                        tableLayout: 'fixed'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"colgroup\", {\n                            children: table.getAllColumns().map((_, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"col\", {\n                                    style: {\n                                        width: \"\".concat(100 / table.getAllColumns().length, \"%\")\n                                    }\n                                }, index, false, {\n                                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                    lineNumber: 110,\n                                    columnNumber: 15\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                            lineNumber: 108,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"thead\", {\n                            className: \"sticky top-0 z-10 bg-secondary-mildCementGrey\",\n                            children: table.getHeaderGroups().map((headerGroup)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                    className: \"border-b border-primary-white/10\",\n                                    children: headerGroup.headers.map((header)=>{\n                                        var _header_column_getIsSorted;\n                                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"th\", {\n                                            className: \"px-4 py-3 text-left text-xs font-medium text-secondary-ashGrey uppercase cursor-pointer hover:bg-primary-white/5 transition-colors\",\n                                            onClick: header.column.getToggleSortingHandler(),\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex items-center gap-1\",\n                                                children: [\n                                                    (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.flexRender)(header.column.columnDef.header, header.getContext()),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                        className: \"text-xs opacity-60 ml-1\",\n                                                        children: (_header_column_getIsSorted = ({\n                                                            asc: '',\n                                                            desc: ''\n                                                        })[header.column.getIsSorted()]) !== null && _header_column_getIsSorted !== void 0 ? _header_column_getIsSorted : ''\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                                        lineNumber: 124,\n                                                        columnNumber: 23\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                                lineNumber: 122,\n                                                columnNumber: 21\n                                            }, undefined)\n                                        }, header.id, false, {\n                                            fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                            lineNumber: 117,\n                                            columnNumber: 19\n                                        }, undefined);\n                                    })\n                                }, headerGroup.id, false, {\n                                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                    lineNumber: 115,\n                                    columnNumber: 15\n                                }, undefined))\n                        }, void 0, false, {\n                            fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                            lineNumber: 113,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tbody\", {\n                            style: {\n                                height: \"\".concat(rowVirtualizer.getTotalSize(), \"px\"),\n                                position: 'relative'\n                            },\n                            children: rowVirtualizer.getVirtualItems().map((virtualItem)=>{\n                                const row = tableRows[virtualItem.index];\n                                return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"tr\", {\n                                    className: \"border-b border-primary-white/5 hover:bg-primary-white/3 transition-colors\",\n                                    style: {\n                                        position: 'absolute',\n                                        top: 0,\n                                        left: 0,\n                                        width: '100%',\n                                        height: \"\".concat(virtualItem.size, \"px\"),\n                                        transform: \"translateY(\".concat(virtualItem.start, \"px)\")\n                                    },\n                                    children: row.getVisibleCells().map((cell)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"td\", {\n                                            className: \"px-4 py-3 text-sm text-primary-white truncate\",\n                                            style: {\n                                                width: \"\".concat(100 / table.getAllColumns().length, \"%\"),\n                                                maxWidth: 0\n                                            },\n                                            children: (0,_tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.flexRender)(cell.column.columnDef.cell, cell.getContext())\n                                        }, cell.id, false, {\n                                            fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                            lineNumber: 158,\n                                            columnNumber: 21\n                                        }, undefined))\n                                }, row.id, false, {\n                                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                                    lineNumber: 145,\n                                    columnNumber: 17\n                                }, undefined);\n                            })\n                        }, void 0, false, {\n                            fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                            lineNumber: 136,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                    lineNumber: 107,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                lineNumber: 103,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-4 text-sm text-secondary-ashGrey\",\n                children: [\n                    \"Showing \",\n                    tableRows.length,\n                    \" entries with virtualized scrolling\"\n                ]\n            }, void 0, true, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n                lineNumber: 177,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/components/Table.tsx\",\n        lineNumber: 102,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Table, \"UnNyKvFa6qQLQEuBNO7imch9eog=\", false, function() {\n    return [\n        _tanstack_react_table__WEBPACK_IMPORTED_MODULE_5__.useReactTable,\n        _tanstack_react_virtual__WEBPACK_IMPORTED_MODULE_6__.useVirtualizer\n    ];\n});\n_c = Table;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Table);\nvar _c;\n$RefreshReg$(_c, \"Table\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL1RhYmxlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFTaEI7QUFDMEI7QUFDakM7QUFDZ0M7QUFDbUI7QUFTMUUsTUFBTWEsYUFBYTtBQUVuQixNQUFNQyxRQUE4QjtRQUFDLEVBQ25DQyxPQUFPLEVBQ1BDLElBQUksRUFDSkMsV0FBVyxFQUNYQyxZQUFZLEVBQUUsRUFDZjs7SUFDQyxNQUFNQyxZQUFZakIsNkNBQU1BLENBQWlCO0lBQ3pDLE1BQU0sQ0FBQ2tCLFNBQVNDLFdBQVcsR0FBR3JCLHFEQUFjLENBQWUsRUFBRTtJQUU3RCw2Q0FBNkM7SUFDN0MsTUFBTXVCLFlBQVl0Qiw4Q0FBT0E7b0NBQUM7WUFDeEIsT0FBT2UsS0FBS1EsR0FBRzs0Q0FBQyxDQUFDQyxLQUFLQztvQkFDcEIsTUFBTUMsU0FBOEI7d0JBQUVDLFFBQVFGO29CQUFNO29CQUNwRFgsUUFBUWMsT0FBTztvREFBQyxDQUFDQyxRQUFRQzs0QkFDdkJKLE1BQU0sQ0FBQ0csT0FBTyxHQUFHO2dDQUNmRSxPQUFPUCxHQUFHLENBQUNNLFNBQVM7Z0NBQ3BCRSxNQUFNaEIsV0FBVyxDQUFDYyxTQUFTO2dDQUMzQkcsV0FBV3ZCLHVFQUFrQkEsQ0FBQ2MsR0FBRyxDQUFDTSxTQUFTLEVBQUVkLFdBQVcsQ0FBQ2MsU0FBUzs0QkFDcEU7d0JBQ0Y7O29CQUNBLE9BQU9KO2dCQUNUOztRQUNGO21DQUFHO1FBQUNYO1FBQU1EO1FBQVNFO0tBQVk7SUFFL0IsNEJBQTRCO0lBQzVCLE1BQU1rQixlQUFlN0IseUVBQWtCQTtJQUN2QyxNQUFNOEIsVUFBaURuQyw4Q0FBT0E7a0NBQUM7WUFDN0QsT0FBT2MsUUFBUVMsR0FBRzswQ0FBQyxDQUFDTSxRQUFRSixRQUMxQlMsYUFBYUUsUUFBUSxDQUFDUCxRQUFRO3dCQUM1QkEsUUFBUUE7d0JBQ1JRLElBQUk7c0RBQUU7b0NBQUMsRUFBRUMsUUFBUSxFQUFFO2dDQUNqQixNQUFNQyxXQUFXRDtnQ0FDakIsT0FBT0MsQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVTixTQUFTLEtBQUk7NEJBQ2hDOzt3QkFDQU8sU0FBUztzREFBRSxDQUFDQyxNQUFNQyxNQUFNQztvQ0FDTUYsZ0JBQ0FDO2dDQUQ1QixNQUFNRSxPQUFPakMsbUVBQWNBLEVBQUM4QixpQkFBQUEsS0FBS0gsUUFBUSxDQUFDSyx1QkFBZEYscUNBQUFBLGVBQXlCVixLQUFLO2dDQUMxRCxNQUFNYyxPQUFPbEMsbUVBQWNBLEVBQUMrQixpQkFBQUEsS0FBS0osUUFBUSxDQUFDSyx1QkFBZEQscUNBQUFBLGVBQXlCWCxLQUFLO2dDQUUxRCxJQUFJYSxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO2dDQUMzQyxJQUFJRCxTQUFTLE1BQU0sT0FBTztnQ0FDMUIsSUFBSUMsU0FBUyxNQUFNLE9BQU8sQ0FBQztnQ0FFM0IsTUFBTUMsYUFBYTlCLFdBQVcsQ0FBQ1MsTUFBTTtnQ0FDckMsSUFBSXFCLGVBQWVyQyx3REFBY0EsQ0FBQ3NDLFVBQVUsRUFBRTtvQ0FDNUMsT0FBT0MsT0FBT0osTUFBTUssYUFBYSxDQUFDRCxPQUFPSDtnQ0FDM0MsT0FBTyxJQUFJQyxlQUFlckMsd0RBQWNBLENBQUN5QyxXQUFXLEVBQUU7b0NBQ3BELE9BQU8sU0FBVUwsT0FBUSxJQUFJRCxPQUFPLElBQUksQ0FBQztnQ0FDM0MsT0FBTztvQ0FDTCxPQUFPTyxPQUFPUCxRQUFRTyxPQUFPTjtnQ0FDL0I7NEJBQ0Y7O29CQUNGOztRQUVKO2lDQUFHO1FBQUMvQjtRQUFTRTtRQUFha0I7S0FBYTtJQUV2QyxNQUFNa0IsUUFBUWxELG9FQUFhQSxDQUFDO1FBQzFCbUQsTUFBTS9CO1FBQ05hO1FBQ0FtQixPQUFPO1lBQ0xuQztRQUNGO1FBQ0FvQyxpQkFBaUJuQztRQUNqQmpCLGlCQUFpQkEsc0VBQWVBO1FBQ2hDRyxtQkFBbUJBLHdFQUFpQkE7SUFDdEM7SUFFQSxNQUFNLEVBQUVTLE1BQU15QyxTQUFTLEVBQUUsR0FBR0osTUFBTUssV0FBVztJQUU3QyxpQkFBaUI7SUFDakIsTUFBTUMsaUJBQWlCbkQsdUVBQWNBLENBQUM7UUFDcENvRCxPQUFPSCxVQUFVSSxNQUFNO1FBQ3ZCQyxnQkFBZ0I7b0RBQUUsSUFBTTNDLFVBQVU0QyxPQUFPOztRQUN6Q0MsWUFBWTtvREFBRSxJQUFNbkQ7O1FBQ3BCb0QsVUFBVTtJQUNaO0lBRUEscUJBQ0UsOERBQUNDO1FBQUloRCxXQUFXVCxnREFBSUEsQ0FBQyxVQUFVUzs7MEJBQzdCLDhEQUFDZ0Q7Z0JBQ0NDLEtBQUtoRDtnQkFDTEQsV0FBVTswQkFFViw0RUFBQ21DO29CQUFNbkMsV0FBVTtvQkFBU2tELE9BQU87d0JBQUVDLGFBQWE7b0JBQVE7O3NDQUN0RCw4REFBQ0M7c0NBQ0VqQixNQUFNa0IsYUFBYSxHQUFHL0MsR0FBRyxDQUFDLENBQUNnRCxHQUFHOUMsc0JBQzdCLDhEQUFDK0M7b0NBQWdCTCxPQUFPO3dDQUFFTSxPQUFPLEdBQXNDLE9BQW5DLE1BQU1yQixNQUFNa0IsYUFBYSxHQUFHVixNQUFNLEVBQUM7b0NBQUc7bUNBQWhFbkM7Ozs7Ozs7Ozs7c0NBR2QsOERBQUNpRDs0QkFBTXpELFdBQVU7c0NBQ2RtQyxNQUFNdUIsZUFBZSxHQUFHcEQsR0FBRyxDQUFDcUQsQ0FBQUEsNEJBQzNCLDhEQUFDQztvQ0FBd0I1RCxXQUFVOzhDQUNoQzJELFlBQVk5RCxPQUFPLENBQUNTLEdBQUcsQ0FBQ00sQ0FBQUE7NENBU2hCOzZEQVJQLDhEQUFDaUQ7NENBRUM3RCxXQUFVOzRDQUNWOEQsU0FBU2xELE9BQU9tRCxNQUFNLENBQUNDLHVCQUF1QjtzREFFOUMsNEVBQUNoQjtnREFBSWhELFdBQVU7O29EQUNaYixpRUFBVUEsQ0FBQ3lCLE9BQU9tRCxNQUFNLENBQUNFLFNBQVMsQ0FBQ3JELE1BQU0sRUFBRUEsT0FBT3NELFVBQVU7a0VBQzdELDhEQUFDQzt3REFBS25FLFdBQVU7a0VBQ2I7NERBQ0NvRSxLQUFLOzREQUNMQyxNQUFNO3dEQUNSLEVBQUMsQ0FBQ3pELE9BQU9tRCxNQUFNLENBQUNPLFdBQVcsR0FBYSxjQUh2QyxxRUFHMkM7Ozs7Ozs7Ozs7OzsyQ0FWM0MxRCxPQUFPMkQsRUFBRTs7Ozs7O21DQUhYWixZQUFZWSxFQUFFOzs7Ozs7Ozs7O3NDQXFCM0IsOERBQUNDOzRCQUNDdEIsT0FBTztnQ0FDTHVCLFFBQVEsR0FBaUMsT0FBOUJoQyxlQUFlaUMsWUFBWSxJQUFHO2dDQUN6Q0MsVUFBVTs0QkFDWjtzQ0FFQ2xDLGVBQWVtQyxlQUFlLEdBQUd0RSxHQUFHLENBQUN1RSxDQUFBQTtnQ0FDcEMsTUFBTXRFLE1BQU1nQyxTQUFTLENBQUNzQyxZQUFZckUsS0FBSyxDQUFDO2dDQUN4QyxxQkFDRSw4REFBQ29EO29DQUVDNUQsV0FBVTtvQ0FDVmtELE9BQU87d0NBQ0x5QixVQUFVO3dDQUNWRyxLQUFLO3dDQUNMQyxNQUFNO3dDQUNOdkIsT0FBTzt3Q0FDUGlCLFFBQVEsR0FBb0IsT0FBakJJLFlBQVlHLElBQUksRUFBQzt3Q0FDNUJDLFdBQVcsY0FBZ0MsT0FBbEJKLFlBQVlLLEtBQUssRUFBQztvQ0FDN0M7OENBRUMzRSxJQUFJNEUsZUFBZSxHQUFHN0UsR0FBRyxDQUFDYyxDQUFBQSxxQkFDekIsOERBQUNnRTs0Q0FFQ3BGLFdBQVU7NENBQ1ZrRCxPQUFPO2dEQUNMTSxPQUFPLEdBQXNDLE9BQW5DLE1BQU1yQixNQUFNa0IsYUFBYSxHQUFHVixNQUFNLEVBQUM7Z0RBQzdDMEMsVUFBVTs0Q0FDWjtzREFFQ2xHLGlFQUFVQSxDQUFDaUMsS0FBSzJDLE1BQU0sQ0FBQ0UsU0FBUyxDQUFDN0MsSUFBSSxFQUFFQSxLQUFLOEMsVUFBVTsyQ0FQbEQ5QyxLQUFLbUQsRUFBRTs7Ozs7bUNBYlhoRSxJQUFJZ0UsRUFBRTs7Ozs7NEJBeUJqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBTU4sOERBQUN2QjtnQkFBSWhELFdBQVU7O29CQUFzQztvQkFDMUN1QyxVQUFVSSxNQUFNO29CQUFDOzs7Ozs7Ozs7Ozs7O0FBSWxDO0dBN0pNL0M7O1FBdURVWCxnRUFBYUE7UUFjSkssbUVBQWNBOzs7S0FyRWpDTTtBQStKTixpRUFBZUEsS0FBS0EsRUFBQSIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvY29tcG9uZW50cy9UYWJsZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgdXNlUmVhY3RUYWJsZSxcbiAgZ2V0Q29yZVJvd01vZGVsLFxuICBDb2x1bW5EZWYsXG4gIGZsZXhSZW5kZXIsXG4gIGNyZWF0ZUNvbHVtbkhlbHBlcixcbiAgZ2V0U29ydGVkUm93TW9kZWwsXG4gIFNvcnRpbmdTdGF0ZSxcbn0gZnJvbSAnQHRhbnN0YWNrL3JlYWN0LXRhYmxlJ1xuaW1wb3J0IHsgdXNlVmlydHVhbGl6ZXIgfSBmcm9tICdAdGFuc3RhY2svcmVhY3QtdmlydHVhbCdcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnXG5pbXBvcnQgeyBTY2FsYXIsIEVwb2NoRm9saW9UeXBlIH0gZnJvbSAnLi4vdHlwZXMvcHJvdG8nXG5pbXBvcnQgeyBmb3JtYXRTY2FsYXJCeVR5cGUsIGdldFNjYWxhclZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvcHJvdG9IZWxwZXJzJ1xuXG5pbnRlcmZhY2UgVGFibGVQcm9wcyB7XG4gIGhlYWRlcnM6IHN0cmluZ1tdXG4gIHJvd3M6IFNjYWxhcltdW11cbiAgY29sdW1uVHlwZXM6IEVwb2NoRm9saW9UeXBlW11cbiAgY2xhc3NOYW1lPzogc3RyaW5nXG59XG5cbmNvbnN0IFJPV19IRUlHSFQgPSA0M1xuXG5jb25zdCBUYWJsZTogUmVhY3QuRkM8VGFibGVQcm9wcz4gPSAoe1xuICBoZWFkZXJzLFxuICByb3dzLFxuICBjb2x1bW5UeXBlcyxcbiAgY2xhc3NOYW1lID0gJydcbn0pID0+IHtcbiAgY29uc3QgcGFyZW50UmVmID0gdXNlUmVmPEhUTUxEaXZFbGVtZW50PihudWxsKVxuICBjb25zdCBbc29ydGluZywgc2V0U29ydGluZ10gPSBSZWFjdC51c2VTdGF0ZTxTb3J0aW5nU3RhdGU+KFtdKVxuXG4gIC8vIENvbnZlcnQgcm93cyB0byBvYmplY3RzIGZvciBUYW5TdGFjayBUYWJsZVxuICBjb25zdCB0YWJsZURhdGEgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gcm93cy5tYXAoKHJvdywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHJvd09iajogUmVjb3JkPHN0cmluZywgYW55PiA9IHsgX2luZGV4OiBpbmRleCB9XG4gICAgICBoZWFkZXJzLmZvckVhY2goKGhlYWRlciwgY29sSW5kZXgpID0+IHtcbiAgICAgICAgcm93T2JqW2hlYWRlcl0gPSB7XG4gICAgICAgICAgdmFsdWU6IHJvd1tjb2xJbmRleF0sXG4gICAgICAgICAgdHlwZTogY29sdW1uVHlwZXNbY29sSW5kZXhdLFxuICAgICAgICAgIGZvcm1hdHRlZDogZm9ybWF0U2NhbGFyQnlUeXBlKHJvd1tjb2xJbmRleF0sIGNvbHVtblR5cGVzW2NvbEluZGV4XSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiByb3dPYmpcbiAgICB9KVxuICB9LCBbcm93cywgaGVhZGVycywgY29sdW1uVHlwZXNdKVxuXG4gIC8vIENyZWF0ZSBjb2x1bW4gZGVmaW5pdGlvbnNcbiAgY29uc3QgY29sdW1uSGVscGVyID0gY3JlYXRlQ29sdW1uSGVscGVyPHR5cGVvZiB0YWJsZURhdGFbMF0+KClcbiAgY29uc3QgY29sdW1uczogQ29sdW1uRGVmPHR5cGVvZiB0YWJsZURhdGFbMF0sIGFueT5bXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBoZWFkZXJzLm1hcCgoaGVhZGVyLCBpbmRleCkgPT5cbiAgICAgIGNvbHVtbkhlbHBlci5hY2Nlc3NvcihoZWFkZXIsIHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIGNlbGw6ICh7IGdldFZhbHVlIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBjZWxsRGF0YSA9IGdldFZhbHVlKClcbiAgICAgICAgICByZXR1cm4gY2VsbERhdGE/LmZvcm1hdHRlZCB8fCAnLSdcbiAgICAgICAgfSxcbiAgICAgICAgc29ydGluZ0ZuOiAocm93QSwgcm93QiwgY29sdW1uSWQpID0+IHtcbiAgICAgICAgICBjb25zdCBhVmFsID0gZ2V0U2NhbGFyVmFsdWUocm93QS5nZXRWYWx1ZShjb2x1bW5JZCk/LnZhbHVlKVxuICAgICAgICAgIGNvbnN0IGJWYWwgPSBnZXRTY2FsYXJWYWx1ZShyb3dCLmdldFZhbHVlKGNvbHVtbklkKT8udmFsdWUpXG5cbiAgICAgICAgICBpZiAoYVZhbCA9PT0gbnVsbCAmJiBiVmFsID09PSBudWxsKSByZXR1cm4gMFxuICAgICAgICAgIGlmIChhVmFsID09PSBudWxsKSByZXR1cm4gMVxuICAgICAgICAgIGlmIChiVmFsID09PSBudWxsKSByZXR1cm4gLTFcblxuICAgICAgICAgIGNvbnN0IGNvbHVtblR5cGUgPSBjb2x1bW5UeXBlc1tpbmRleF1cbiAgICAgICAgICBpZiAoY29sdW1uVHlwZSA9PT0gRXBvY2hGb2xpb1R5cGUuVHlwZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhhVmFsKS5sb2NhbGVDb21wYXJlKFN0cmluZyhiVmFsKSlcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtblR5cGUgPT09IEVwb2NoRm9saW9UeXBlLlR5cGVCb29sZWFuKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFWYWwgPT09IGJWYWwpID8gMCA6IGFWYWwgPyAxIDogLTFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihhVmFsKSAtIE51bWJlcihiVmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH0sIFtoZWFkZXJzLCBjb2x1bW5UeXBlcywgY29sdW1uSGVscGVyXSlcblxuICBjb25zdCB0YWJsZSA9IHVzZVJlYWN0VGFibGUoe1xuICAgIGRhdGE6IHRhYmxlRGF0YSxcbiAgICBjb2x1bW5zLFxuICAgIHN0YXRlOiB7XG4gICAgICBzb3J0aW5nLFxuICAgIH0sXG4gICAgb25Tb3J0aW5nQ2hhbmdlOiBzZXRTb3J0aW5nLFxuICAgIGdldENvcmVSb3dNb2RlbDogZ2V0Q29yZVJvd01vZGVsKCksXG4gICAgZ2V0U29ydGVkUm93TW9kZWw6IGdldFNvcnRlZFJvd01vZGVsKCksXG4gIH0pXG5cbiAgY29uc3QgeyByb3dzOiB0YWJsZVJvd3MgfSA9IHRhYmxlLmdldFJvd01vZGVsKClcblxuICAvLyBWaXJ0dWFsaXphdGlvblxuICBjb25zdCByb3dWaXJ0dWFsaXplciA9IHVzZVZpcnR1YWxpemVyKHtcbiAgICBjb3VudDogdGFibGVSb3dzLmxlbmd0aCxcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiBwYXJlbnRSZWYuY3VycmVudCxcbiAgICBlc3RpbWF0ZVNpemU6ICgpID0+IFJPV19IRUlHSFQsXG4gICAgb3ZlcnNjYW46IDUsXG4gIH0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xzeCgndy1mdWxsJywgY2xhc3NOYW1lKX0+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj17cGFyZW50UmVmfVxuICAgICAgICBjbGFzc05hbWU9XCJoLVs0MDBweF0gb3ZlcmZsb3ctYXV0byByb3VuZGVkLTIgYm9yZGVyIGJvcmRlci1wcmltYXJ5LXdoaXRlLzUgYmctcHJpbWFyeS13aGl0ZS8yIHNjcm9sbGJhci1oaWRlXCJcbiAgICAgID5cbiAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cInctZnVsbFwiIHN0eWxlPXt7IHRhYmxlTGF5b3V0OiAnZml4ZWQnIH19PlxuICAgICAgICAgIDxjb2xncm91cD5cbiAgICAgICAgICAgIHt0YWJsZS5nZXRBbGxDb2x1bW5zKCkubWFwKChfLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8Y29sIGtleT17aW5kZXh9IHN0eWxlPXt7IHdpZHRoOiBgJHsxMDAgLyB0YWJsZS5nZXRBbGxDb2x1bW5zKCkubGVuZ3RofSVgIH19IC8+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L2NvbGdyb3VwPlxuICAgICAgICAgIDx0aGVhZCBjbGFzc05hbWU9XCJzdGlja3kgdG9wLTAgei0xMCBiZy1zZWNvbmRhcnktbWlsZENlbWVudEdyZXlcIj5cbiAgICAgICAgICAgIHt0YWJsZS5nZXRIZWFkZXJHcm91cHMoKS5tYXAoaGVhZGVyR3JvdXAgPT4gKFxuICAgICAgICAgICAgICA8dHIga2V5PXtoZWFkZXJHcm91cC5pZH0gY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLXByaW1hcnktd2hpdGUvMTBcIj5cbiAgICAgICAgICAgICAgICB7aGVhZGVyR3JvdXAuaGVhZGVycy5tYXAoaGVhZGVyID0+IChcbiAgICAgICAgICAgICAgICAgIDx0aFxuICAgICAgICAgICAgICAgICAgICBrZXk9e2hlYWRlci5pZH1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0zIHRleHQtbGVmdCB0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtc2Vjb25kYXJ5LWFzaEdyZXkgdXBwZXJjYXNlIGN1cnNvci1wb2ludGVyIGhvdmVyOmJnLXByaW1hcnktd2hpdGUvNSB0cmFuc2l0aW9uLWNvbG9yc1wiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hlYWRlci5jb2x1bW4uZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIoKX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtmbGV4UmVuZGVyKGhlYWRlci5jb2x1bW4uY29sdW1uRGVmLmhlYWRlciwgaGVhZGVyLmdldENvbnRleHQoKSl9XG4gICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC14cyBvcGFjaXR5LTYwIG1sLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFzYzogJ+KWsicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2M6ICfilrwnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVtoZWFkZXIuY29sdW1uLmdldElzU29ydGVkKCkgYXMgc3RyaW5nXSA/PyAn4oeFJ31cbiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC90aD5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgPHRib2R5XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBoZWlnaHQ6IGAke3Jvd1ZpcnR1YWxpemVyLmdldFRvdGFsU2l6ZSgpfXB4YCxcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3Jvd1ZpcnR1YWxpemVyLmdldFZpcnR1YWxJdGVtcygpLm1hcCh2aXJ0dWFsSXRlbSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlUm93c1t2aXJ0dWFsSXRlbS5pbmRleF1cbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8dHJcbiAgICAgICAgICAgICAgICAgIGtleT17cm93LmlkfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLXByaW1hcnktd2hpdGUvNSBob3ZlcjpiZy1wcmltYXJ5LXdoaXRlLzMgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBgJHt2aXJ0dWFsSXRlbS5zaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlWSgke3ZpcnR1YWxJdGVtLnN0YXJ0fXB4KWAsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHtyb3cuZ2V0VmlzaWJsZUNlbGxzKCkubWFwKGNlbGwgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgICAgICAgICBrZXk9e2NlbGwuaWR9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0zIHRleHQtc20gdGV4dC1wcmltYXJ5LXdoaXRlIHRydW5jYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGAkezEwMCAvIHRhYmxlLmdldEFsbENvbHVtbnMoKS5sZW5ndGh9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogMFxuICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICB7ZmxleFJlbmRlcihjZWxsLmNvbHVtbi5jb2x1bW5EZWYuY2VsbCwgY2VsbC5nZXRDb250ZXh0KCkpfVxuICAgICAgICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSl9XG4gICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgPC90YWJsZT5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7LyogU3RhdHMgKi99XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgdGV4dC1zbSB0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+XG4gICAgICAgIFNob3dpbmcge3RhYmxlUm93cy5sZW5ndGh9IGVudHJpZXMgd2l0aCB2aXJ0dWFsaXplZCBzY3JvbGxpbmdcbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhYmxlIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVJlYWN0VGFibGUiLCJnZXRDb3JlUm93TW9kZWwiLCJmbGV4UmVuZGVyIiwiY3JlYXRlQ29sdW1uSGVscGVyIiwiZ2V0U29ydGVkUm93TW9kZWwiLCJ1c2VWaXJ0dWFsaXplciIsImNsc3giLCJFcG9jaEZvbGlvVHlwZSIsImZvcm1hdFNjYWxhckJ5VHlwZSIsImdldFNjYWxhclZhbHVlIiwiUk9XX0hFSUdIVCIsIlRhYmxlIiwiaGVhZGVycyIsInJvd3MiLCJjb2x1bW5UeXBlcyIsImNsYXNzTmFtZSIsInBhcmVudFJlZiIsInNvcnRpbmciLCJzZXRTb3J0aW5nIiwidXNlU3RhdGUiLCJ0YWJsZURhdGEiLCJtYXAiLCJyb3ciLCJpbmRleCIsInJvd09iaiIsIl9pbmRleCIsImZvckVhY2giLCJoZWFkZXIiLCJjb2xJbmRleCIsInZhbHVlIiwidHlwZSIsImZvcm1hdHRlZCIsImNvbHVtbkhlbHBlciIsImNvbHVtbnMiLCJhY2Nlc3NvciIsImNlbGwiLCJnZXRWYWx1ZSIsImNlbGxEYXRhIiwic29ydGluZ0ZuIiwicm93QSIsInJvd0IiLCJjb2x1bW5JZCIsImFWYWwiLCJiVmFsIiwiY29sdW1uVHlwZSIsIlR5cGVTdHJpbmciLCJTdHJpbmciLCJsb2NhbGVDb21wYXJlIiwiVHlwZUJvb2xlYW4iLCJOdW1iZXIiLCJ0YWJsZSIsImRhdGEiLCJzdGF0ZSIsIm9uU29ydGluZ0NoYW5nZSIsInRhYmxlUm93cyIsImdldFJvd01vZGVsIiwicm93VmlydHVhbGl6ZXIiLCJjb3VudCIsImxlbmd0aCIsImdldFNjcm9sbEVsZW1lbnQiLCJjdXJyZW50IiwiZXN0aW1hdGVTaXplIiwib3ZlcnNjYW4iLCJkaXYiLCJyZWYiLCJzdHlsZSIsInRhYmxlTGF5b3V0IiwiY29sZ3JvdXAiLCJnZXRBbGxDb2x1bW5zIiwiXyIsImNvbCIsIndpZHRoIiwidGhlYWQiLCJnZXRIZWFkZXJHcm91cHMiLCJoZWFkZXJHcm91cCIsInRyIiwidGgiLCJvbkNsaWNrIiwiY29sdW1uIiwiZ2V0VG9nZ2xlU29ydGluZ0hhbmRsZXIiLCJjb2x1bW5EZWYiLCJnZXRDb250ZXh0Iiwic3BhbiIsImFzYyIsImRlc2MiLCJnZXRJc1NvcnRlZCIsImlkIiwidGJvZHkiLCJoZWlnaHQiLCJnZXRUb3RhbFNpemUiLCJwb3NpdGlvbiIsImdldFZpcnR1YWxJdGVtcyIsInZpcnR1YWxJdGVtIiwidG9wIiwibGVmdCIsInNpemUiLCJ0cmFuc2Zvcm0iLCJzdGFydCIsImdldFZpc2libGVDZWxscyIsInRkIiwibWF4V2lkdGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/components/Table.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/examples/components/Navigation.tsx":
/*!************************************************!*\
  !*** ./src/examples/components/Navigation.tsx ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Navigation)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst NavItem = (param)=>{\n    let { label, status, onClick, active } = param;\n    const statusColor = {\n        done: 'text-territory-success',\n        building: 'text-secondary-yellow',\n        pending: 'text-secondary-ashGrey'\n    }[status];\n    const statusIcon = {\n        done: '',\n        building: '',\n        pending: ''\n    }[status];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        onClick: onClick,\n        className: \"w-full text-left px-4 py-2 rounded-lg transition-colors \".concat(active ? 'bg-primary-white/10 text-primary-white' : 'text-secondary-ashGrey hover:bg-primary-white/5'),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                className: \"\".concat(statusColor, \" mr-2\"),\n                children: statusIcon\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                lineNumber: 33,\n                columnNumber: 7\n            }, undefined),\n            label\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n        lineNumber: 25,\n        columnNumber: 5\n    }, undefined);\n};\n_c = NavItem;\nfunction Navigation(param) {\n    let { currentView, onNavigate } = param;\n    const routes = [\n        {\n            id: 'card',\n            label: 'Card',\n            status: 'done'\n        },\n        {\n            id: 'table',\n            label: 'Table',\n            status: 'done'\n        },\n        {\n            id: 'line',\n            label: 'Line Chart',\n            status: 'pending'\n        },\n        {\n            id: 'bar',\n            label: 'Bar Chart',\n            status: 'pending'\n        },\n        {\n            id: 'heatmap',\n            label: 'Heatmap',\n            status: 'pending'\n        },\n        {\n            id: 'histogram',\n            label: 'Histogram',\n            status: 'pending'\n        },\n        {\n            id: 'boxplot',\n            label: 'Box Plot',\n            status: 'pending'\n        },\n        {\n            id: 'xrange',\n            label: 'X-Range',\n            status: 'pending'\n        },\n        {\n            id: 'pie',\n            label: 'Pie Chart',\n            status: 'pending'\n        },\n        {\n            id: 'full',\n            label: 'Full Dashboard',\n            status: 'pending'\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n        className: \"w-64 h-screen bg-secondary-mildCementGrey border-r border-primary-white/10 p-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-xl font-bold text-primary-white mb-6\",\n                children: \"Dashboard Components\"\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                lineNumber: 60,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-2\",\n                children: routes.map((route)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NavItem, {\n                        id: route.id,\n                        label: route.label,\n                        status: route.status,\n                        onClick: ()=>onNavigate(route.id),\n                        active: currentView === route.id\n                    }, route.id, false, {\n                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                        lineNumber: 66,\n                        columnNumber: 11\n                    }, this))\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-8 pt-4 border-t border-primary-white/10\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-xs text-secondary-ashGrey\",\n                    children: \" Done \\xa0  Building \\xa0  Pending\"\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                    lineNumber: 78,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n                lineNumber: 77,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/components/Navigation.tsx\",\n        lineNumber: 59,\n        columnNumber: 5\n    }, this);\n}\n_c1 = Navigation;\nvar _c, _c1;\n$RefreshReg$(_c, \"NavItem\");\n$RefreshReg$(_c1, \"Navigation\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9leGFtcGxlcy9jb21wb25lbnRzL05hdmlnYXRpb24udHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF5QjtBQVV6QixNQUFNQyxVQUFrQztRQUFDLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRTtJQUN6RSxNQUFNQyxjQUFjO1FBQ2xCQyxNQUFNO1FBQ05DLFVBQVU7UUFDVkMsU0FBUztJQUNYLENBQUMsQ0FBQ04sT0FBTztJQUVULE1BQU1PLGFBQWE7UUFDakJILE1BQU07UUFDTkMsVUFBVTtRQUNWQyxTQUFTO0lBQ1gsQ0FBQyxDQUFDTixPQUFPO0lBRVQscUJBQ0UsOERBQUNRO1FBQ0NQLFNBQVNBO1FBQ1RRLFdBQVcsMkRBSVYsT0FIQ1AsU0FDSSwyQ0FDQTs7MEJBR04sOERBQUNRO2dCQUFLRCxXQUFXLEdBQWUsT0FBWk4sYUFBWTswQkFBU0k7Ozs7OztZQUN4Q1I7Ozs7Ozs7QUFHUDtLQTFCTUQ7QUFpQ1MsU0FBU2EsV0FBVyxLQUE0QztRQUE1QyxFQUFFQyxXQUFXLEVBQUVDLFVBQVUsRUFBbUIsR0FBNUM7SUFDakMsTUFBTUMsU0FBUztRQUNiO1lBQUVDLElBQUk7WUFBUWhCLE9BQU87WUFBUUMsUUFBUTtRQUFnQjtRQUNyRDtZQUFFZSxJQUFJO1lBQVNoQixPQUFPO1lBQVNDLFFBQVE7UUFBZ0I7UUFDdkQ7WUFBRWUsSUFBSTtZQUFRaEIsT0FBTztZQUFjQyxRQUFRO1FBQW1CO1FBQzlEO1lBQUVlLElBQUk7WUFBT2hCLE9BQU87WUFBYUMsUUFBUTtRQUFtQjtRQUM1RDtZQUFFZSxJQUFJO1lBQVdoQixPQUFPO1lBQVdDLFFBQVE7UUFBbUI7UUFDOUQ7WUFBRWUsSUFBSTtZQUFhaEIsT0FBTztZQUFhQyxRQUFRO1FBQW1CO1FBQ2xFO1lBQUVlLElBQUk7WUFBV2hCLE9BQU87WUFBWUMsUUFBUTtRQUFtQjtRQUMvRDtZQUFFZSxJQUFJO1lBQVVoQixPQUFPO1lBQVdDLFFBQVE7UUFBbUI7UUFDN0Q7WUFBRWUsSUFBSTtZQUFPaEIsT0FBTztZQUFhQyxRQUFRO1FBQW1CO1FBQzVEO1lBQUVlLElBQUk7WUFBUWhCLE9BQU87WUFBa0JDLFFBQVE7UUFBbUI7S0FDbkU7SUFFRCxxQkFDRSw4REFBQ2dCO1FBQUlQLFdBQVU7OzBCQUNiLDhEQUFDUTtnQkFBR1IsV0FBVTswQkFBNEM7Ozs7OzswQkFJMUQsOERBQUNTO2dCQUFJVCxXQUFVOzBCQUNaSyxPQUFPSyxHQUFHLENBQUMsQ0FBQ0Msc0JBQ1gsOERBQUN0Qjt3QkFFQ2lCLElBQUlLLE1BQU1MLEVBQUU7d0JBQ1poQixPQUFPcUIsTUFBTXJCLEtBQUs7d0JBQ2xCQyxRQUFRb0IsTUFBTXBCLE1BQU07d0JBQ3BCQyxTQUFTLElBQU1ZLFdBQVdPLE1BQU1MLEVBQUU7d0JBQ2xDYixRQUFRVSxnQkFBZ0JRLE1BQU1MLEVBQUU7dUJBTDNCSyxNQUFNTCxFQUFFOzs7Ozs7Ozs7OzBCQVVuQiw4REFBQ0c7Z0JBQUlULFdBQVU7MEJBQ2IsNEVBQUNZO29CQUFFWixXQUFVOzhCQUFpQzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNdEQ7TUF4Q3dCRSIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvZXhhbXBsZXMvY29tcG9uZW50cy9OYXZpZ2F0aW9uLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmludGVyZmFjZSBOYXZJdGVtUHJvcHMge1xuICBpZDogc3RyaW5nXG4gIGxhYmVsOiBzdHJpbmdcbiAgc3RhdHVzOiAnZG9uZScgfCAnYnVpbGRpbmcnIHwgJ3BlbmRpbmcnXG4gIG9uQ2xpY2s6ICgpID0+IHZvaWRcbiAgYWN0aXZlOiBib29sZWFuXG59XG5cbmNvbnN0IE5hdkl0ZW06IFJlYWN0LkZDPE5hdkl0ZW1Qcm9wcz4gPSAoeyBsYWJlbCwgc3RhdHVzLCBvbkNsaWNrLCBhY3RpdmUgfSkgPT4ge1xuICBjb25zdCBzdGF0dXNDb2xvciA9IHtcbiAgICBkb25lOiAndGV4dC10ZXJyaXRvcnktc3VjY2VzcycsXG4gICAgYnVpbGRpbmc6ICd0ZXh0LXNlY29uZGFyeS15ZWxsb3cnLFxuICAgIHBlbmRpbmc6ICd0ZXh0LXNlY29uZGFyeS1hc2hHcmV5J1xuICB9W3N0YXR1c11cblxuICBjb25zdCBzdGF0dXNJY29uID0ge1xuICAgIGRvbmU6ICfinJMnLFxuICAgIGJ1aWxkaW5nOiAn4pqZJyxcbiAgICBwZW5kaW5nOiAn4peLJ1xuICB9W3N0YXR1c11cblxuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgdGV4dC1sZWZ0IHB4LTQgcHktMiByb3VuZGVkLWxnIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgIGFjdGl2ZVxuICAgICAgICAgID8gJ2JnLXByaW1hcnktd2hpdGUvMTAgdGV4dC1wcmltYXJ5LXdoaXRlJ1xuICAgICAgICAgIDogJ3RleHQtc2Vjb25kYXJ5LWFzaEdyZXkgaG92ZXI6YmctcHJpbWFyeS13aGl0ZS81J1xuICAgICAgfWB9XG4gICAgPlxuICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgJHtzdGF0dXNDb2xvcn0gbXItMmB9PntzdGF0dXNJY29ufTwvc3Bhbj5cbiAgICAgIHtsYWJlbH1cbiAgICA8L2J1dHRvbj5cbiAgKVxufVxuXG5pbnRlcmZhY2UgTmF2aWdhdGlvblByb3BzIHtcbiAgY3VycmVudFZpZXc6IHN0cmluZ1xuICBvbk5hdmlnYXRlOiAodmlldzogc3RyaW5nKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE5hdmlnYXRpb24oeyBjdXJyZW50Vmlldywgb25OYXZpZ2F0ZSB9OiBOYXZpZ2F0aW9uUHJvcHMpIHtcbiAgY29uc3Qgcm91dGVzID0gW1xuICAgIHsgaWQ6ICdjYXJkJywgbGFiZWw6ICdDYXJkJywgc3RhdHVzOiAnZG9uZScgYXMgY29uc3QgfSxcbiAgICB7IGlkOiAndGFibGUnLCBsYWJlbDogJ1RhYmxlJywgc3RhdHVzOiAnZG9uZScgYXMgY29uc3QgfSxcbiAgICB7IGlkOiAnbGluZScsIGxhYmVsOiAnTGluZSBDaGFydCcsIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0IH0sXG4gICAgeyBpZDogJ2JhcicsIGxhYmVsOiAnQmFyIENoYXJ0Jywgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QgfSxcbiAgICB7IGlkOiAnaGVhdG1hcCcsIGxhYmVsOiAnSGVhdG1hcCcsIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0IH0sXG4gICAgeyBpZDogJ2hpc3RvZ3JhbScsIGxhYmVsOiAnSGlzdG9ncmFtJywgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QgfSxcbiAgICB7IGlkOiAnYm94cGxvdCcsIGxhYmVsOiAnQm94IFBsb3QnLCBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCB9LFxuICAgIHsgaWQ6ICd4cmFuZ2UnLCBsYWJlbDogJ1gtUmFuZ2UnLCBzdGF0dXM6ICdwZW5kaW5nJyBhcyBjb25zdCB9LFxuICAgIHsgaWQ6ICdwaWUnLCBsYWJlbDogJ1BpZSBDaGFydCcsIHN0YXR1czogJ3BlbmRpbmcnIGFzIGNvbnN0IH0sXG4gICAgeyBpZDogJ2Z1bGwnLCBsYWJlbDogJ0Z1bGwgRGFzaGJvYXJkJywgc3RhdHVzOiAncGVuZGluZycgYXMgY29uc3QgfSxcbiAgXVxuXG4gIHJldHVybiAoXG4gICAgPG5hdiBjbGFzc05hbWU9XCJ3LTY0IGgtc2NyZWVuIGJnLXNlY29uZGFyeS1taWxkQ2VtZW50R3JleSBib3JkZXItciBib3JkZXItcHJpbWFyeS13aGl0ZS8xMCBwLTRcIj5cbiAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtYm9sZCB0ZXh0LXByaW1hcnktd2hpdGUgbWItNlwiPlxuICAgICAgICBEYXNoYm9hcmQgQ29tcG9uZW50c1xuICAgICAgPC9oMT5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cbiAgICAgICAge3JvdXRlcy5tYXAoKHJvdXRlKSA9PiAoXG4gICAgICAgICAgPE5hdkl0ZW1cbiAgICAgICAgICAgIGtleT17cm91dGUuaWR9XG4gICAgICAgICAgICBpZD17cm91dGUuaWR9XG4gICAgICAgICAgICBsYWJlbD17cm91dGUubGFiZWx9XG4gICAgICAgICAgICBzdGF0dXM9e3JvdXRlLnN0YXR1c31cbiAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uTmF2aWdhdGUocm91dGUuaWQpfVxuICAgICAgICAgICAgYWN0aXZlPXtjdXJyZW50VmlldyA9PT0gcm91dGUuaWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC04IHB0LTQgYm9yZGVyLXQgYm9yZGVyLXByaW1hcnktd2hpdGUvMTBcIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+XG4gICAgICAgICAg4pyTIERvbmUgJm5ic3A7IOKamSBCdWlsZGluZyAmbmJzcDsg4peLIFBlbmRpbmdcbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgPC9uYXY+XG4gIClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJOYXZJdGVtIiwibGFiZWwiLCJzdGF0dXMiLCJvbkNsaWNrIiwiYWN0aXZlIiwic3RhdHVzQ29sb3IiLCJkb25lIiwiYnVpbGRpbmciLCJwZW5kaW5nIiwic3RhdHVzSWNvbiIsImJ1dHRvbiIsImNsYXNzTmFtZSIsInNwYW4iLCJOYXZpZ2F0aW9uIiwiY3VycmVudFZpZXciLCJvbk5hdmlnYXRlIiwicm91dGVzIiwiaWQiLCJuYXYiLCJoMSIsImRpdiIsIm1hcCIsInJvdXRlIiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/examples/components/Navigation.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/examples/pages/CardExample.tsx":
/*!********************************************!*\
  !*** ./src/examples/pages/CardExample.tsx ***!
  \********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CardExample)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/Card */ \"(pages-dir-browser)/./src/components/Card.tsx\");\n/* harmony import */ var _utils_mockData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/mockData */ \"(pages-dir-browser)/./src/utils/mockData.ts\");\n\n\n\n\nfunction CardExample() {\n    const mockCardDef = (0,_utils_mockData__WEBPACK_IMPORTED_MODULE_3__.createMockCardDef)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-2xl font-bold text-primary-white mb-6\",\n                children: \"Card Component\"\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/CardExample.tsx\",\n                lineNumber: 10,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-secondary-ashGrey mb-8\",\n                children: \"Displays grouped metric cards with various data types (percent, decimal, monetary, etc.)\"\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/CardExample.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Card__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    cardDef: mockCardDef\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/CardExample.tsx\",\n                    lineNumber: 18,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/CardExample.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/CardExample.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = CardExample;\nvar _c;\n$RefreshReg$(_c, \"CardExample\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9leGFtcGxlcy9wYWdlcy9DYXJkRXhhbXBsZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBeUI7QUFDZTtBQUNnQjtBQUV6QyxTQUFTRztJQUN0QixNQUFNQyxjQUFjRixrRUFBaUJBO0lBRXJDLHFCQUNFLDhEQUFDRzs7MEJBQ0MsOERBQUNDO2dCQUFHQyxXQUFVOzBCQUE2Qzs7Ozs7OzBCQUczRCw4REFBQ0M7Z0JBQUVELFdBQVU7MEJBQThCOzs7Ozs7MEJBSTNDLDhEQUFDRjtnQkFBSUUsV0FBVTswQkFDYiw0RUFBQ04sd0RBQUlBO29CQUFDUSxTQUFTTDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJdkI7S0FqQndCRCIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvZXhhbXBsZXMvcGFnZXMvQ2FyZEV4YW1wbGUudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBDYXJkIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvQ2FyZCdcbmltcG9ydCB7IGNyZWF0ZU1vY2tDYXJkRGVmIH0gZnJvbSAnLi4vLi4vdXRpbHMvbW9ja0RhdGEnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENhcmRFeGFtcGxlKCkge1xuICBjb25zdCBtb2NrQ2FyZERlZiA9IGNyZWF0ZU1vY2tDYXJkRGVmKClcblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHRleHQtcHJpbWFyeS13aGl0ZSBtYi02XCI+XG4gICAgICAgIENhcmQgQ29tcG9uZW50XG4gICAgICA8L2gyPlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zZWNvbmRhcnktYXNoR3JleSBtYi04XCI+XG4gICAgICAgIERpc3BsYXlzIGdyb3VwZWQgbWV0cmljIGNhcmRzIHdpdGggdmFyaW91cyBkYXRhIHR5cGVzIChwZXJjZW50LCBkZWNpbWFsLCBtb25ldGFyeSwgZXRjLilcbiAgICAgIDwvcD5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cbiAgICAgICAgPENhcmQgY2FyZERlZj17bW9ja0NhcmREZWZ9IC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufSJdLCJuYW1lcyI6WyJSZWFjdCIsIkNhcmQiLCJjcmVhdGVNb2NrQ2FyZERlZiIsIkNhcmRFeGFtcGxlIiwibW9ja0NhcmREZWYiLCJkaXYiLCJoMiIsImNsYXNzTmFtZSIsInAiLCJjYXJkRGVmIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/examples/pages/CardExample.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/examples/pages/TableExample.tsx":
/*!*********************************************!*\
  !*** ./src/examples/pages/TableExample.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TableExample)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/Table */ \"(pages-dir-browser)/./src/components/Table.tsx\");\n/* harmony import */ var _utils_tableMocks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/tableMocks */ \"(pages-dir-browser)/./src/utils/tableMocks.ts\");\n\n\n\n\nfunction TableExample() {\n    const tableData = (0,_utils_tableMocks__WEBPACK_IMPORTED_MODULE_3__.createMockTableData)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-2xl font-bold text-primary-white mb-6\",\n                children: \"Table Component\"\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                lineNumber: 10,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                className: \"text-secondary-ashGrey mb-8\",\n                children: \"Displays tabular data with all supported EpochFolioType formatting, sorting, and pagination. Click column headers to sort. Covers all 10 data types: String, Integer, Decimal, Percent, Boolean, DateTime, Date, DayDuration, Monetary, Duration.\"\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                lineNumber: 13,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-6\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Table__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    headers: tableData.headers,\n                    rows: tableData.rows,\n                    columnTypes: tableData.columnTypes,\n                    itemsPerPage: 3\n                }, void 0, false, {\n                    fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                    lineNumber: 19,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                lineNumber: 18,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-8 p-4 rounded-lg bg-secondary-mildCementGrey border border-primary-white/10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-lg font-medium text-primary-white mb-3\",\n                        children: \"Type Coverage\"\n                    }, void 0, false, {\n                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid grid-cols-2 gap-2 text-sm\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeString\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 30,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeInteger\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 31,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeDecimal\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 32,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypePercent\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 33,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeBoolean\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 34,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeDateTime\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 35,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeDate\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 36,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeDayDuration\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 37,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeMonetary\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 38,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-secondary-ashGrey\",\n                                children: \" TypeDuration\"\n                            }, void 0, false, {\n                                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                                lineNumber: 39,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                        lineNumber: 29,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/adesola/EpochLab/EpochDashboard/js/src/examples/pages/TableExample.tsx\",\n        lineNumber: 9,\n        columnNumber: 5\n    }, this);\n}\n_c = TableExample;\nvar _c;\n$RefreshReg$(_c, \"TableExample\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9leGFtcGxlcy9wYWdlcy9UYWJsZUV4YW1wbGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXlCO0FBQ2lCO0FBQ2tCO0FBRTdDLFNBQVNHO0lBQ3RCLE1BQU1DLFlBQVlGLHNFQUFtQkE7SUFFckMscUJBQ0UsOERBQUNHOzswQkFDQyw4REFBQ0M7Z0JBQUdDLFdBQVU7MEJBQTZDOzs7Ozs7MEJBRzNELDhEQUFDQztnQkFBRUQsV0FBVTswQkFBOEI7Ozs7OzswQkFLM0MsOERBQUNGO2dCQUFJRSxXQUFVOzBCQUNiLDRFQUFDTix5REFBS0E7b0JBQ0pRLFNBQVNMLFVBQVVLLE9BQU87b0JBQzFCQyxNQUFNTixVQUFVTSxJQUFJO29CQUNwQkMsYUFBYVAsVUFBVU8sV0FBVztvQkFDbENDLGNBQWM7Ozs7Ozs7Ozs7OzBCQUlsQiw4REFBQ1A7Z0JBQUlFLFdBQVU7O2tDQUNiLDhEQUFDTTt3QkFBR04sV0FBVTtrQ0FBOEM7Ozs7OztrQ0FDNUQsOERBQUNGO3dCQUFJRSxXQUFVOzswQ0FDYiw4REFBQ0Y7Z0NBQUlFLFdBQVU7MENBQXlCOzs7Ozs7MENBQ3hDLDhEQUFDRjtnQ0FBSUUsV0FBVTswQ0FBeUI7Ozs7OzswQ0FDeEMsOERBQUNGO2dDQUFJRSxXQUFVOzBDQUF5Qjs7Ozs7OzBDQUN4Qyw4REFBQ0Y7Z0NBQUlFLFdBQVU7MENBQXlCOzs7Ozs7MENBQ3hDLDhEQUFDRjtnQ0FBSUUsV0FBVTswQ0FBeUI7Ozs7OzswQ0FDeEMsOERBQUNGO2dDQUFJRSxXQUFVOzBDQUF5Qjs7Ozs7OzBDQUN4Qyw4REFBQ0Y7Z0NBQUlFLFdBQVU7MENBQXlCOzs7Ozs7MENBQ3hDLDhEQUFDRjtnQ0FBSUUsV0FBVTswQ0FBeUI7Ozs7OzswQ0FDeEMsOERBQUNGO2dDQUFJRSxXQUFVOzBDQUF5Qjs7Ozs7OzBDQUN4Qyw4REFBQ0Y7Z0NBQUlFLFdBQVU7MENBQXlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLbEQ7S0F2Q3dCSiIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvZXhhbXBsZXMvcGFnZXMvVGFibGVFeGFtcGxlLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgVGFibGUgZnJvbSAnLi4vLi4vY29tcG9uZW50cy9UYWJsZSdcbmltcG9ydCB7IGNyZWF0ZU1vY2tUYWJsZURhdGEgfSBmcm9tICcuLi8uLi91dGlscy90YWJsZU1vY2tzJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWJsZUV4YW1wbGUoKSB7XG4gIGNvbnN0IHRhYmxlRGF0YSA9IGNyZWF0ZU1vY2tUYWJsZURhdGEoKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1wcmltYXJ5LXdoaXRlIG1iLTZcIj5cbiAgICAgICAgVGFibGUgQ29tcG9uZW50XG4gICAgICA8L2gyPlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zZWNvbmRhcnktYXNoR3JleSBtYi04XCI+XG4gICAgICAgIERpc3BsYXlzIHRhYnVsYXIgZGF0YSB3aXRoIGFsbCBzdXBwb3J0ZWQgRXBvY2hGb2xpb1R5cGUgZm9ybWF0dGluZywgc29ydGluZywgYW5kIHBhZ2luYXRpb24uXG4gICAgICAgIENsaWNrIGNvbHVtbiBoZWFkZXJzIHRvIHNvcnQuIENvdmVycyBhbGwgMTAgZGF0YSB0eXBlczogU3RyaW5nLCBJbnRlZ2VyLCBEZWNpbWFsLCBQZXJjZW50LCBCb29sZWFuLCBEYXRlVGltZSwgRGF0ZSwgRGF5RHVyYXRpb24sIE1vbmV0YXJ5LCBEdXJhdGlvbi5cbiAgICAgIDwvcD5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cbiAgICAgICAgPFRhYmxlXG4gICAgICAgICAgaGVhZGVycz17dGFibGVEYXRhLmhlYWRlcnN9XG4gICAgICAgICAgcm93cz17dGFibGVEYXRhLnJvd3N9XG4gICAgICAgICAgY29sdW1uVHlwZXM9e3RhYmxlRGF0YS5jb2x1bW5UeXBlc31cbiAgICAgICAgICBpdGVtc1BlclBhZ2U9ezN9IC8vIFNtYWxsIHBhZ2Ugc2l6ZSBmb3IgZGVtb1xuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtOCBwLTQgcm91bmRlZC1sZyBiZy1zZWNvbmRhcnktbWlsZENlbWVudEdyZXkgYm9yZGVyIGJvcmRlci1wcmltYXJ5LXdoaXRlLzEwXCI+XG4gICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtbWVkaXVtIHRleHQtcHJpbWFyeS13aGl0ZSBtYi0zXCI+VHlwZSBDb3ZlcmFnZTwvaDM+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMiB0ZXh0LXNtXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+4pyTIFR5cGVTdHJpbmc8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZUludGVnZXI8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZURlY2ltYWw8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZVBlcmNlbnQ8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZUJvb2xlYW48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZURhdGVUaW1lPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+4pyTIFR5cGVEYXRlPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNlY29uZGFyeS1hc2hHcmV5XCI+4pyTIFR5cGVEYXlEdXJhdGlvbjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zZWNvbmRhcnktYXNoR3JleVwiPuKckyBUeXBlTW9uZXRhcnk8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc2Vjb25kYXJ5LWFzaEdyZXlcIj7inJMgVHlwZUR1cmF0aW9uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJUYWJsZSIsImNyZWF0ZU1vY2tUYWJsZURhdGEiLCJUYWJsZUV4YW1wbGUiLCJ0YWJsZURhdGEiLCJkaXYiLCJoMiIsImNsYXNzTmFtZSIsInAiLCJoZWFkZXJzIiwicm93cyIsImNvbHVtblR5cGVzIiwiaXRlbXNQZXJQYWdlIiwiaDMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/examples/pages/TableExample.tsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/types/proto.ts":
/*!****************************!*\
  !*** ./src/types/proto.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AxisType: () => (/* binding */ AxisType),\n/* harmony export */   DashStyle: () => (/* binding */ DashStyle),\n/* harmony export */   EpochFolioDashboardWidget: () => (/* binding */ EpochFolioDashboardWidget),\n/* harmony export */   EpochFolioType: () => (/* binding */ EpochFolioType)\n/* harmony export */ });\n/* harmony import */ var _epochlab_epoch_protos_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @epochlab/epoch-protos/common */ \"(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/common.esm.js\");\n/* harmony import */ var _epochlab_epoch_protos_tearsheet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @epochlab/epoch-protos/tearsheet */ \"(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/tearsheet.esm.js\");\n/* harmony import */ var _epochlab_epoch_protos_chart_def__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @epochlab/epoch-protos/chart_def */ \"(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/chart_def.esm.js\");\n/* harmony import */ var _epochlab_epoch_protos_table_def__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @epochlab/epoch-protos/table_def */ \"(pages-dir-browser)/./node_modules/@epochlab/epoch-protos/dist/table_def.esm.js\");\n// Import using default exports as shown in debug\n\n\n\n\n// Access epoch_proto namespace from default exports\nconst common_proto = _epochlab_epoch_protos_common__WEBPACK_IMPORTED_MODULE_0__[\"default\"].epoch_proto;\nconst tearsheet_proto = _epochlab_epoch_protos_tearsheet__WEBPACK_IMPORTED_MODULE_1__[\"default\"].epoch_proto;\nconst chart_proto = _epochlab_epoch_protos_chart_def__WEBPACK_IMPORTED_MODULE_2__[\"default\"].epoch_proto;\nconst table_proto = _epochlab_epoch_protos_table_def__WEBPACK_IMPORTED_MODULE_3__[\"default\"].epoch_proto;\n// Export enums from protobuf package\nconst EpochFolioType = common_proto.EpochFolioType;\nconst EpochFolioDashboardWidget = common_proto.EpochFolioDashboardWidget;\nconst AxisType = common_proto.AxisType;\nconst DashStyle = common_proto.DashStyle;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy90eXBlcy9wcm90by50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlEQUFpRDtBQUNPO0FBQ007QUFDSjtBQUNBO0FBRTFELG9EQUFvRDtBQUNwRCxNQUFNSSxlQUFlSixpRkFBd0I7QUFDN0MsTUFBTU0sa0JBQWtCTCxvRkFBMkI7QUFDbkQsTUFBTU0sY0FBY0wsb0ZBQXVCO0FBQzNDLE1BQU1NLGNBQWNMLG9GQUF1QjtBQVMzQyxxQ0FBcUM7QUFDOUIsTUFBTU0saUJBQWlCTCxhQUFhSyxjQUFjO0FBQ2xELE1BQU1DLDRCQUE0Qk4sYUFBYU0seUJBQXlCO0FBQ3hFLE1BQU1DLFdBQVdQLGFBQWFPLFFBQVE7QUFDdEMsTUFBTUMsWUFBWVIsYUFBYVEsU0FBUyIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvdHlwZXMvcHJvdG8udHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0IHVzaW5nIGRlZmF1bHQgZXhwb3J0cyBhcyBzaG93biBpbiBkZWJ1Z1xuaW1wb3J0IGNvbW1vbk1vZHVsZSBmcm9tIFwiQGVwb2NobGFiL2Vwb2NoLXByb3Rvcy9jb21tb25cIlxuaW1wb3J0IHRlYXJzaGVldE1vZHVsZSBmcm9tIFwiQGVwb2NobGFiL2Vwb2NoLXByb3Rvcy90ZWFyc2hlZXRcIlxuaW1wb3J0IGNoYXJ0TW9kdWxlIGZyb20gXCJAZXBvY2hsYWIvZXBvY2gtcHJvdG9zL2NoYXJ0X2RlZlwiXG5pbXBvcnQgdGFibGVNb2R1bGUgZnJvbSBcIkBlcG9jaGxhYi9lcG9jaC1wcm90b3MvdGFibGVfZGVmXCJcblxuLy8gQWNjZXNzIGVwb2NoX3Byb3RvIG5hbWVzcGFjZSBmcm9tIGRlZmF1bHQgZXhwb3J0c1xuY29uc3QgY29tbW9uX3Byb3RvID0gY29tbW9uTW9kdWxlLmVwb2NoX3Byb3RvXG5jb25zdCB0ZWFyc2hlZXRfcHJvdG8gPSB0ZWFyc2hlZXRNb2R1bGUuZXBvY2hfcHJvdG9cbmNvbnN0IGNoYXJ0X3Byb3RvID0gY2hhcnRNb2R1bGUuZXBvY2hfcHJvdG9cbmNvbnN0IHRhYmxlX3Byb3RvID0gdGFibGVNb2R1bGUuZXBvY2hfcHJvdG9cblxuLy8gRXhwb3J0IHJlYWwgcHJvdG9idWYgdHlwZXNcbmV4cG9ydCB0eXBlIENhcmREYXRhID0gdGFibGVfcHJvdG8uSUNhcmREYXRhXG5leHBvcnQgdHlwZSBJQ2FyZERhdGEgPSB0YWJsZV9wcm90by5JQ2FyZERhdGFcbmV4cG9ydCB0eXBlIENhcmREZWYgPSB0YWJsZV9wcm90by5JQ2FyZERlZlxuZXhwb3J0IHR5cGUgU2NhbGFyID0gY29tbW9uX3Byb3RvLklTY2FsYXJcbmV4cG9ydCB0eXBlIElTY2FsYXIgPSBjb21tb25fcHJvdG8uSVNjYWxhclxuXG4vLyBFeHBvcnQgZW51bXMgZnJvbSBwcm90b2J1ZiBwYWNrYWdlXG5leHBvcnQgY29uc3QgRXBvY2hGb2xpb1R5cGUgPSBjb21tb25fcHJvdG8uRXBvY2hGb2xpb1R5cGVcbmV4cG9ydCBjb25zdCBFcG9jaEZvbGlvRGFzaGJvYXJkV2lkZ2V0ID0gY29tbW9uX3Byb3RvLkVwb2NoRm9saW9EYXNoYm9hcmRXaWRnZXRcbmV4cG9ydCBjb25zdCBBeGlzVHlwZSA9IGNvbW1vbl9wcm90by5BeGlzVHlwZVxuZXhwb3J0IGNvbnN0IERhc2hTdHlsZSA9IGNvbW1vbl9wcm90by5EYXNoU3R5bGUiXSwibmFtZXMiOlsiY29tbW9uTW9kdWxlIiwidGVhcnNoZWV0TW9kdWxlIiwiY2hhcnRNb2R1bGUiLCJ0YWJsZU1vZHVsZSIsImNvbW1vbl9wcm90byIsImVwb2NoX3Byb3RvIiwidGVhcnNoZWV0X3Byb3RvIiwiY2hhcnRfcHJvdG8iLCJ0YWJsZV9wcm90byIsIkVwb2NoRm9saW9UeXBlIiwiRXBvY2hGb2xpb0Rhc2hib2FyZFdpZGdldCIsIkF4aXNUeXBlIiwiRGFzaFN0eWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/types/proto.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/utils/mockData.ts":
/*!*******************************!*\
  !*** ./src/utils/mockData.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMockCardDef: () => (/* binding */ createMockCardDef)\n/* harmony export */ });\n/* harmony import */ var _types_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/proto */ \"(pages-dir-browser)/./src/types/proto.ts\");\n\nconst createMockCardDef = ()=>{\n    const cardDataGroup1 = [\n        {\n            title: 'Total Return',\n            value: {\n                percentValue: 15.42\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypePercent,\n            group: 0\n        },\n        {\n            title: 'Sharpe Ratio',\n            value: {\n                decimalValue: 1.85\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDecimal,\n            group: 0\n        },\n        {\n            title: 'Max Drawdown',\n            value: {\n                percentValue: -8.23\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypePercent,\n            group: 0\n        },\n        {\n            title: 'Win Rate',\n            value: {\n                percentValue: 62.34\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypePercent,\n            group: 0\n        }\n    ];\n    const cardDataGroup2 = [\n        {\n            title: 'Total Trades',\n            value: {\n                integerValue: 1245\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeInteger,\n            group: 1\n        },\n        {\n            title: 'Avg Trade Duration',\n            value: {\n                durationMs: 3600000 * 48 + 1800000 // 48.5 hours\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDuration,\n            group: 1\n        },\n        {\n            title: 'Capital Deployed',\n            value: {\n                monetaryValue: 250000\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeMonetary,\n            group: 1\n        },\n        {\n            title: 'Active Since',\n            value: {\n                dateValue: 1640995200000\n            },\n            type: _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDate,\n            group: 1\n        }\n    ];\n    return {\n        type: 1,\n        category: 'Performance Metrics',\n        data: [\n            ...cardDataGroup1,\n            ...cardDataGroup2\n        ],\n        groupSize: 2\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9tb2NrRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRTtBQUVuRSxNQUFNQyxvQkFBb0I7SUFDL0IsTUFBTUMsaUJBQTZCO1FBQ2pDO1lBQ0VDLE9BQU87WUFDUEMsT0FBTztnQkFDTEMsY0FBYztZQUNoQjtZQUNBQyxNQUFNTix3REFBY0EsQ0FBQ08sV0FBVztZQUNoQ0MsT0FBTztRQUNUO1FBQ0E7WUFDRUwsT0FBTztZQUNQQyxPQUFPO2dCQUNMSyxjQUFjO1lBQ2hCO1lBQ0FILE1BQU1OLHdEQUFjQSxDQUFDVSxXQUFXO1lBQ2hDRixPQUFPO1FBQ1Q7UUFDQTtZQUNFTCxPQUFPO1lBQ1BDLE9BQU87Z0JBQ0xDLGNBQWMsQ0FBQztZQUNqQjtZQUNBQyxNQUFNTix3REFBY0EsQ0FBQ08sV0FBVztZQUNoQ0MsT0FBTztRQUNUO1FBQ0E7WUFDRUwsT0FBTztZQUNQQyxPQUFPO2dCQUNMQyxjQUFjO1lBQ2hCO1lBQ0FDLE1BQU1OLHdEQUFjQSxDQUFDTyxXQUFXO1lBQ2hDQyxPQUFPO1FBQ1Q7S0FDRDtJQUVELE1BQU1HLGlCQUE2QjtRQUNqQztZQUNFUixPQUFPO1lBQ1BDLE9BQU87Z0JBQ0xRLGNBQWM7WUFDaEI7WUFDQU4sTUFBTU4sd0RBQWNBLENBQUNhLFdBQVc7WUFDaENMLE9BQU87UUFDVDtRQUNBO1lBQ0VMLE9BQU87WUFDUEMsT0FBTztnQkFDTFUsWUFBWSxVQUFVLEtBQUssUUFBUSxhQUFhO1lBQ2xEO1lBQ0FSLE1BQU1OLHdEQUFjQSxDQUFDZSxZQUFZO1lBQ2pDUCxPQUFPO1FBQ1Q7UUFDQTtZQUNFTCxPQUFPO1lBQ1BDLE9BQU87Z0JBQ0xZLGVBQWU7WUFDakI7WUFDQVYsTUFBTU4sd0RBQWNBLENBQUNpQixZQUFZO1lBQ2pDVCxPQUFPO1FBQ1Q7UUFDQTtZQUNFTCxPQUFPO1lBQ1BDLE9BQU87Z0JBQ0xjLFdBQVc7WUFDYjtZQUNBWixNQUFNTix3REFBY0EsQ0FBQ21CLFFBQVE7WUFDN0JYLE9BQU87UUFDVDtLQUNEO0lBRUQsT0FBTztRQUNMRixNQUFNO1FBQ05jLFVBQVU7UUFDVkMsTUFBTTtlQUFJbkI7ZUFBbUJTO1NBQWU7UUFDNUNXLFdBQVc7SUFDYjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2FkZXNvbGEvRXBvY2hMYWIvRXBvY2hEYXNoYm9hcmQvanMvc3JjL3V0aWxzL21vY2tEYXRhLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhcmREZWYsIENhcmREYXRhLCBFcG9jaEZvbGlvVHlwZSwgU2NhbGFyIH0gZnJvbSAnLi4vdHlwZXMvcHJvdG8nXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2NrQ2FyZERlZiA9ICgpOiBDYXJkRGVmID0+IHtcbiAgY29uc3QgY2FyZERhdGFHcm91cDE6IENhcmREYXRhW10gPSBbXG4gICAge1xuICAgICAgdGl0bGU6ICdUb3RhbCBSZXR1cm4nLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgcGVyY2VudFZhbHVlOiAxNS40MlxuICAgICAgfSBhcyBTY2FsYXIsXG4gICAgICB0eXBlOiBFcG9jaEZvbGlvVHlwZS5UeXBlUGVyY2VudCxcbiAgICAgIGdyb3VwOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ1NoYXJwZSBSYXRpbycsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBkZWNpbWFsVmFsdWU6IDEuODVcbiAgICAgIH0gYXMgU2NhbGFyLFxuICAgICAgdHlwZTogRXBvY2hGb2xpb1R5cGUuVHlwZURlY2ltYWwsXG4gICAgICBncm91cDogMFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6ICdNYXggRHJhd2Rvd24nLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgcGVyY2VudFZhbHVlOiAtOC4yM1xuICAgICAgfSBhcyBTY2FsYXIsXG4gICAgICB0eXBlOiBFcG9jaEZvbGlvVHlwZS5UeXBlUGVyY2VudCxcbiAgICAgIGdyb3VwOiAwXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ1dpbiBSYXRlJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHBlcmNlbnRWYWx1ZTogNjIuMzRcbiAgICAgIH0gYXMgU2NhbGFyLFxuICAgICAgdHlwZTogRXBvY2hGb2xpb1R5cGUuVHlwZVBlcmNlbnQsXG4gICAgICBncm91cDogMFxuICAgIH1cbiAgXVxuXG4gIGNvbnN0IGNhcmREYXRhR3JvdXAyOiBDYXJkRGF0YVtdID0gW1xuICAgIHtcbiAgICAgIHRpdGxlOiAnVG90YWwgVHJhZGVzJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGludGVnZXJWYWx1ZTogMTI0NVxuICAgICAgfSBhcyBTY2FsYXIsXG4gICAgICB0eXBlOiBFcG9jaEZvbGlvVHlwZS5UeXBlSW50ZWdlcixcbiAgICAgIGdyb3VwOiAxXG4gICAgfSxcbiAgICB7XG4gICAgICB0aXRsZTogJ0F2ZyBUcmFkZSBEdXJhdGlvbicsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBkdXJhdGlvbk1zOiAzNjAwMDAwICogNDggKyAxODAwMDAwIC8vIDQ4LjUgaG91cnNcbiAgICAgIH0gYXMgU2NhbGFyLFxuICAgICAgdHlwZTogRXBvY2hGb2xpb1R5cGUuVHlwZUR1cmF0aW9uLFxuICAgICAgZ3JvdXA6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnQ2FwaXRhbCBEZXBsb3llZCcsXG4gICAgICB2YWx1ZToge1xuICAgICAgICBtb25ldGFyeVZhbHVlOiAyNTAwMDBcbiAgICAgIH0gYXMgU2NhbGFyLFxuICAgICAgdHlwZTogRXBvY2hGb2xpb1R5cGUuVHlwZU1vbmV0YXJ5LFxuICAgICAgZ3JvdXA6IDFcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiAnQWN0aXZlIFNpbmNlJyxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGRhdGVWYWx1ZTogMTY0MDk5NTIwMDAwMFxuICAgICAgfSBhcyBTY2FsYXIsXG4gICAgICB0eXBlOiBFcG9jaEZvbGlvVHlwZS5UeXBlRGF0ZSxcbiAgICAgIGdyb3VwOiAxXG4gICAgfVxuICBdXG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIGNhdGVnb3J5OiAnUGVyZm9ybWFuY2UgTWV0cmljcycsXG4gICAgZGF0YTogWy4uLmNhcmREYXRhR3JvdXAxLCAuLi5jYXJkRGF0YUdyb3VwMl0sXG4gICAgZ3JvdXBTaXplOiAyXG4gIH1cbn0iXSwibmFtZXMiOlsiRXBvY2hGb2xpb1R5cGUiLCJjcmVhdGVNb2NrQ2FyZERlZiIsImNhcmREYXRhR3JvdXAxIiwidGl0bGUiLCJ2YWx1ZSIsInBlcmNlbnRWYWx1ZSIsInR5cGUiLCJUeXBlUGVyY2VudCIsImdyb3VwIiwiZGVjaW1hbFZhbHVlIiwiVHlwZURlY2ltYWwiLCJjYXJkRGF0YUdyb3VwMiIsImludGVnZXJWYWx1ZSIsIlR5cGVJbnRlZ2VyIiwiZHVyYXRpb25NcyIsIlR5cGVEdXJhdGlvbiIsIm1vbmV0YXJ5VmFsdWUiLCJUeXBlTW9uZXRhcnkiLCJkYXRlVmFsdWUiLCJUeXBlRGF0ZSIsImNhdGVnb3J5IiwiZGF0YSIsImdyb3VwU2l6ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/mockData.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/utils/protoHelpers.ts":
/*!***********************************!*\
  !*** ./src/utils/protoHelpers.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatScalarByType: () => (/* binding */ formatScalarByType),\n/* harmony export */   getScalarDatetimeValue: () => (/* binding */ getScalarDatetimeValue),\n/* harmony export */   getScalarNumericValue: () => (/* binding */ getScalarNumericValue),\n/* harmony export */   getScalarStringValue: () => (/* binding */ getScalarStringValue),\n/* harmony export */   getScalarValue: () => (/* binding */ getScalarValue)\n/* harmony export */ });\n/* harmony import */ var _types_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/proto */ \"(pages-dir-browser)/./src/types/proto.ts\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ms */ \"(pages-dir-browser)/./node_modules/ms/index.js\");\n/* harmony import */ var ms__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ms__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst getScalarValue = (scalar)=>{\n    if (!scalar) return null;\n    // Check all possible scalar value fields directly on the object\n    if (scalar.stringValue !== undefined && scalar.stringValue !== null) return scalar.stringValue;\n    if (scalar.integerValue !== undefined && scalar.integerValue !== null) return scalar.integerValue;\n    if (scalar.decimalValue !== undefined && scalar.decimalValue !== null) return scalar.decimalValue;\n    if (scalar.percentValue !== undefined && scalar.percentValue !== null) return scalar.percentValue;\n    if (scalar.booleanValue !== undefined && scalar.booleanValue !== null) return scalar.booleanValue;\n    if (scalar.timestampMs !== undefined && scalar.timestampMs !== null) return scalar.timestampMs;\n    if (scalar.dateValue !== undefined && scalar.dateValue !== null) return scalar.dateValue;\n    if (scalar.dayDuration !== undefined && scalar.dayDuration !== null) return scalar.dayDuration;\n    if (scalar.monetaryValue !== undefined && scalar.monetaryValue !== null) return scalar.monetaryValue;\n    if (scalar.durationMs !== undefined && scalar.durationMs !== null) return scalar.durationMs;\n    if (scalar.nullValue !== undefined) return null;\n    return null;\n};\nconst getScalarNumericValue = function(scalar) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (!scalar) return defaultValue;\n    if (scalar.integerValue !== undefined && scalar.integerValue !== null) return Number(scalar.integerValue);\n    if (scalar.decimalValue !== undefined && scalar.decimalValue !== null) return scalar.decimalValue;\n    if (scalar.percentValue !== undefined && scalar.percentValue !== null) return scalar.percentValue;\n    if (scalar.monetaryValue !== undefined && scalar.monetaryValue !== null) return scalar.monetaryValue;\n    if (scalar.timestampMs !== undefined && scalar.timestampMs !== null) return Number(scalar.timestampMs);\n    if (scalar.durationMs !== undefined && scalar.durationMs !== null) return Number(scalar.durationMs);\n    return defaultValue;\n};\nconst getScalarStringValue = function(scalar) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '';\n    if (!scalar) return defaultValue;\n    if (scalar.stringValue !== undefined && scalar.stringValue !== null) {\n        return scalar.stringValue;\n    }\n    var _getScalarValue;\n    return String((_getScalarValue = getScalarValue(scalar)) !== null && _getScalarValue !== void 0 ? _getScalarValue : defaultValue);\n};\nconst getScalarDatetimeValue = function(scalar) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    if (!scalar) return defaultValue;\n    if (scalar.timestampMs !== undefined && scalar.timestampMs !== null) {\n        return Number(scalar.timestampMs);\n    }\n    return defaultValue;\n};\nconst formatScalarByType = (scalar, type)=>{\n    const value = getScalarValue(scalar);\n    if (value === null || value === undefined) return '-';\n    switch(type){\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeString:\n            return String(value);\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeInteger:\n            return Number(value).toLocaleString('en-US', {\n                maximumFractionDigits: 0\n            });\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDecimal:\n            return Number(value).toLocaleString('en-US', {\n                maximumFractionDigits: 2\n            });\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypePercent:\n            return \"\".concat(Number(value).toFixed(2), \"%\");\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeMonetary:\n            return \"$\".concat(Number(value).toLocaleString('en-US', {\n                minimumFractionDigits: 2,\n                maximumFractionDigits: 2\n            }));\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeBoolean:\n            return value ? 'Yes' : 'No';\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDateTime:\n            return new Date(Number(value)).toLocaleString('en-US');\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDate:\n            return new Date(Number(value)).toLocaleDateString('en-US');\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDayDuration:\n            return \"\".concat(value, \" days\");\n        case _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDuration:\n            return ms__WEBPACK_IMPORTED_MODULE_1___default()(Number(value), {\n                long: false\n            });\n        default:\n            return String(value);\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy9wcm90b0hlbHBlcnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDcEM7QUFFWixNQUFNRSxpQkFBaUIsQ0FBQ0M7SUFDN0IsSUFBSSxDQUFDQSxRQUFRLE9BQU87SUFFcEIsZ0VBQWdFO0lBQ2hFLElBQUlBLE9BQU9DLFdBQVcsS0FBS0MsYUFBYUYsT0FBT0MsV0FBVyxLQUFLLE1BQU0sT0FBT0QsT0FBT0MsV0FBVztJQUM5RixJQUFJRCxPQUFPRyxZQUFZLEtBQUtELGFBQWFGLE9BQU9HLFlBQVksS0FBSyxNQUFNLE9BQU9ILE9BQU9HLFlBQVk7SUFDakcsSUFBSUgsT0FBT0ksWUFBWSxLQUFLRixhQUFhRixPQUFPSSxZQUFZLEtBQUssTUFBTSxPQUFPSixPQUFPSSxZQUFZO0lBQ2pHLElBQUlKLE9BQU9LLFlBQVksS0FBS0gsYUFBYUYsT0FBT0ssWUFBWSxLQUFLLE1BQU0sT0FBT0wsT0FBT0ssWUFBWTtJQUNqRyxJQUFJTCxPQUFPTSxZQUFZLEtBQUtKLGFBQWFGLE9BQU9NLFlBQVksS0FBSyxNQUFNLE9BQU9OLE9BQU9NLFlBQVk7SUFDakcsSUFBSU4sT0FBT08sV0FBVyxLQUFLTCxhQUFhRixPQUFPTyxXQUFXLEtBQUssTUFBTSxPQUFPUCxPQUFPTyxXQUFXO0lBQzlGLElBQUlQLE9BQU9RLFNBQVMsS0FBS04sYUFBYUYsT0FBT1EsU0FBUyxLQUFLLE1BQU0sT0FBT1IsT0FBT1EsU0FBUztJQUN4RixJQUFJUixPQUFPUyxXQUFXLEtBQUtQLGFBQWFGLE9BQU9TLFdBQVcsS0FBSyxNQUFNLE9BQU9ULE9BQU9TLFdBQVc7SUFDOUYsSUFBSVQsT0FBT1UsYUFBYSxLQUFLUixhQUFhRixPQUFPVSxhQUFhLEtBQUssTUFBTSxPQUFPVixPQUFPVSxhQUFhO0lBQ3BHLElBQUlWLE9BQU9XLFVBQVUsS0FBS1QsYUFBYUYsT0FBT1csVUFBVSxLQUFLLE1BQU0sT0FBT1gsT0FBT1csVUFBVTtJQUMzRixJQUFJWCxPQUFPWSxTQUFTLEtBQUtWLFdBQVcsT0FBTztJQUUzQyxPQUFPO0FBQ1QsRUFBQztBQUVNLE1BQU1XLHdCQUF3QixTQUFDYjtRQUFtQ2MsZ0ZBQXVCO0lBQzlGLElBQUksQ0FBQ2QsUUFBUSxPQUFPYztJQUVwQixJQUFJZCxPQUFPRyxZQUFZLEtBQUtELGFBQWFGLE9BQU9HLFlBQVksS0FBSyxNQUFNLE9BQU9ZLE9BQU9mLE9BQU9HLFlBQVk7SUFDeEcsSUFBSUgsT0FBT0ksWUFBWSxLQUFLRixhQUFhRixPQUFPSSxZQUFZLEtBQUssTUFBTSxPQUFPSixPQUFPSSxZQUFZO0lBQ2pHLElBQUlKLE9BQU9LLFlBQVksS0FBS0gsYUFBYUYsT0FBT0ssWUFBWSxLQUFLLE1BQU0sT0FBT0wsT0FBT0ssWUFBWTtJQUNqRyxJQUFJTCxPQUFPVSxhQUFhLEtBQUtSLGFBQWFGLE9BQU9VLGFBQWEsS0FBSyxNQUFNLE9BQU9WLE9BQU9VLGFBQWE7SUFDcEcsSUFBSVYsT0FBT08sV0FBVyxLQUFLTCxhQUFhRixPQUFPTyxXQUFXLEtBQUssTUFBTSxPQUFPUSxPQUFPZixPQUFPTyxXQUFXO0lBQ3JHLElBQUlQLE9BQU9XLFVBQVUsS0FBS1QsYUFBYUYsT0FBT1csVUFBVSxLQUFLLE1BQU0sT0FBT0ksT0FBT2YsT0FBT1csVUFBVTtJQUVsRyxPQUFPRztBQUNULEVBQUM7QUFFTSxNQUFNRSx1QkFBdUIsU0FBQ2hCO1FBQW1DYyxnRkFBdUI7SUFDN0YsSUFBSSxDQUFDZCxRQUFRLE9BQU9jO0lBRXBCLElBQUlkLE9BQU9DLFdBQVcsS0FBS0MsYUFBYUYsT0FBT0MsV0FBVyxLQUFLLE1BQU07UUFDbkUsT0FBT0QsT0FBT0MsV0FBVztJQUMzQjtRQUVjRjtJQUFkLE9BQU9rQixPQUFPbEIsQ0FBQUEsa0JBQUFBLGVBQWVDLHFCQUFmRCw2QkFBQUEsa0JBQTBCZTtBQUMxQyxFQUFDO0FBRU0sTUFBTUkseUJBQXlCLFNBQUNsQjtRQUFtQ2MsZ0ZBQXVCO0lBQy9GLElBQUksQ0FBQ2QsUUFBUSxPQUFPYztJQUVwQixJQUFJZCxPQUFPTyxXQUFXLEtBQUtMLGFBQWFGLE9BQU9PLFdBQVcsS0FBSyxNQUFNO1FBQ25FLE9BQU9RLE9BQU9mLE9BQU9PLFdBQVc7SUFDbEM7SUFFQSxPQUFPTztBQUNULEVBQUM7QUFFTSxNQUFNSyxxQkFBcUIsQ0FBQ25CLFFBQW1Db0I7SUFDcEUsTUFBTUMsUUFBUXRCLGVBQWVDO0lBRTdCLElBQUlxQixVQUFVLFFBQVFBLFVBQVVuQixXQUFXLE9BQU87SUFFbEQsT0FBUWtCO1FBQ04sS0FBS3ZCLHdEQUFjQSxDQUFDeUIsVUFBVTtZQUM1QixPQUFPTCxPQUFPSTtRQUVoQixLQUFLeEIsd0RBQWNBLENBQUMwQixXQUFXO1lBQzdCLE9BQU9SLE9BQU9NLE9BQU9HLGNBQWMsQ0FBQyxTQUFTO2dCQUFFQyx1QkFBdUI7WUFBRTtRQUUxRSxLQUFLNUIsd0RBQWNBLENBQUM2QixXQUFXO1lBQzdCLE9BQU9YLE9BQU9NLE9BQU9HLGNBQWMsQ0FBQyxTQUFTO2dCQUFFQyx1QkFBdUI7WUFBRTtRQUUxRSxLQUFLNUIsd0RBQWNBLENBQUM4QixXQUFXO1lBQzdCLE9BQU8sR0FBNEIsT0FBekJaLE9BQU9NLE9BQU9PLE9BQU8sQ0FBQyxJQUFHO1FBRXJDLEtBQUsvQix3REFBY0EsQ0FBQ2dDLFlBQVk7WUFDOUIsT0FBTyxJQUFrRyxPQUE5RmQsT0FBT00sT0FBT0csY0FBYyxDQUFDLFNBQVM7Z0JBQUVNLHVCQUF1QjtnQkFBR0wsdUJBQXVCO1lBQUU7UUFFeEcsS0FBSzVCLHdEQUFjQSxDQUFDa0MsV0FBVztZQUM3QixPQUFPVixRQUFRLFFBQVE7UUFFekIsS0FBS3hCLHdEQUFjQSxDQUFDbUMsWUFBWTtZQUM5QixPQUFPLElBQUlDLEtBQUtsQixPQUFPTSxRQUFRRyxjQUFjLENBQUM7UUFFaEQsS0FBSzNCLHdEQUFjQSxDQUFDcUMsUUFBUTtZQUMxQixPQUFPLElBQUlELEtBQUtsQixPQUFPTSxRQUFRYyxrQkFBa0IsQ0FBQztRQUVwRCxLQUFLdEMsd0RBQWNBLENBQUN1QyxlQUFlO1lBQ2pDLE9BQU8sR0FBUyxPQUFOZixPQUFNO1FBRWxCLEtBQUt4Qix3REFBY0EsQ0FBQ3dDLFlBQVk7WUFDOUIsT0FBT3ZDLHlDQUFFQSxDQUFDaUIsT0FBT00sUUFBUTtnQkFBRWlCLE1BQU07WUFBTTtRQUV6QztZQUNFLE9BQU9yQixPQUFPSTtJQUNsQjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9ob21lL2FkZXNvbGEvRXBvY2hMYWIvRXBvY2hEYXNoYm9hcmQvanMvc3JjL3V0aWxzL3Byb3RvSGVscGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY2FsYXIsIEVwb2NoRm9saW9UeXBlIH0gZnJvbSAnLi4vdHlwZXMvcHJvdG8nXG5pbXBvcnQgbXMgZnJvbSAnbXMnXG5cbmV4cG9ydCBjb25zdCBnZXRTY2FsYXJWYWx1ZSA9IChzY2FsYXI6IFNjYWxhciB8IHVuZGVmaW5lZCB8IG51bGwpOiBhbnkgPT4ge1xuICBpZiAoIXNjYWxhcikgcmV0dXJuIG51bGxcblxuICAvLyBDaGVjayBhbGwgcG9zc2libGUgc2NhbGFyIHZhbHVlIGZpZWxkcyBkaXJlY3RseSBvbiB0aGUgb2JqZWN0XG4gIGlmIChzY2FsYXIuc3RyaW5nVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzY2FsYXIuc3RyaW5nVmFsdWUgIT09IG51bGwpIHJldHVybiBzY2FsYXIuc3RyaW5nVmFsdWVcbiAgaWYgKHNjYWxhci5pbnRlZ2VyVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzY2FsYXIuaW50ZWdlclZhbHVlICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLmludGVnZXJWYWx1ZVxuICBpZiAoc2NhbGFyLmRlY2ltYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5kZWNpbWFsVmFsdWUgIT09IG51bGwpIHJldHVybiBzY2FsYXIuZGVjaW1hbFZhbHVlXG4gIGlmIChzY2FsYXIucGVyY2VudFZhbHVlICE9PSB1bmRlZmluZWQgJiYgc2NhbGFyLnBlcmNlbnRWYWx1ZSAhPT0gbnVsbCkgcmV0dXJuIHNjYWxhci5wZXJjZW50VmFsdWVcbiAgaWYgKHNjYWxhci5ib29sZWFuVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzY2FsYXIuYm9vbGVhblZhbHVlICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLmJvb2xlYW5WYWx1ZVxuICBpZiAoc2NhbGFyLnRpbWVzdGFtcE1zICE9PSB1bmRlZmluZWQgJiYgc2NhbGFyLnRpbWVzdGFtcE1zICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLnRpbWVzdGFtcE1zXG4gIGlmIChzY2FsYXIuZGF0ZVZhbHVlICE9PSB1bmRlZmluZWQgJiYgc2NhbGFyLmRhdGVWYWx1ZSAhPT0gbnVsbCkgcmV0dXJuIHNjYWxhci5kYXRlVmFsdWVcbiAgaWYgKHNjYWxhci5kYXlEdXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5kYXlEdXJhdGlvbiAhPT0gbnVsbCkgcmV0dXJuIHNjYWxhci5kYXlEdXJhdGlvblxuICBpZiAoc2NhbGFyLm1vbmV0YXJ5VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzY2FsYXIubW9uZXRhcnlWYWx1ZSAhPT0gbnVsbCkgcmV0dXJuIHNjYWxhci5tb25ldGFyeVZhbHVlXG4gIGlmIChzY2FsYXIuZHVyYXRpb25NcyAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5kdXJhdGlvbk1zICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLmR1cmF0aW9uTXNcbiAgaWYgKHNjYWxhci5udWxsVmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gbnVsbFxufVxuXG5leHBvcnQgY29uc3QgZ2V0U2NhbGFyTnVtZXJpY1ZhbHVlID0gKHNjYWxhcjogU2NhbGFyIHwgdW5kZWZpbmVkIHwgbnVsbCwgZGVmYXVsdFZhbHVlOiBudW1iZXIgPSAwKTogbnVtYmVyID0+IHtcbiAgaWYgKCFzY2FsYXIpIHJldHVybiBkZWZhdWx0VmFsdWVcblxuICBpZiAoc2NhbGFyLmludGVnZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5pbnRlZ2VyVmFsdWUgIT09IG51bGwpIHJldHVybiBOdW1iZXIoc2NhbGFyLmludGVnZXJWYWx1ZSlcbiAgaWYgKHNjYWxhci5kZWNpbWFsVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBzY2FsYXIuZGVjaW1hbFZhbHVlICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLmRlY2ltYWxWYWx1ZVxuICBpZiAoc2NhbGFyLnBlcmNlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5wZXJjZW50VmFsdWUgIT09IG51bGwpIHJldHVybiBzY2FsYXIucGVyY2VudFZhbHVlXG4gIGlmIChzY2FsYXIubW9uZXRhcnlWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5tb25ldGFyeVZhbHVlICE9PSBudWxsKSByZXR1cm4gc2NhbGFyLm1vbmV0YXJ5VmFsdWVcbiAgaWYgKHNjYWxhci50aW1lc3RhbXBNcyAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci50aW1lc3RhbXBNcyAhPT0gbnVsbCkgcmV0dXJuIE51bWJlcihzY2FsYXIudGltZXN0YW1wTXMpXG4gIGlmIChzY2FsYXIuZHVyYXRpb25NcyAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5kdXJhdGlvbk1zICE9PSBudWxsKSByZXR1cm4gTnVtYmVyKHNjYWxhci5kdXJhdGlvbk1zKVxuXG4gIHJldHVybiBkZWZhdWx0VmFsdWVcbn1cblxuZXhwb3J0IGNvbnN0IGdldFNjYWxhclN0cmluZ1ZhbHVlID0gKHNjYWxhcjogU2NhbGFyIHwgdW5kZWZpbmVkIHwgbnVsbCwgZGVmYXVsdFZhbHVlOiBzdHJpbmcgPSAnJyk6IHN0cmluZyA9PiB7XG4gIGlmICghc2NhbGFyKSByZXR1cm4gZGVmYXVsdFZhbHVlXG5cbiAgaWYgKHNjYWxhci5zdHJpbmdWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxhci5zdHJpbmdWYWx1ZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBzY2FsYXIuc3RyaW5nVmFsdWVcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoZ2V0U2NhbGFyVmFsdWUoc2NhbGFyKSA/PyBkZWZhdWx0VmFsdWUpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRTY2FsYXJEYXRldGltZVZhbHVlID0gKHNjYWxhcjogU2NhbGFyIHwgdW5kZWZpbmVkIHwgbnVsbCwgZGVmYXVsdFZhbHVlOiBudW1iZXIgPSAwKTogbnVtYmVyID0+IHtcbiAgaWYgKCFzY2FsYXIpIHJldHVybiBkZWZhdWx0VmFsdWVcblxuICBpZiAoc2NhbGFyLnRpbWVzdGFtcE1zICE9PSB1bmRlZmluZWQgJiYgc2NhbGFyLnRpbWVzdGFtcE1zICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIE51bWJlcihzY2FsYXIudGltZXN0YW1wTXMpXG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlXG59XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRTY2FsYXJCeVR5cGUgPSAoc2NhbGFyOiBTY2FsYXIgfCB1bmRlZmluZWQgfCBudWxsLCB0eXBlOiBFcG9jaEZvbGlvVHlwZSk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U2NhbGFyVmFsdWUoc2NhbGFyKVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJy0nXG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBFcG9jaEZvbGlvVHlwZS5UeXBlU3RyaW5nOlxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcblxuICAgIGNhc2UgRXBvY2hGb2xpb1R5cGUuVHlwZUludGVnZXI6XG4gICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKS50b0xvY2FsZVN0cmluZygnZW4tVVMnLCB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogMCB9KVxuXG4gICAgY2FzZSBFcG9jaEZvbGlvVHlwZS5UeXBlRGVjaW1hbDpcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpLnRvTG9jYWxlU3RyaW5nKCdlbi1VUycsIHsgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiAyIH0pXG5cbiAgICBjYXNlIEVwb2NoRm9saW9UeXBlLlR5cGVQZXJjZW50OlxuICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSkudG9GaXhlZCgyKX0lYFxuXG4gICAgY2FzZSBFcG9jaEZvbGlvVHlwZS5UeXBlTW9uZXRhcnk6XG4gICAgICByZXR1cm4gYCQke051bWJlcih2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoJ2VuLVVTJywgeyBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IDIsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMiB9KX1gXG5cbiAgICBjYXNlIEVwb2NoRm9saW9UeXBlLlR5cGVCb29sZWFuOlxuICAgICAgcmV0dXJuIHZhbHVlID8gJ1llcycgOiAnTm8nXG5cbiAgICBjYXNlIEVwb2NoRm9saW9UeXBlLlR5cGVEYXRlVGltZTpcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodmFsdWUpKS50b0xvY2FsZVN0cmluZygnZW4tVVMnKVxuXG4gICAgY2FzZSBFcG9jaEZvbGlvVHlwZS5UeXBlRGF0ZTpcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodmFsdWUpKS50b0xvY2FsZURhdGVTdHJpbmcoJ2VuLVVTJylcblxuICAgIGNhc2UgRXBvY2hGb2xpb1R5cGUuVHlwZURheUR1cmF0aW9uOlxuICAgICAgcmV0dXJuIGAke3ZhbHVlfSBkYXlzYFxuXG4gICAgY2FzZSBFcG9jaEZvbGlvVHlwZS5UeXBlRHVyYXRpb246XG4gICAgICByZXR1cm4gbXMoTnVtYmVyKHZhbHVlKSwgeyBsb25nOiBmYWxzZSB9KVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gIH1cbn0iXSwibmFtZXMiOlsiRXBvY2hGb2xpb1R5cGUiLCJtcyIsImdldFNjYWxhclZhbHVlIiwic2NhbGFyIiwic3RyaW5nVmFsdWUiLCJ1bmRlZmluZWQiLCJpbnRlZ2VyVmFsdWUiLCJkZWNpbWFsVmFsdWUiLCJwZXJjZW50VmFsdWUiLCJib29sZWFuVmFsdWUiLCJ0aW1lc3RhbXBNcyIsImRhdGVWYWx1ZSIsImRheUR1cmF0aW9uIiwibW9uZXRhcnlWYWx1ZSIsImR1cmF0aW9uTXMiLCJudWxsVmFsdWUiLCJnZXRTY2FsYXJOdW1lcmljVmFsdWUiLCJkZWZhdWx0VmFsdWUiLCJOdW1iZXIiLCJnZXRTY2FsYXJTdHJpbmdWYWx1ZSIsIlN0cmluZyIsImdldFNjYWxhckRhdGV0aW1lVmFsdWUiLCJmb3JtYXRTY2FsYXJCeVR5cGUiLCJ0eXBlIiwidmFsdWUiLCJUeXBlU3RyaW5nIiwiVHlwZUludGVnZXIiLCJ0b0xvY2FsZVN0cmluZyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsIlR5cGVEZWNpbWFsIiwiVHlwZVBlcmNlbnQiLCJ0b0ZpeGVkIiwiVHlwZU1vbmV0YXJ5IiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwiVHlwZUJvb2xlYW4iLCJUeXBlRGF0ZVRpbWUiLCJEYXRlIiwiVHlwZURhdGUiLCJ0b0xvY2FsZURhdGVTdHJpbmciLCJUeXBlRGF5RHVyYXRpb24iLCJUeXBlRHVyYXRpb24iLCJsb25nIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/protoHelpers.ts\n"));

/***/ }),

/***/ "(pages-dir-browser)/./src/utils/tableMocks.ts":
/*!*********************************!*\
  !*** ./src/utils/tableMocks.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createMockTableData: () => (/* binding */ createMockTableData)\n/* harmony export */ });\n/* harmony import */ var _types_proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/proto */ \"(pages-dir-browser)/./src/types/proto.ts\");\n\nconst createMockTableData = ()=>{\n    const headers = [\n        'Strategy Name',\n        'ID',\n        'Returns',\n        'Success Rate',\n        'Active',\n        'Last Updated',\n        'Start Date',\n        'Runtime Days',\n        'Capital',\n        'Avg Duration' // TypeDuration\n    ];\n    const columnTypes = [\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeString,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeInteger,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDecimal,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypePercent,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeBoolean,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDateTime,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDate,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDayDuration,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeMonetary,\n        _types_proto__WEBPACK_IMPORTED_MODULE_0__.EpochFolioType.TypeDuration\n    ];\n    const rows = [\n        [\n            {\n                stringValue: 'Momentum Alpha'\n            },\n            {\n                integerValue: 1001\n            },\n            {\n                decimalValue: 12.45\n            },\n            {\n                percentValue: 78.5\n            },\n            {\n                booleanValue: true\n            },\n            {\n                timestampMs: Date.now() - 3600000\n            },\n            {\n                dateValue: 1609459200000\n            },\n            {\n                dayDuration: 365\n            },\n            {\n                monetaryValue: 1250000\n            },\n            {\n                durationMs: 7200000\n            }\n        ],\n        [\n            {\n                stringValue: 'Mean Reversion Beta'\n            },\n            {\n                integerValue: 1002\n            },\n            {\n                decimalValue: -3.21\n            },\n            {\n                percentValue: 45.2\n            },\n            {\n                booleanValue: false\n            },\n            {\n                timestampMs: Date.now() - 86400000\n            },\n            {\n                dateValue: 1640995200000\n            },\n            {\n                dayDuration: 180\n            },\n            {\n                monetaryValue: 750000\n            },\n            {\n                durationMs: 1800000\n            }\n        ],\n        [\n            {\n                stringValue: 'Arbitrage Gamma'\n            },\n            {\n                integerValue: 1003\n            },\n            {\n                decimalValue: 25.67\n            },\n            {\n                percentValue: 92.1\n            },\n            {\n                booleanValue: true\n            },\n            {\n                timestampMs: Date.now() - 7200000\n            },\n            {\n                dateValue: 1672531200000\n            },\n            {\n                dayDuration: 90\n            },\n            {\n                monetaryValue: 2000000\n            },\n            {\n                durationMs: 14400000\n            }\n        ],\n        [\n            {\n                stringValue: 'Trend Following Delta'\n            },\n            {\n                integerValue: 1004\n            },\n            {\n                decimalValue: 8.93\n            },\n            {\n                percentValue: 65.8\n            },\n            {\n                booleanValue: true\n            },\n            {\n                timestampMs: Date.now() - 1800000\n            },\n            {\n                dateValue: 1704067200000\n            },\n            {\n                dayDuration: 45\n            },\n            {\n                monetaryValue: 500000\n            },\n            {\n                durationMs: 5400000\n            }\n        ],\n        [\n            {\n                stringValue: 'Statistical Edge'\n            },\n            {\n                integerValue: 1005\n            },\n            {\n                decimalValue: 0.0\n            },\n            {\n                percentValue: 0.0\n            },\n            {\n                booleanValue: false\n            },\n            {\n                timestampMs: Date.now()\n            },\n            {\n                dateValue: Date.now()\n            },\n            {\n                dayDuration: 1\n            },\n            {\n                monetaryValue: 0\n            },\n            {\n                durationMs: 300000\n            }\n        ]\n    ];\n    return {\n        headers,\n        rows,\n        columnTypes\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy91dGlscy90YWJsZU1vY2tzLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXVEO0FBUWhELE1BQU1DLHNCQUFzQjtJQUNqQyxNQUFNQyxVQUFVO1FBQ2Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsZUFBcUIsZUFBZTtLQUNyQztJQUVELE1BQU1DLGNBQWM7UUFDbEJILHdEQUFjQSxDQUFDSSxVQUFVO1FBQ3pCSix3REFBY0EsQ0FBQ0ssV0FBVztRQUMxQkwsd0RBQWNBLENBQUNNLFdBQVc7UUFDMUJOLHdEQUFjQSxDQUFDTyxXQUFXO1FBQzFCUCx3REFBY0EsQ0FBQ1EsV0FBVztRQUMxQlIsd0RBQWNBLENBQUNTLFlBQVk7UUFDM0JULHdEQUFjQSxDQUFDVSxRQUFRO1FBQ3ZCVix3REFBY0EsQ0FBQ1csZUFBZTtRQUM5Qlgsd0RBQWNBLENBQUNZLFlBQVk7UUFDM0JaLHdEQUFjQSxDQUFDYSxZQUFZO0tBQzVCO0lBRUQsTUFBTUMsT0FBbUI7UUFDdkI7WUFDRTtnQkFBRUMsYUFBYTtZQUFpQjtZQUNoQztnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxjQUFjO1lBQU07WUFDdEI7Z0JBQUVDLGNBQWM7WUFBSztZQUNyQjtnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxhQUFhQyxLQUFLQyxHQUFHLEtBQUs7WUFBUTtZQUNwQztnQkFBRUMsV0FBVztZQUFjO1lBQzNCO2dCQUFFQyxhQUFhO1lBQUk7WUFDbkI7Z0JBQUVDLGVBQWU7WUFBUTtZQUN6QjtnQkFBRUMsWUFBWTtZQUFRO1NBQ3ZCO1FBQ0Q7WUFDRTtnQkFBRVgsYUFBYTtZQUFzQjtZQUNyQztnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxjQUFjLENBQUM7WUFBSztZQUN0QjtnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxjQUFjO1lBQU07WUFDdEI7Z0JBQUVDLGFBQWFDLEtBQUtDLEdBQUcsS0FBSztZQUFTO1lBQ3JDO2dCQUFFQyxXQUFXO1lBQWM7WUFDM0I7Z0JBQUVDLGFBQWE7WUFBSTtZQUNuQjtnQkFBRUMsZUFBZTtZQUFPO1lBQ3hCO2dCQUFFQyxZQUFZO1lBQVE7U0FDdkI7UUFDRDtZQUNFO2dCQUFFWCxhQUFhO1lBQWtCO1lBQ2pDO2dCQUFFQyxjQUFjO1lBQUs7WUFDckI7Z0JBQUVDLGNBQWM7WUFBTTtZQUN0QjtnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxjQUFjO1lBQUs7WUFDckI7Z0JBQUVDLGFBQWFDLEtBQUtDLEdBQUcsS0FBSztZQUFRO1lBQ3BDO2dCQUFFQyxXQUFXO1lBQWM7WUFDM0I7Z0JBQUVDLGFBQWE7WUFBRztZQUNsQjtnQkFBRUMsZUFBZTtZQUFRO1lBQ3pCO2dCQUFFQyxZQUFZO1lBQVM7U0FDeEI7UUFDRDtZQUNFO2dCQUFFWCxhQUFhO1lBQXdCO1lBQ3ZDO2dCQUFFQyxjQUFjO1lBQUs7WUFDckI7Z0JBQUVDLGNBQWM7WUFBSztZQUNyQjtnQkFBRUMsY0FBYztZQUFLO1lBQ3JCO2dCQUFFQyxjQUFjO1lBQUs7WUFDckI7Z0JBQUVDLGFBQWFDLEtBQUtDLEdBQUcsS0FBSztZQUFRO1lBQ3BDO2dCQUFFQyxXQUFXO1lBQWM7WUFDM0I7Z0JBQUVDLGFBQWE7WUFBRztZQUNsQjtnQkFBRUMsZUFBZTtZQUFPO1lBQ3hCO2dCQUFFQyxZQUFZO1lBQVE7U0FDdkI7UUFDRDtZQUNFO2dCQUFFWCxhQUFhO1lBQW1CO1lBQ2xDO2dCQUFFQyxjQUFjO1lBQUs7WUFDckI7Z0JBQUVDLGNBQWM7WUFBSTtZQUNwQjtnQkFBRUMsY0FBYztZQUFJO1lBQ3BCO2dCQUFFQyxjQUFjO1lBQU07WUFDdEI7Z0JBQUVDLGFBQWFDLEtBQUtDLEdBQUc7WUFBRztZQUMxQjtnQkFBRUMsV0FBV0YsS0FBS0MsR0FBRztZQUFHO1lBQ3hCO2dCQUFFRSxhQUFhO1lBQUU7WUFDakI7Z0JBQUVDLGVBQWU7WUFBRTtZQUNuQjtnQkFBRUMsWUFBWTtZQUFPO1NBQ3RCO0tBQ0Y7SUFFRCxPQUFPO1FBQ0x4QjtRQUNBWTtRQUNBWDtJQUNGO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL2hvbWUvYWRlc29sYS9FcG9jaExhYi9FcG9jaERhc2hib2FyZC9qcy9zcmMvdXRpbHMvdGFibGVNb2Nrcy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFcG9jaEZvbGlvVHlwZSwgU2NhbGFyIH0gZnJvbSAnLi4vdHlwZXMvcHJvdG8nXG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVEYXRhIHtcbiAgaGVhZGVyczogc3RyaW5nW11cbiAgcm93czogU2NhbGFyW11bXVxuICBjb2x1bW5UeXBlczogRXBvY2hGb2xpb1R5cGVbXVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlTW9ja1RhYmxlRGF0YSA9ICgpOiBUYWJsZURhdGEgPT4ge1xuICBjb25zdCBoZWFkZXJzID0gW1xuICAgICdTdHJhdGVneSBOYW1lJywgICAgICAvLyBUeXBlU3RyaW5nXG4gICAgJ0lEJywgICAgICAgICAgICAgICAgLy8gVHlwZUludGVnZXJcbiAgICAnUmV0dXJucycsICAgICAgICAgICAvLyBUeXBlRGVjaW1hbFxuICAgICdTdWNjZXNzIFJhdGUnLCAgICAgIC8vIFR5cGVQZXJjZW50XG4gICAgJ0FjdGl2ZScsICAgICAgICAgICAgLy8gVHlwZUJvb2xlYW5cbiAgICAnTGFzdCBVcGRhdGVkJywgICAgICAvLyBUeXBlRGF0ZVRpbWVcbiAgICAnU3RhcnQgRGF0ZScsICAgICAgICAvLyBUeXBlRGF0ZVxuICAgICdSdW50aW1lIERheXMnLCAgICAgIC8vIFR5cGVEYXlEdXJhdGlvblxuICAgICdDYXBpdGFsJywgICAgICAgICAgIC8vIFR5cGVNb25ldGFyeVxuICAgICdBdmcgRHVyYXRpb24nICAgICAgIC8vIFR5cGVEdXJhdGlvblxuICBdXG5cbiAgY29uc3QgY29sdW1uVHlwZXMgPSBbXG4gICAgRXBvY2hGb2xpb1R5cGUuVHlwZVN0cmluZyxcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlSW50ZWdlcixcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlRGVjaW1hbCxcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlUGVyY2VudCxcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlQm9vbGVhbixcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlRGF0ZVRpbWUsXG4gICAgRXBvY2hGb2xpb1R5cGUuVHlwZURhdGUsXG4gICAgRXBvY2hGb2xpb1R5cGUuVHlwZURheUR1cmF0aW9uLFxuICAgIEVwb2NoRm9saW9UeXBlLlR5cGVNb25ldGFyeSxcbiAgICBFcG9jaEZvbGlvVHlwZS5UeXBlRHVyYXRpb25cbiAgXVxuXG4gIGNvbnN0IHJvd3M6IFNjYWxhcltdW10gPSBbXG4gICAgW1xuICAgICAgeyBzdHJpbmdWYWx1ZTogJ01vbWVudHVtIEFscGhhJyB9IGFzIFNjYWxhcixcbiAgICAgIHsgaW50ZWdlclZhbHVlOiAxMDAxIH0gYXMgU2NhbGFyLFxuICAgICAgeyBkZWNpbWFsVmFsdWU6IDEyLjQ1IH0gYXMgU2NhbGFyLFxuICAgICAgeyBwZXJjZW50VmFsdWU6IDc4LjUgfSBhcyBTY2FsYXIsXG4gICAgICB7IGJvb2xlYW5WYWx1ZTogdHJ1ZSB9IGFzIFNjYWxhcixcbiAgICAgIHsgdGltZXN0YW1wTXM6IERhdGUubm93KCkgLSAzNjAwMDAwIH0gYXMgU2NhbGFyLCAvLyAxIGhvdXIgYWdvXG4gICAgICB7IGRhdGVWYWx1ZTogMTYwOTQ1OTIwMDAwMCB9IGFzIFNjYWxhciwgLy8gSmFuIDEsIDIwMjFcbiAgICAgIHsgZGF5RHVyYXRpb246IDM2NSB9IGFzIFNjYWxhcixcbiAgICAgIHsgbW9uZXRhcnlWYWx1ZTogMTI1MDAwMCB9IGFzIFNjYWxhcixcbiAgICAgIHsgZHVyYXRpb25NczogNzIwMDAwMCB9IGFzIFNjYWxhciAvLyAyIGhvdXJzXG4gICAgXSxcbiAgICBbXG4gICAgICB7IHN0cmluZ1ZhbHVlOiAnTWVhbiBSZXZlcnNpb24gQmV0YScgfSBhcyBTY2FsYXIsXG4gICAgICB7IGludGVnZXJWYWx1ZTogMTAwMiB9IGFzIFNjYWxhcixcbiAgICAgIHsgZGVjaW1hbFZhbHVlOiAtMy4yMSB9IGFzIFNjYWxhcixcbiAgICAgIHsgcGVyY2VudFZhbHVlOiA0NS4yIH0gYXMgU2NhbGFyLFxuICAgICAgeyBib29sZWFuVmFsdWU6IGZhbHNlIH0gYXMgU2NhbGFyLFxuICAgICAgeyB0aW1lc3RhbXBNczogRGF0ZS5ub3coKSAtIDg2NDAwMDAwIH0gYXMgU2NhbGFyLCAvLyAxIGRheSBhZ29cbiAgICAgIHsgZGF0ZVZhbHVlOiAxNjQwOTk1MjAwMDAwIH0gYXMgU2NhbGFyLCAvLyBKYW4gMSwgMjAyMlxuICAgICAgeyBkYXlEdXJhdGlvbjogMTgwIH0gYXMgU2NhbGFyLFxuICAgICAgeyBtb25ldGFyeVZhbHVlOiA3NTAwMDAgfSBhcyBTY2FsYXIsXG4gICAgICB7IGR1cmF0aW9uTXM6IDE4MDAwMDAgfSBhcyBTY2FsYXIgLy8gMzAgbWludXRlc1xuICAgIF0sXG4gICAgW1xuICAgICAgeyBzdHJpbmdWYWx1ZTogJ0FyYml0cmFnZSBHYW1tYScgfSBhcyBTY2FsYXIsXG4gICAgICB7IGludGVnZXJWYWx1ZTogMTAwMyB9IGFzIFNjYWxhcixcbiAgICAgIHsgZGVjaW1hbFZhbHVlOiAyNS42NyB9IGFzIFNjYWxhcixcbiAgICAgIHsgcGVyY2VudFZhbHVlOiA5Mi4xIH0gYXMgU2NhbGFyLFxuICAgICAgeyBib29sZWFuVmFsdWU6IHRydWUgfSBhcyBTY2FsYXIsXG4gICAgICB7IHRpbWVzdGFtcE1zOiBEYXRlLm5vdygpIC0gNzIwMDAwMCB9IGFzIFNjYWxhciwgLy8gMiBob3VycyBhZ29cbiAgICAgIHsgZGF0ZVZhbHVlOiAxNjcyNTMxMjAwMDAwIH0gYXMgU2NhbGFyLCAvLyBKYW4gMSwgMjAyM1xuICAgICAgeyBkYXlEdXJhdGlvbjogOTAgfSBhcyBTY2FsYXIsXG4gICAgICB7IG1vbmV0YXJ5VmFsdWU6IDIwMDAwMDAgfSBhcyBTY2FsYXIsXG4gICAgICB7IGR1cmF0aW9uTXM6IDE0NDAwMDAwIH0gYXMgU2NhbGFyIC8vIDQgaG91cnNcbiAgICBdLFxuICAgIFtcbiAgICAgIHsgc3RyaW5nVmFsdWU6ICdUcmVuZCBGb2xsb3dpbmcgRGVsdGEnIH0gYXMgU2NhbGFyLFxuICAgICAgeyBpbnRlZ2VyVmFsdWU6IDEwMDQgfSBhcyBTY2FsYXIsXG4gICAgICB7IGRlY2ltYWxWYWx1ZTogOC45MyB9IGFzIFNjYWxhcixcbiAgICAgIHsgcGVyY2VudFZhbHVlOiA2NS44IH0gYXMgU2NhbGFyLFxuICAgICAgeyBib29sZWFuVmFsdWU6IHRydWUgfSBhcyBTY2FsYXIsXG4gICAgICB7IHRpbWVzdGFtcE1zOiBEYXRlLm5vdygpIC0gMTgwMDAwMCB9IGFzIFNjYWxhciwgLy8gMzAgbWludXRlcyBhZ29cbiAgICAgIHsgZGF0ZVZhbHVlOiAxNzA0MDY3MjAwMDAwIH0gYXMgU2NhbGFyLCAvLyBKYW4gMSwgMjAyNFxuICAgICAgeyBkYXlEdXJhdGlvbjogNDUgfSBhcyBTY2FsYXIsXG4gICAgICB7IG1vbmV0YXJ5VmFsdWU6IDUwMDAwMCB9IGFzIFNjYWxhcixcbiAgICAgIHsgZHVyYXRpb25NczogNTQwMDAwMCB9IGFzIFNjYWxhciAvLyAxLjUgaG91cnNcbiAgICBdLFxuICAgIFtcbiAgICAgIHsgc3RyaW5nVmFsdWU6ICdTdGF0aXN0aWNhbCBFZGdlJyB9IGFzIFNjYWxhcixcbiAgICAgIHsgaW50ZWdlclZhbHVlOiAxMDA1IH0gYXMgU2NhbGFyLFxuICAgICAgeyBkZWNpbWFsVmFsdWU6IDAuMCB9IGFzIFNjYWxhcixcbiAgICAgIHsgcGVyY2VudFZhbHVlOiAwLjAgfSBhcyBTY2FsYXIsXG4gICAgICB7IGJvb2xlYW5WYWx1ZTogZmFsc2UgfSBhcyBTY2FsYXIsXG4gICAgICB7IHRpbWVzdGFtcE1zOiBEYXRlLm5vdygpIH0gYXMgU2NhbGFyLCAvLyBub3dcbiAgICAgIHsgZGF0ZVZhbHVlOiBEYXRlLm5vdygpIH0gYXMgU2NhbGFyLCAvLyB0b2RheVxuICAgICAgeyBkYXlEdXJhdGlvbjogMSB9IGFzIFNjYWxhcixcbiAgICAgIHsgbW9uZXRhcnlWYWx1ZTogMCB9IGFzIFNjYWxhcixcbiAgICAgIHsgZHVyYXRpb25NczogMzAwMDAwIH0gYXMgU2NhbGFyIC8vIDUgbWludXRlc1xuICAgIF1cbiAgXVxuXG4gIHJldHVybiB7XG4gICAgaGVhZGVycyxcbiAgICByb3dzLFxuICAgIGNvbHVtblR5cGVzXG4gIH1cbn0iXSwibmFtZXMiOlsiRXBvY2hGb2xpb1R5cGUiLCJjcmVhdGVNb2NrVGFibGVEYXRhIiwiaGVhZGVycyIsImNvbHVtblR5cGVzIiwiVHlwZVN0cmluZyIsIlR5cGVJbnRlZ2VyIiwiVHlwZURlY2ltYWwiLCJUeXBlUGVyY2VudCIsIlR5cGVCb29sZWFuIiwiVHlwZURhdGVUaW1lIiwiVHlwZURhdGUiLCJUeXBlRGF5RHVyYXRpb24iLCJUeXBlTW9uZXRhcnkiLCJUeXBlRHVyYXRpb24iLCJyb3dzIiwic3RyaW5nVmFsdWUiLCJpbnRlZ2VyVmFsdWUiLCJkZWNpbWFsVmFsdWUiLCJwZXJjZW50VmFsdWUiLCJib29sZWFuVmFsdWUiLCJ0aW1lc3RhbXBNcyIsIkRhdGUiLCJub3ciLCJkYXRlVmFsdWUiLCJkYXlEdXJhdGlvbiIsIm1vbmV0YXJ5VmFsdWUiLCJkdXJhdGlvbk1zIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/utils/tableMocks.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fadesola%2FEpochLab%2FEpochDashboard%2Fjs%2Fpages%2Findex.tsx&page=%2F!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);